{"version":3,"file":"han-excel.cjs.js","sources":["../src/utils/EventEmitter.ts","../src/types/core.types.ts","../src/core/Worksheet.ts","../src/types/builder.types.ts","../src/core/ExcelBuilder.ts","../src/types/reader.types.ts","../src/styles/StyleBuilder.ts","../src/types/cell.types.ts","../src/types/worksheet.types.ts","../src/types/style.types.ts","../src/core/ExcelReader.ts"],"sourcesContent":["/**\r\n * Simple EventEmitter implementation\r\n */\r\n\r\n/**\r\n * Event listener function type\r\n */\r\nexport type EventListener<T = any> = (event: T) => void | Promise<void>;\r\n\r\n/**\r\n * Event listener options\r\n */\r\nexport interface EventListenerOptions {\r\n  /** Whether to execute the listener only once */\r\n  once?: boolean;\r\n  /** Whether to execute the listener asynchronously */\r\n  async?: boolean;\r\n  /** Priority of the listener (higher = executed first) */\r\n  priority?: number;\r\n  /** Whether to stop event propagation */\r\n  stopPropagation?: boolean;\r\n}\r\n\r\n/**\r\n * Event listener registration\r\n */\r\nexport interface EventListenerRegistration {\r\n  /** Event type */\r\n  type: string;\r\n  /** Listener function */\r\n  listener: EventListener;\r\n  /** Listener options */\r\n  options: EventListenerOptions;\r\n  /** Registration ID */\r\n  id: string;\r\n  /** Whether the listener is active */\r\n  active: boolean;\r\n  /** Registration timestamp */\r\n  timestamp: Date;\r\n}\r\n\r\n/**\r\n * EventEmitter class for handling events\r\n */\r\nexport class EventEmitter {\r\n  private listeners: Map<string, EventListenerRegistration[]> = new Map();\r\n\r\n  /**\r\n   * Add an event listener\r\n   */\r\n  on<T = any>(type: string, listener: EventListener<T>, options: EventListenerOptions = {}): string {\r\n    if (!this.listeners.has(type)) {\r\n      this.listeners.set(type, []);\r\n    }\r\n\r\n    const registration: EventListenerRegistration = {\r\n      type,\r\n      listener: listener as EventListener,\r\n      options: {\r\n        once: false,\r\n        async: false,\r\n        priority: 0,\r\n        stopPropagation: false,\r\n        ...options\r\n      },\r\n      id: this.generateId(),\r\n      active: true,\r\n      timestamp: new Date()\r\n    };\r\n\r\n    this.listeners.get(type)!.push(registration);\r\n    \r\n    // Sort by priority (higher priority first)\r\n    this.listeners.get(type)!.sort((a, b) => (b.options.priority || 0) - (a.options.priority || 0));\r\n\r\n    return registration.id;\r\n  }\r\n\r\n  /**\r\n   * Add a one-time event listener\r\n   */\r\n  once<T = any>(type: string, listener: EventListener<T>, options: EventListenerOptions = {}): string {\r\n    return this.on(type, listener, { ...options, once: true });\r\n  }\r\n\r\n  /**\r\n   * Remove an event listener\r\n   */\r\n  off(type: string, listenerId: string): boolean {\r\n    const listeners = this.listeners.get(type);\r\n    if (!listeners) {\r\n      return false;\r\n    }\r\n\r\n    const index = listeners.findIndex(reg => reg.id === listenerId);\r\n    if (index === -1) {\r\n      return false;\r\n    }\r\n\r\n    listeners.splice(index, 1);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Remove all listeners for an event type\r\n   */\r\n  offAll(type: string): number {\r\n    const listeners = this.listeners.get(type);\r\n    if (!listeners) {\r\n      return 0;\r\n    }\r\n\r\n    const count = listeners.length;\r\n    this.listeners.delete(type);\r\n    return count;\r\n  }\r\n\r\n  /**\r\n   * Emit an event\r\n   */\r\n  async emit<T = any>(event: T): Promise<void> {\r\n    const type = (event as any).type || 'default';\r\n    const listeners = this.listeners.get(type);\r\n    \r\n    if (!listeners || listeners.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const activeListeners = listeners.filter(reg => reg.active);\r\n    \r\n    for (const registration of activeListeners) {\r\n      try {\r\n        if (registration.options.once) {\r\n          registration.active = false;\r\n        }\r\n\r\n        if (registration.options.async) {\r\n          await registration.listener(event);\r\n        } else {\r\n          registration.listener(event);\r\n        }\r\n\r\n        if (registration.options.stopPropagation) {\r\n          break;\r\n        }\r\n      } catch (error) {\r\n        console.error(`Error in event listener for ${type}:`, error);\r\n      }\r\n    }\r\n\r\n    // Clean up inactive listeners\r\n    this.cleanupInactiveListeners(type);\r\n  }\r\n\r\n  /**\r\n   * Emit an event synchronously\r\n   */\r\n  emitSync<T = any>(event: T): void {\r\n    const type = (event as any).type || 'default';\r\n    const listeners = this.listeners.get(type);\r\n    \r\n    if (!listeners || listeners.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const activeListeners = listeners.filter(reg => reg.active);\r\n    \r\n    for (const registration of activeListeners) {\r\n      try {\r\n        if (registration.options.once) {\r\n          registration.active = false;\r\n        }\r\n\r\n        registration.listener(event);\r\n\r\n        if (registration.options.stopPropagation) {\r\n          break;\r\n        }\r\n      } catch (error) {\r\n        console.error(`Error in event listener for ${type}:`, error);\r\n      }\r\n    }\r\n\r\n    // Clean up inactive listeners\r\n    this.cleanupInactiveListeners(type);\r\n  }\r\n\r\n  /**\r\n   * Clear all listeners\r\n   */\r\n  clear(): void {\r\n    this.listeners.clear();\r\n  }\r\n\r\n  /**\r\n   * Get listeners for an event type\r\n   */\r\n  getListeners(type: string): EventListenerRegistration[] {\r\n    return this.listeners.get(type) || [];\r\n  }\r\n\r\n  /**\r\n   * Get listener count for an event type\r\n   */\r\n  getListenerCount(type: string): number {\r\n    return this.listeners.get(type)?.length || 0;\r\n  }\r\n\r\n  /**\r\n   * Get all registered event types\r\n   */\r\n  getEventTypes(): string[] {\r\n    return Array.from(this.listeners.keys());\r\n  }\r\n\r\n  // Private methods\r\n\r\n  private generateId(): string {\r\n    return Math.random().toString(36).substr(2, 9);\r\n  }\r\n\r\n  private cleanupInactiveListeners(type: string): void {\r\n    const listeners = this.listeners.get(type);\r\n    if (listeners) {\r\n      const activeListeners = listeners.filter(reg => reg.active);\r\n      if (activeListeners.length !== listeners.length) {\r\n        this.listeners.set(type, activeListeners);\r\n      }\r\n    }\r\n  }\r\n} ","/**\n * Core type definitions for Han Excel Builder\n */\n\nimport { CellValue } from 'exceljs';\n\n/**\n * Supported cell data types\n */\nexport enum CellType {\n  STRING = 'string',\n  NUMBER = 'number',\n  BOOLEAN = 'boolean',\n  DATE = 'date',\n  PERCENTAGE = 'percentage',\n  CURRENCY = 'currency',\n  LINK = 'link',\n  FORMULA = 'formula'\n}\n\n/**\n * Number format options\n */\nexport enum NumberFormat {\n  GENERAL = 'General',\n  NUMBER = '#,##0',\n  NUMBER_DECIMALS = '#,##0.00',\n  CURRENCY = '$#,##0.00',\n  CURRENCY_INTEGER = '$#,##0',\n  PERCENTAGE = '0%',\n  PERCENTAGE_DECIMALS = '0.00%',\n  DATE = 'dd/mm/yyyy',\n  DATE_TIME = 'dd/mm/yyyy hh:mm',\n  TIME = 'hh:mm:ss',\n  CUSTOM = 'custom'\n}\n\n/**\n * Horizontal alignment options\n */\nexport enum HorizontalAlignment {\n  LEFT = 'left',\n  CENTER = 'center',\n  RIGHT = 'right',\n  FILL = 'fill',\n  JUSTIFY = 'justify',\n  CENTER_CONTINUOUS = 'centerContinuous',\n  DISTRIBUTED = 'distributed'\n}\n\n/**\n * Vertical alignment options\n */\nexport enum VerticalAlignment {\n  TOP = 'top',\n  MIDDLE = 'middle',\n  BOTTOM = 'bottom',\n  DISTRIBUTED = 'distributed',\n  JUSTIFY = 'justify'\n}\n\n/**\n * Border style options\n */\nexport enum BorderStyle {\n  THIN = 'thin',\n  MEDIUM = 'medium',\n  THICK = 'thick',\n  DOTTED = 'dotted',\n  DASHED = 'dashed',\n  DOUBLE = 'double',\n  HAIR = 'hair',\n  MEDIUM_DASHED = 'mediumDashed',\n  DASH_DOT = 'dashDot',\n  MEDIUM_DASH_DOT = 'mediumDashDot',\n  DASH_DOT_DOT = 'dashDotDot',\n  MEDIUM_DASH_DOT_DOT = 'mediumDashDotDot',\n  SLANT_DASH_DOT = 'slantDashDot'\n}\n\n/**\n * Font style options\n */\nexport enum FontStyle {\n  NORMAL = 'normal',\n  BOLD = 'bold',\n  ITALIC = 'italic',\n  BOLD_ITALIC = 'bold italic'\n}\n\n/**\n * Color type - can be hex string, RGB object, or theme color\n */\nexport type Color = string | { r: number; g: number; b: number } | { theme: number };\n\n/**\n * Base cell properties interface\n */\nexport interface IBaseCell {\n  /** Unique identifier for the cell */\n  key: string;\n  /** Cell data type */\n  type: CellType;\n  /** Cell value */\n  value: CellValue;\n  /** Optional cell reference (e.g., A1, B2) */\n  reference?: string;\n  /** Whether to merge this cell with others */\n  mergeCell?: boolean;\n  /** Number of columns to merge (if mergeCell is true) */\n  mergeTo?: number;\n  /** Row height for this cell */\n  rowHeight?: number;\n  /** Column width for this cell */\n  colWidth?: number;\n  /** Whether to move to next row after this cell */\n  jump?: boolean;\n  /** Hyperlink URL */\n  link?: string;\n  /** Text mask for hyperlink (displayed text when link is present) */\n  mask?: string;\n  /** Excel formula */\n  formula?: string;\n  /** Number format for numeric cells */\n  numberFormat?: NumberFormat | string;\n  /** Custom number format string */\n  customNumberFormat?: string;\n  /** Whether the cell is protected */\n  protected?: boolean;\n  /** Whether the cell is hidden */\n  hidden?: boolean;\n  /** Cell comment */\n  comment?: string;\n  /** Data validation rules */\n  validation?: IDataValidation;\n  /** Optional styles for the cell */\n  styles?: import('./style.types').IStyle;\n  /** Legacy children cells */\n  childrens?: IBaseCell[];\n  /** Modern children cells */\n  children?: IBaseCell[];\n}\n\n/**\n * Data validation interface\n */\nexport interface IDataValidation {\n  /** Validation type */\n  type: 'list' | 'whole' | 'decimal' | 'textLength' | 'date' | 'time' | 'custom';\n  /** Validation operator */\n  operator?: 'between' | 'notBetween' | 'equal' | 'notEqual' | 'greaterThan' | 'lessThan' | 'greaterThanOrEqual' | 'lessThanOrEqual';\n  /** Validation formula or values */\n  formula1?: string | number | Date;\n  /** Second validation formula or value (for between/notBetween) */\n  formula2?: string | number | Date;\n  /** Whether to show error message */\n  showErrorMessage?: boolean;\n  /** Error message text */\n  errorMessage?: string;\n  /** Whether to show input message */\n  showInputMessage?: boolean;\n  /** Input message text */\n  inputMessage?: string;\n  /** Whether to allow blank values */\n  allowBlank?: boolean;\n}\n\n/**\n * Workbook metadata interface\n */\nexport interface IWorkbookMetadata {\n  /** Workbook author */\n  author?: string;\n  /** Workbook title */\n  title?: string;\n  /** Workbook subject */\n  subject?: string;\n  /** Workbook keywords */\n  keywords?: string;\n  /** Workbook category */\n  category?: string;\n  /** Workbook description */\n  description?: string;\n  /** Workbook company */\n  company?: string;\n  /** Workbook manager */\n  manager?: string;\n  /** Creation date */\n  created?: Date;\n  /** Last modified date */\n  modified?: Date;\n  /** Application name */\n  application?: string;\n  /** Application version */\n  appVersion?: string;\n  /** Hyperlink base */\n  hyperlinkBase?: string;\n}\n\n/**\n * Error types for validation\n */\nexport enum ErrorType {\n  VALIDATION_ERROR = 'VALIDATION_ERROR',\n  BUILD_ERROR = 'BUILD_ERROR',\n  STYLE_ERROR = 'STYLE_ERROR',\n  WORKSHEET_ERROR = 'WORKSHEET_ERROR',\n  CELL_ERROR = 'CELL_ERROR'\n}\n\n/**\n * Error interface\n */\nexport interface IError {\n  type: ErrorType;\n  message: string;\n  code?: string;\n  details?: Record<string, unknown>;\n  stack?: string;\n}\n\n/**\n * Success result interface\n */\nexport interface ISuccessResult<T = unknown> {\n  success: true;\n  data: T;\n  message?: string;\n}\n\n/**\n * Error result interface\n */\nexport interface IErrorResult {\n  success: false;\n  error: IError;\n}\n\n/**\n * Result union type\n */\nexport type Result<T = unknown> = ISuccessResult<T> | IErrorResult; ","import ExcelJS from 'exceljs';\nimport {\n  IWorksheet,\n  IWorksheetConfig,\n  ITable\n} from '../types/worksheet.types';\nimport {\n  IDataCell,\n  IHeaderCell,\n  IFooterCell\n} from '../types/cell.types';\nimport { IBuildOptions } from '../types/builder.types';\nimport { Result, ErrorType, CellType } from '../types/core.types';\n\n/**\n * Worksheet - Representa una hoja de cálculo dentro del builder\n *\n2 * Soporta headers, subheaders anidados, rows, footers, children y estilos por celda.\n */\nexport class Worksheet implements IWorksheet {\n  public config: IWorksheetConfig;\n  public tables: ITable[] = [];\n  public currentRow = 1;\n  public currentCol = 1;\n  public headerPointers: Map<string, any> = new Map();\n  public isBuilt = false;\n\n  // Estructuras temporales para la tabla actual\n  private headers: IHeaderCell[] = [];\n  private subHeaders: IHeaderCell[] = [];\n  private body: IDataCell[] = [];\n  private footers: IFooterCell[] = [];\n\n  constructor(config: IWorksheetConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Agrega un header principal\n   */\n  addHeader(header: IHeaderCell): this {\n    this.headers.push(header);\n    return this;\n  }\n\n  /**\n   * Agrega subheaders (ahora soporta anidación)\n   */\n  addSubHeaders(subHeaders: IHeaderCell[]): this {\n    this.subHeaders.push(...subHeaders);\n    return this;\n  }\n\n  /**\n   * Agrega una fila de datos (puede ser jerárquica con childrens)\n   */\n  addRow(row: IDataCell[] | IDataCell): this {\n    if (Array.isArray(row)) {\n      this.body.push(...row);\n    } else {\n      this.body.push(row);\n    }\n    return this;\n  }\n\n  /**\n   * Agrega un footer o varios\n   */\n  addFooter(footer: IFooterCell[] | IFooterCell): this {\n    if (Array.isArray(footer)) {\n      this.footers.push(...footer);\n    } else {\n      this.footers.push(footer);\n    }\n    return this;\n  }\n\n  /**\n   * Crea una nueva tabla y la agrega al worksheet\n   */\n  addTable(tableConfig: Partial<ITable> = {}): this {\n    const table: ITable = {\n      name: tableConfig.name || `Table_${this.tables.length + 1}`,\n      headers: tableConfig.headers || [],\n      subHeaders: tableConfig.subHeaders || [],\n      body: tableConfig.body || [],\n      footers: tableConfig.footers || [],\n      showBorders: tableConfig.showBorders !== false,\n      showStripes: tableConfig.showStripes !== false,\n      style: tableConfig.style || 'TableStyleLight1',\n      ...tableConfig\n    };\n    \n    this.tables.push(table);\n    return this;\n  }\n\n  /**\n   * Finaliza la tabla actual agregando todos los elementos temporales a la última tabla\n   */\n  finalizeTable(): this {\n    if (this.tables.length === 0) {\n      // Si no hay tablas, crear una nueva con los datos temporales\n      this.addTable();\n    }\n    \n    const currentTable = this.tables[this.tables.length - 1];\n    if (!currentTable) {\n      throw new Error('No se pudo obtener la tabla actual');\n    }\n    \n    // Agregar headers, subheaders, body y footers a la tabla actual\n    if (this.headers.length > 0) {\n      currentTable.headers = [...(currentTable.headers || []), ...this.headers];\n    }\n    \n    if (this.subHeaders.length > 0) {\n      currentTable.subHeaders = [...(currentTable.subHeaders || []), ...this.subHeaders];\n    }\n    \n    if (this.body.length > 0) {\n      currentTable.body = [...(currentTable.body || []), ...this.body];\n    }\n    \n    if (this.footers.length > 0) {\n      currentTable.footers = [...(currentTable.footers || []), ...this.footers];\n    }\n    \n    // Limpiar las estructuras temporales\n    this.headers = [];\n    this.subHeaders = [];\n    this.body = [];\n    this.footers = [];\n    \n    return this;\n  }\n\n  /**\n   * Obtiene una tabla por nombre\n   */\n  getTable(name: string): ITable | undefined {\n    return this.tables.find(table => table.name === name);\n  }\n\n  /**\n   * Construye la hoja en el workbook de ExcelJS\n   */\n  async build(workbook: ExcelJS.Workbook, _options: IBuildOptions = {}): Promise<void> {\n    const ws = workbook.addWorksheet(this.config.name, {\n      properties: {\n        defaultRowHeight: this.config.defaultRowHeight || 20,\n        tabColor: this.config.tabColor as any\n      },\n      pageSetup: this.config.pageSetup as any\n    });\n\n    let rowPointer = 1;\n    \n    // Si hay tablas definidas, construir cada tabla\n    if (this.tables.length > 0) {\n      for (let i = 0; i < this.tables.length; i++) {\n        const table = this.tables[i];\n        if (table) {\n          rowPointer = await this.buildTable(ws, table, rowPointer, i > 0);\n        }\n      }\n    } else {\n      // Construcción tradicional para compatibilidad hacia atrás\n      rowPointer = await this.buildLegacyContent(ws, rowPointer);\n    }\n    \n    this.isBuilt = true;\n  }\n\n  /**\n   * Construye una tabla individual en el worksheet\n   */\n  private async buildTable(ws: ExcelJS.Worksheet, table: ITable, startRow: number, addSpacing: boolean = false): Promise<number> {\n    let rowPointer = startRow;\n    \n    // Agregar espacio entre tablas si no es la primera\n    if (addSpacing) {\n      rowPointer += 2; // 2 filas de espacio\n    }\n    \n    // Headers principales de la tabla\n    if (table.headers && table.headers.length > 0) {\n      for (const header of table.headers) {\n        ws.addRow([this.processCellValue(header)]);\n        if (header.mergeCell) {\n          const maxCols = this.calculateTableMaxColumns(table);\n          ws.mergeCells(rowPointer, 1, rowPointer, maxCols);\n        }\n        if (header.styles) {\n          ws.getRow(rowPointer).eachCell((cell: any) => {\n            cell.style = this.convertStyle(header.styles);\n          });\n        }\n        // Aplicar dimensiones de celda\n        this.applyCellDimensions(ws, rowPointer, 1, header);\n        rowPointer++;\n      }\n    }\n    \n    // SubHeaders con soporte para anidación\n    if (table.subHeaders && table.subHeaders.length > 0) {\n      rowPointer = this.buildNestedHeaders(ws, rowPointer, table.subHeaders);\n    }\n    \n    // Body (soporta children)\n    if (table.body && table.body.length > 0) {\n      for (const row of table.body) {\n        rowPointer = this.addDataRowRecursive(ws, rowPointer, row);\n      }\n    }\n    \n    // Footers\n    if (table.footers && table.footers.length > 0) {\n      for (const footer of table.footers) {\n        rowPointer = this.addFooterRow(ws, rowPointer, footer);\n      }\n    }\n    \n    // Aplicar estilo de tabla si está configurado\n    if (table.showBorders || table.showStripes) {\n      this.applyTableStyle(ws, table, startRow, rowPointer - 1);\n    }\n    \n    return rowPointer;\n  }\n\n  /**\n   * Construcción tradicional para compatibilidad hacia atrás\n   */\n  private async buildLegacyContent(ws: ExcelJS.Worksheet, startRow: number): Promise<number> {\n    let rowPointer = startRow;\n    \n    // Headers principales\n    if (this.headers.length > 0) {\n      this.headers.forEach(header => {\n        ws.addRow([this.processCellValue(header)]);\n        if (header.mergeCell) {\n          ws.mergeCells(rowPointer, 1, rowPointer, (this.getMaxColumns() || 1));\n        }\n        if (header.styles) {\n          ws.getRow(rowPointer).eachCell((cell: any) => {\n            cell.style = this.convertStyle(header.styles);\n          });\n        }\n        // Aplicar dimensiones de celda\n        this.applyCellDimensions(ws, rowPointer, 1, header);\n        rowPointer++;\n      });\n    }\n    \n    // SubHeaders con soporte para anidación\n    if (this.subHeaders.length > 0) {\n      rowPointer = this.buildNestedHeaders(ws, rowPointer, this.subHeaders);\n    }\n    \n    // Body (soporta children)\n    for (const row of this.body) {\n      rowPointer = this.addDataRowRecursive(ws, rowPointer, row);\n    }\n    \n    // Footers\n    if (this.footers.length > 0) {\n      for (const footer of this.footers) {\n        rowPointer = this.addFooterRow(ws, rowPointer, footer);\n      }\n    }\n    \n    return rowPointer;\n  }\n\n  /**\n   * Calcula el número máximo de columnas para una tabla\n   */\n  private calculateTableMaxColumns(table: ITable): number {\n    let maxCols = 0;\n    \n    if (table.subHeaders && table.subHeaders.length > 0) {\n      for (const header of table.subHeaders) {\n        maxCols += this.calculateHeaderColSpan(header);\n      }\n    }\n    \n    return maxCols || 1;\n  }\n\n  /**\n   * Aplica el estilo de tabla a un rango específico\n   */\n  private applyTableStyle(ws: ExcelJS.Worksheet, table: ITable, startRow: number, endRow: number): void {\n    const maxCols = this.calculateTableMaxColumns(table);\n    \n    // Aplicar bordes si está configurado\n    if (table.showBorders) {\n      for (let row = startRow; row <= endRow; row++) {\n        for (let col = 1; col <= maxCols; col++) {\n          const cell = ws.getRow(row).getCell(col);\n          if (!cell.style) cell.style = {};\n          if (!cell.style.border) {\n            cell.style.border = {\n              top: { style: 'thin', color: { argb: 'FF8EAADB' } },\n              left: { style: 'thin', color: { argb: 'FF8EAADB' } },\n              bottom: { style: 'thin', color: { argb: 'FF8EAADB' } },\n              right: { style: 'thin', color: { argb: 'FF8EAADB' } }\n            };\n          }\n        }\n      }\n    }\n    \n    // Aplicar rayas alternadas si está configurado\n    if (table.showStripes) {\n      for (let row = startRow; row <= endRow; row++) {\n        if ((row - startRow) % 2 === 1) { // Filas impares (empezando desde 0)\n          for (let col = 1; col <= maxCols; col++) {\n            const cell = ws.getRow(row).getCell(col);\n            if (!cell.style) cell.style = {};\n            if (!cell.style.fill) {\n              cell.style.fill = {\n                type: 'pattern',\n                pattern: 'solid',\n                fgColor: { argb: 'FFF2F2F2' }\n              };\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Construye headers anidados recursivamente\n   * @param ws - Worksheet de ExcelJS\n   * @param startRow - Fila inicial\n   * @param headers - Array de headers a procesar\n   * @returns La siguiente fila disponible\n   */\n    private buildNestedHeaders(ws: ExcelJS.Worksheet, startRow: number, headers: IHeaderCell[]): number {\n    let currentRow = startRow;\n    const maxDepth = this.getMaxHeaderDepth(headers);\n    \n    // Crear filas para cada nivel de profundidad\n    for (let depth = 0; depth < maxDepth; depth++) {\n      // Crear la fila primero\n      const row = ws.getRow(currentRow);\n      \n      // Procesar cada header en este nivel\n      let colIndex = 1;\n      for (const header of headers) {\n        if (depth === 0) {\n          // Nivel principal del header\n          const headerInfo = this.getHeaderAtDepth(header, depth, colIndex);\n          const cell = row.getCell(colIndex);\n          cell.value = this.processCellValue(header);\n          if (headerInfo.style) {\n            cell.style = this.convertStyle(headerInfo.style);\n          }\n          // Aplicar dimensiones de celda\n          this.applyCellDimensions(ws, currentRow, colIndex, header);\n          colIndex += headerInfo.colSpan;\n        } else {\n          // Nivel de children - procesar todos los children directos\n          if (header.children && header.children.length > 0) {\n            for (const child of header.children) {\n              const cell = row.getCell(colIndex);\n              cell.value = this.processCellValue(child);\n              if (child.styles || header.styles) {\n                cell.style = this.convertStyle(child.styles || header.styles);\n              }\n              // Aplicar dimensiones de celda para children\n              this.applyCellDimensions(ws, currentRow, colIndex, child);\n              colIndex += this.calculateHeaderColSpan(child);\n            }\n          } else {\n            // Si no tiene children, agregar celda vacía\n            const cell = row.getCell(colIndex);\n            cell.value = null;\n            colIndex += 1;\n          }\n        }\n      }\n      \n      currentRow++;\n    }\n    \n    // Aplicar todos los merges después de crear todas las filas\n    this.applyAllMerges(ws, startRow, currentRow - 1, headers);\n    \n    return currentRow;\n  }\n\n  /**\n   * Obtiene información del header en una profundidad específica\n   */\n  private getHeaderAtDepth(header: IHeaderCell, depth: number, startCol: number): {\n    value: string | null;\n    style: any;\n    colSpan: number;\n    mergeRange?: { start: number; end: number } | null;\n  } {\n    const colSpan = this.calculateHeaderColSpan(header);\n    if (depth === 0) {\n      // Nivel principal del header\n      const mergeRange = colSpan > 1 ? { start: startCol, end: startCol + colSpan - 1 } : null;\n      return {\n        value: typeof header.value === 'string' ? header.value : String(header.value || ''),\n        style: header.styles,\n        colSpan,\n        mergeRange: mergeRange\n      };\n    } else if (header.children && header.children.length > 0) {\n      // Nivel de children\n      const child = header.children[depth];\n      if (child) {\n        const childColSpan = this.calculateHeaderColSpan(child);\n        // Los children también pueden hacer merge si tienen múltiples childrens\n        const mergeRange = childColSpan > 1 ? { start: startCol, end: startCol + childColSpan - 1 } : null;\n        \n        return {\n          value: typeof child.value === 'string' ? child.value : String(child.value || ''),\n          style: child.styles || header.styles,\n          colSpan: childColSpan,\n          mergeRange: mergeRange\n        };\n      }\n    }\n    \n    // Celda vacía para mantener alineación\n    return {\n      value: null,\n      style: null,\n      colSpan: 1\n    };\n  }\n\n\n\n\n  /**\n   * Aplica todos los merges (horizontales y verticales) después de crear todas las filas\n   */\n  private applyAllMerges(ws: ExcelJS.Worksheet, startRow: number, endRow: number, headers: IHeaderCell[]): void {\n    const maxDepth = this.getMaxHeaderDepth(headers);\n    \n    // Solo aplicar merges si hay más de una fila de headers\n    if (maxDepth <= 1) return;\n    \n    // Aplicar merges inteligentes basados en la estructura\n    this.applySmartMerges(ws, startRow, endRow, headers);\n  }\n\n  /**\n   * Aplica merges inteligentes basados en la estructura de headers\n   */\n  private applySmartMerges(ws: ExcelJS.Worksheet, startRow: number, endRow: number, headers: IHeaderCell[]): void {\n    const maxDepth = this.getMaxHeaderDepth(headers);\n    \n    // Solo aplicar merges si hay más de una fila de headers\n    if (maxDepth <= 1) return;\n    \n    // Aplicar merges para cada header\n    let colIndex = 1;\n    for (const header of headers) {\n      this.applySmartMergesForHeader(ws, startRow, endRow, header, colIndex);\n      colIndex += this.calculateHeaderColSpan(header);\n    }\n  }\n\n  /**\n   * Aplica merges inteligentes para un header específico\n   */\n  private applySmartMergesForHeader(ws: ExcelJS.Worksheet, startRow: number, endRow: number, header: IHeaderCell, startCol: number): void {\n    const headerColSpan = this.calculateHeaderColSpan(header);\n    \n    if (!header.children || header.children.length === 0) {\n      // Si no tiene children, hacer merge vertical desde la primera fila hasta la última\n      ws.mergeCells(startRow, startCol, endRow, startCol + headerColSpan - 1);\n    } else {\n      // Si tiene children, aplicar merge horizontal en la primera fila\n      if (headerColSpan > 1) {\n        ws.mergeCells(startRow, startCol, startRow, startCol + headerColSpan - 1);\n      }\n      \n      // Procesar children recursivamente\n      let childColIndex = startCol;\n      for (const child of header.children) {\n        this.applySmartMergesForHeader(ws, startRow + 1, endRow, child, childColIndex);\n        childColIndex += this.calculateHeaderColSpan(child);\n      }\n    }\n  }\n\n\n \n  /**\n   * Calcula el span de columnas para un header\n   */\n  private calculateHeaderColSpan(header: IHeaderCell): number {\n    if (!header.children || header.children.length === 0) {\n      return 1;\n    }\n    \n    return header.children.reduce((total, child) => {\n      return total + this.calculateHeaderColSpan(child);\n    }, 0);\n  }\n\n  /**\n   * Obtiene la profundidad máxima de headers anidados\n   */\n  private getMaxHeaderDepth(headers: IHeaderCell[]): number {\n    let maxDepth = 1;\n    \n    for (const header of headers) {\n      if (header.children && header.children.length > 0) {\n        const childDepth = this.getMaxHeaderDepth(header.children);\n        maxDepth = Math.max(maxDepth, childDepth + 1);\n      }\n    }\n    \n    return maxDepth;\n  }\n\n  /**\n   * Obtiene el número máximo de columnas\n   */\n  private getMaxColumns(): number {\n    let maxCols = 0;\n    \n    for (const header of this.subHeaders) {\n      maxCols += this.calculateHeaderColSpan(header);\n    }\n    \n    return maxCols;\n  }\n\n  /**\n   * Valida la hoja\n   */\n  validate(): Result<boolean> {\n    if (!this.headers.length && !this.body.length) {\n      return {\n        success: false,\n        error: {\n          type: ErrorType.VALIDATION_ERROR,\n          message: 'La hoja no tiene datos',\n        }\n      };\n    }\n    return { success: true, data: true };\n  }\n\n  /**\n   * Calcula las posiciones de columnas para los datos basándose en la estructura de subheaders\n   */\n  private calculateDataColumnPositions(): { [key: string]: number } {\n    const positions: { [key: string]: number } = {};\n    let currentCol = 1;\n    \n    for (const header of this.subHeaders) {\n      if (header.children && header.children.length > 0) {\n        // Si el header tiene children, cada child ocupa una columna\n        for (const child of header.children) {\n          if (child.key) {\n            positions[child.key] = currentCol;\n          }\n          if (child.value) {\n            positions[String(child.value)] = currentCol;\n          }\n          currentCol++;\n        }\n      } else {\n        // Si el header no tiene children, ocupa una columna\n        if (header.key) {\n          positions[header.key] = currentCol;\n        }\n        if (header.value) {\n          positions[String(header.value)] = currentCol;\n        }\n        currentCol++;\n      }\n    }\n    \n    return positions;\n  }\n\n  /**\n   * Agrega una fila de footer\n   * @returns el siguiente rowPointer disponible\n   */\n  private addFooterRow(ws: ExcelJS.Worksheet, rowPointer: number, footer: IFooterCell): number {\n    // Calcular las columnas basándose en la estructura de subheaders\n    const columnPositions = this.calculateDataColumnPositions();\n    \n    // Buscar la columna correcta para el footer\n    let footerColPosition: number | undefined;\n    \n    // Intentar encontrar por key primero\n    if (footer.key && columnPositions[footer.key]) {\n      footerColPosition = columnPositions[footer.key];\n    }\n    // Si no se encuentra por key, intentar por header\n    else if (footer.header && columnPositions[footer.header]) {\n      footerColPosition = columnPositions[footer.header];\n    }\n    \n    // Si no se encuentra la posición, usar columna 1 por defecto\n    if (footerColPosition === undefined) {\n      footerColPosition = 1;\n    }\n    \n    // Escribir el footer en la columna correcta\n    const excelRow = ws.getRow(rowPointer);\n    const footerCell = excelRow.getCell(footerColPosition);\n    footerCell.value = this.processCellValue(footer);\n    if (footer.styles) {\n      footerCell.style = this.convertStyle(footer.styles);\n    }\n    if (footer.numberFormat) {\n      footerCell.numFmt = footer.numberFormat;\n    }\n    \n    // Aplicar dimensiones de celda\n    this.applyCellDimensions(ws, rowPointer, footerColPosition, footer);\n    \n    // Aplicar merge si está configurado\n    if (footer.mergeCell && footer.mergeTo) {\n      ws.mergeCells(rowPointer, footerColPosition, rowPointer, footer.mergeTo);\n    }\n    \n    // Si hay children, escribirlos en las columnas correspondientes\n    if (footer.children && footer.children.length > 0) {\n      for (const child of footer.children) {\n        if (child) {\n          // Buscar la columna correcta basándose en el header del child\n          let colPosition: number | undefined;\n          \n          // Intentar encontrar por key primero\n          if (child.key && columnPositions[child.key]) {\n            colPosition = columnPositions[child.key];\n          }\n          // Si no se encuentra por key, intentar por header\n          else if (child.header && columnPositions[child.header]) {\n            colPosition = columnPositions[child.header];\n          }\n          \n          if (colPosition !== undefined) {\n            const childCell = excelRow.getCell(colPosition);\n            childCell.value = this.processCellValue(child);\n            if (child.styles) {\n              childCell.style = this.convertStyle(child.styles);\n            }\n            if (child.numberFormat) {\n              childCell.numFmt = child.numberFormat;\n            }\n            \n            // Aplicar dimensiones de celda para children\n            this.applyCellDimensions(ws, rowPointer, colPosition, child);\n          }\n        }\n      }\n    }\n    \n    // Incrementar rowPointer solo si el footer tiene la propiedad jump\n    if (footer.jump) {\n      return rowPointer + 1;\n    }\n    \n    return rowPointer;\n  }\n\n  /**\n   * Aplica width y height a una celda/fila\n   */\n  private applyCellDimensions(ws: ExcelJS.Worksheet, row: number, col: number, cell: IDataCell | IHeaderCell | IFooterCell): void {\n    // Aplicar rowHeight si está definido\n    if (cell.rowHeight !== undefined) {\n      const excelRow = ws.getRow(row);\n      excelRow.height = cell.rowHeight;\n    }\n    \n    // Aplicar colWidth si está definido\n    if (cell.colWidth !== undefined) {\n      const excelCol = ws.getColumn(col);\n      excelCol.width = cell.colWidth;\n    }\n  }\n\n  /**\n   * Procesa el valor de una celda considerando links y máscaras\n   * Si el tipo es LINK o hay un link, crea un hipervínculo en Excel\n   */\n  private processCellValue(cell: IDataCell | IHeaderCell | IFooterCell): ExcelJS.CellValue {\n    // Si hay un link o el tipo es LINK, crear hipervínculo\n    if (cell.link || cell.type === CellType.LINK) {\n      const linkUrl = cell.link || (typeof cell.value === 'string' ? cell.value : '');\n      \n      // Si no hay URL válida, retornar el valor normal\n      if (!linkUrl || linkUrl.trim() === '') {\n        return cell.value;\n      }\n      \n      // Determinar el texto visible: usar máscara si existe, sino usar value, sino usar la URL\n      const displayText = cell.mask || cell.value || linkUrl;\n      \n      // Crear objeto de hipervínculo para ExcelJS\n      return {\n        text: String(displayText),\n        hyperlink: linkUrl\n      } as any;\n    }\n    \n    // Si no hay link, retornar el valor normal\n    return cell.value;\n  }\n\n  /**\n   * Agrega una fila de datos y sus children recursivamente\n   * @returns el siguiente rowPointer disponible\n   */\n  private addDataRowRecursive(ws: ExcelJS.Worksheet, rowPointer: number, row: IDataCell): number {\n    // Calcular las columnas basándose en la estructura de subheaders\n    const columnPositions = this.calculateDataColumnPositions();\n\n    // Buscar la columna correcta para el dato principal\n    let mainColPosition: number | undefined;\n    \n    // Intentar encontrar por key primero\n    if (row.key && columnPositions[row.key]) {\n      mainColPosition = columnPositions[row.key];\n    }\n    // Si no se encuentra por key, intentar por header\n    else if (row.header && columnPositions[row.header]) {\n      mainColPosition = columnPositions[row.header];\n    }\n    \n    // Si no se encuentra la posición, usar columna 1 por defecto\n    if (mainColPosition === undefined) {\n      mainColPosition = 1;\n    }\n    \n    // Escribir el dato principal en la columna correcta\n    const excelRow = ws.getRow(rowPointer);\n    const mainCell = excelRow.getCell(mainColPosition);\n    mainCell.value = this.processCellValue(row);\n    if (row.styles) {\n      mainCell.style = this.convertStyle(row.styles);\n    }\n    if (row.numberFormat) {\n      mainCell.numFmt = row.numberFormat;\n    }\n    \n    // Aplicar dimensiones de celda\n    this.applyCellDimensions(ws, rowPointer, mainColPosition, row);\n    \n    // Si hay children, escribirlos en las columnas correspondientes\n    if (row.children && row.children.length > 0) {\n      for (const child of row.children) {\n        if (child) {\n          // Buscar la columna correcta basándose en el header del child\n          let colPosition: number | undefined;\n          \n          // Intentar encontrar por key primero\n          if (child.key && columnPositions[child.key]) {\n            colPosition = columnPositions[child.key];\n          }\n          // Si no se encuentra por key, intentar por header\n          else if (child.header && columnPositions[child.header]) {\n            colPosition = columnPositions[child.header];\n          }\n          \n          if (colPosition !== undefined) {\n            const childCell = excelRow.getCell(colPosition);\n            childCell.value = this.processCellValue(child);\n            if (child.styles) {\n              childCell.style = this.convertStyle(child.styles);\n            }\n            if (child.numberFormat) {\n              childCell.numFmt = child.numberFormat;\n            }\n            \n            // Aplicar dimensiones de celda para children\n            this.applyCellDimensions(ws, rowPointer, colPosition, child);\n          }\n        }\n      }\n    }\n    \n    // Incrementar rowPointer solo si la celda tiene la propiedad jump\n    if (row.jump) {\n      return rowPointer + 1;\n    }\n    \n    return rowPointer;\n  }\n\n  /**\n   * Convierte un color a formato ExcelJS (ARGB)\n   */\n  private convertColor(color: any): any {\n    if (!color) return undefined;\n    \n    // Si ya es un objeto con argb, retornarlo\n    if (typeof color === 'object' && color.argb) {\n      return color;\n    }\n    \n    // Si es un objeto con r, g, b\n    if (typeof color === 'object' && 'r' in color && 'g' in color && 'b' in color) {\n      const r = color.r.toString(16).padStart(2, '0');\n      const g = color.g.toString(16).padStart(2, '0');\n      const b = color.b.toString(16).padStart(2, '0');\n      return { argb: `FF${r}${g}${b}`.toUpperCase() };\n    }\n    \n    // Si es un string (hex)\n    if (typeof color === 'string') {\n      // Remover # si existe\n      let hex = color.replace('#', '');\n      \n      // Si es formato corto (RGB), expandirlo\n      if (hex.length === 3) {\n        hex = hex.split('').map(c => c + c).join('');\n      }\n      \n      // Asegurar que tenga alpha (FF = completamente opaco)\n      if (hex.length === 6) {\n        hex = 'FF' + hex.toUpperCase();\n      }\n      \n      return { argb: hex };\n    }\n    \n    // Si es un objeto theme\n    if (typeof color === 'object' && 'theme' in color) {\n      return color;\n    }\n    \n    return undefined;\n  }\n\n  /**\n   * Convierte el estilo personalizado a formato compatible con ExcelJS\n   */\n  private convertStyle(style: any): Partial<ExcelJS.Style> {\n    if (!style) return {};\n    \n    const converted: Partial<ExcelJS.Style> = {};\n    \n    if (style.font) {\n      converted.font = {\n        name: style.font.family || style.font.name,\n        size: style.font.size,\n        bold: style.font.bold,\n        italic: style.font.italic,\n        underline: style.font.underline,\n        color: this.convertColor(style.font.color)\n      };\n    }\n    \n    if (style.fill) {\n      // En ExcelJS, para patrón sólido, el color de fondo debe ir en fgColor\n      // backgroundColor es el color que queremos mostrar como fondo de la celda\n      const pattern = style.fill.pattern || 'solid';\n      \n      // Para patrón sólido: backgroundColor va en fgColor (es el color visible)\n      // Para otros patrones: foregroundColor es el color del patrón, backgroundColor es el fondo\n      const fgColor = pattern === 'solid' \n        ? (style.fill.backgroundColor || style.fill.foregroundColor)\n        : (style.fill.foregroundColor || style.fill.backgroundColor);\n      \n      // bgColor solo es relevante para patrones no sólidos\n      const bgColor = pattern !== 'solid' ? style.fill.backgroundColor : undefined;\n      \n      converted.fill = {\n        type: style.fill.type || 'pattern',\n        pattern: pattern,\n        fgColor: this.convertColor(fgColor),\n        bgColor: bgColor ? this.convertColor(bgColor) : undefined\n      };\n      \n      // Limpiar bgColor si es undefined para evitar problemas\n      if (!converted.fill.bgColor) {\n        delete converted.fill.bgColor;\n      }\n    }\n    \n    if (style.border) {\n      converted.border = {};\n      \n      if (style.border.top) {\n        converted.border.top = {\n          style: style.border.top.style,\n          color: this.convertColor(style.border.top.color)\n        };\n      }\n      \n      if (style.border.left) {\n        converted.border.left = {\n          style: style.border.left.style,\n          color: this.convertColor(style.border.left.color)\n        };\n      }\n      \n      if (style.border.bottom) {\n        converted.border.bottom = {\n          style: style.border.bottom.style,\n          color: this.convertColor(style.border.bottom.color)\n        };\n      }\n      \n      if (style.border.right) {\n        converted.border.right = {\n          style: style.border.right.style,\n          color: this.convertColor(style.border.right.color)\n        };\n      }\n    }\n    \n    if (style.alignment) {\n      converted.alignment = {};\n      \n      // Horizontal alignment - validar valores permitidos\n      if (style.alignment.horizontal !== undefined) {\n        const validHorizontal = ['left', 'center', 'right', 'fill', 'justify', 'centerContinuous', 'distributed'];\n        if (validHorizontal.includes(style.alignment.horizontal)) {\n          converted.alignment.horizontal = style.alignment.horizontal as any;\n        }\n      }\n      \n      // Vertical alignment - validar valores permitidos\n      if (style.alignment.vertical !== undefined) {\n        const validVertical = ['top', 'middle', 'bottom', 'distributed', 'justify'];\n        if (validVertical.includes(style.alignment.vertical)) {\n          converted.alignment.vertical = style.alignment.vertical as any;\n        }\n      }\n      \n      // Wrap text\n      if (style.alignment.wrapText !== undefined) {\n        converted.alignment.wrapText = Boolean(style.alignment.wrapText);\n      }\n      \n      // Shrink to fit\n      if (style.alignment.shrinkToFit !== undefined) {\n        converted.alignment.shrinkToFit = Boolean(style.alignment.shrinkToFit);\n      }\n      \n      // Indent\n      if (style.alignment.indent !== undefined && typeof style.alignment.indent === 'number') {\n        converted.alignment.indent = style.alignment.indent;\n      }\n      \n      // Text rotation (0-180 grados)\n      if (style.alignment.textRotation !== undefined && typeof style.alignment.textRotation === 'number') {\n        converted.alignment.textRotation = style.alignment.textRotation;\n      }\n      \n      // Reading order\n      if (style.alignment.readingOrder !== undefined) {\n        const validReadingOrder = ['left-to-right', 'right-to-left', 'context'];\n        if (validReadingOrder.includes(style.alignment.readingOrder)) {\n          converted.alignment.readingOrder = style.alignment.readingOrder as any;\n        }\n      }\n      \n      // Solo agregar alignment si tiene al menos una propiedad\n      if (Object.keys(converted.alignment).length === 0) {\n        delete converted.alignment;\n      }\n    }\n    \n    if (style.numFmt) {\n      converted.numFmt = style.numFmt;\n    }\n    \n    return converted;\n  }\n}","/**\r\n * Builder-specific type definitions\r\n */\r\n\r\nimport { IWorkbookMetadata, Result } from './core.types';\r\nimport { IWorksheet, IWorksheetConfig } from './worksheet.types';\r\nimport { IStyle } from './style.types';\r\n\r\n// Re-export ErrorType for convenience\r\nexport { ErrorType } from './core.types';\r\n\r\n/**\r\n * Excel builder configuration interface\r\n */\r\nexport interface IExcelBuilderConfig {\r\n  /** Workbook metadata */\r\n  metadata?: IWorkbookMetadata;\r\n  /** Default worksheet configuration */\r\n  defaultWorksheetConfig?: Partial<IWorksheetConfig>;\r\n  /** Default styles */\r\n  defaultStyles?: {\r\n    header?: IStyle;\r\n    subheader?: IStyle;\r\n    data?: IStyle;\r\n    footer?: IStyle;\r\n    total?: IStyle;\r\n  };\r\n  /** Whether to enable validation */\r\n  enableValidation?: boolean;\r\n  /** Whether to enable events */\r\n  enableEvents?: boolean;\r\n  /** Whether to enable performance monitoring */\r\n  enablePerformanceMonitoring?: boolean;\r\n  /** Maximum number of worksheets */\r\n  maxWorksheets?: number;\r\n  /** Maximum number of rows per worksheet */\r\n  maxRowsPerWorksheet?: number;\r\n  /** Maximum number of columns per worksheet */\r\n  maxColumnsPerWorksheet?: number;\r\n  /** Memory limit in bytes */\r\n  memoryLimit?: number;\r\n}\r\n\r\n/**\r\n * Build options interface\r\n */\r\nexport interface IBuildOptions {\r\n  /** Output format */\r\n  format?: 'xlsx' | 'xls' | 'csv';\r\n  /** Whether to include styles */\r\n  includeStyles?: boolean;\r\n  /** Whether to include formulas */\r\n  includeFormulas?: boolean;\r\n  /** Whether to include comments */\r\n  includeComments?: boolean;\r\n  /** Whether to include data validation */\r\n  includeValidation?: boolean;\r\n  /** Whether to include conditional formatting */\r\n  includeConditionalFormatting?: boolean;\r\n  /** Compression level (0-9) */\r\n  compressionLevel?: number;\r\n  /** Whether to optimize for size */\r\n  optimizeForSize?: boolean;\r\n  /** Whether to optimize for speed */\r\n  optimizeForSpeed?: boolean;\r\n}\r\n\r\n/**\r\n * Download options interface\r\n */\r\nexport interface IDownloadOptions extends IBuildOptions {\r\n  /** File name */\r\n  fileName?: string;\r\n  /** Whether to show download progress */\r\n  showProgress?: boolean;\r\n  /** Progress callback */\r\n  onProgress?: (progress: number) => void;\r\n  /** Whether to auto-download */\r\n  autoDownload?: boolean;\r\n  /** MIME type */\r\n  mimeType?: string;\r\n}\r\n\r\n/**\r\n * Excel builder interface\r\n */\r\nexport interface IExcelBuilder {\r\n  /** Builder configuration */\r\n  config: IExcelBuilderConfig;\r\n  /** Worksheets in the workbook */\r\n  worksheets: Map<string, IWorksheet>;\r\n  /** Current worksheet */\r\n  currentWorksheet: IWorksheet | undefined;\r\n  /** Whether the builder is building */\r\n  isBuilding: boolean;\r\n  /** Build statistics */\r\n  stats: IBuildStats;\r\n\r\n  /** Add a new worksheet */\r\n  addWorksheet(name: string, config?: Partial<IWorksheetConfig>): IWorksheet;\r\n  /** Get a worksheet by name */\r\n  getWorksheet(name: string): IWorksheet | undefined;\r\n  /** Remove a worksheet */\r\n  removeWorksheet(name: string): boolean;\r\n  /** Set the current worksheet */\r\n  setCurrentWorksheet(name: string): boolean;\r\n  /** Build the workbook */\r\n  build(options?: IBuildOptions): Promise<Result<ArrayBuffer>>;\r\n  /** Generate and download the file */\r\n  generateAndDownload(fileName: string, options?: IDownloadOptions): Promise<Result<void>>;\r\n  /** Get workbook as buffer */\r\n  toBuffer(options?: IBuildOptions): Promise<Result<ArrayBuffer>>;\r\n  /** Get workbook as blob */\r\n  toBlob(options?: IBuildOptions): Promise<Result<Blob>>;\r\n  /** Validate the workbook */\r\n  validate(): Result<boolean>;\r\n  /** Clear all worksheets */\r\n  clear(): void;\r\n  /** Get workbook statistics */\r\n  getStats(): IBuildStats;\r\n}\r\n\r\n/**\r\n * Build statistics interface\r\n */\r\nexport interface IBuildStats {\r\n  /** Total number of worksheets */\r\n  totalWorksheets: number;\r\n  /** Total number of cells */\r\n  totalCells: number;\r\n  /** Total memory usage in bytes */\r\n  memoryUsage: number;\r\n  /** Build time in milliseconds */\r\n  buildTime: number;\r\n  /** File size in bytes */\r\n  fileSize: number;\r\n  /** Number of styles used */\r\n  stylesUsed: number;\r\n  /** Number of formulas used */\r\n  formulasUsed: number;\r\n  /** Number of conditional formats used */\r\n  conditionalFormatsUsed: number;\r\n  /** Performance metrics */\r\n  performance: {\r\n    /** Time spent building headers */\r\n    headersTime: number;\r\n    /** Time spent building data */\r\n    dataTime: number;\r\n    /** Time spent applying styles */\r\n    stylesTime: number;\r\n    /** Time spent writing to buffer */\r\n    writeTime: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Builder event types\r\n */\r\nexport enum BuilderEventType {\r\n  WORKSHEET_ADDED = 'worksheetAdded',\r\n  WORKSHEET_REMOVED = 'worksheetRemoved',\r\n  WORKSHEET_UPDATED = 'worksheetUpdated',\r\n  BUILD_STARTED = 'buildStarted',\r\n  BUILD_PROGRESS = 'buildProgress',\r\n  BUILD_COMPLETED = 'buildCompleted',\r\n  BUILD_ERROR = 'buildError',\r\n  DOWNLOAD_STARTED = 'downloadStarted',\r\n  DOWNLOAD_PROGRESS = 'downloadProgress',\r\n  DOWNLOAD_COMPLETED = 'downloadCompleted',\r\n  DOWNLOAD_ERROR = 'downloadError'\r\n}\r\n\r\n/**\r\n * Builder event interface\r\n */\r\nexport interface IBuilderEvent {\r\n  type: BuilderEventType;\r\n  data?: Record<string, unknown>;\r\n  timestamp: Date;\r\n}\r\n\r\n/**\r\n * Builder event listener interface\r\n */\r\nexport interface IBuilderEventListener {\r\n  (event: IBuilderEvent): void;\r\n}\r\n\r\n/**\r\n * Builder validation result interface\r\n */\r\nexport interface IBuilderValidationResult {\r\n  /** Whether the builder is valid */\r\n  isValid: boolean;\r\n  /** Validation errors */\r\n  errors: string[];\r\n  /** Validation warnings */\r\n  warnings: string[];\r\n  /** Worksheet validation results */\r\n  worksheetResults: Map<string, boolean>;\r\n} ","/**\r\n * ExcelBuilder - Main class for creating Excel workbooks\r\n */\r\n\r\nimport ExcelJS from 'exceljs';\r\nimport saveAs from 'file-saver';\r\nimport { EventEmitter } from '../utils/EventEmitter';\r\nimport { Worksheet } from './Worksheet';\r\nimport {\r\n  IExcelBuilder,\r\n  IExcelBuilderConfig,\r\n  IBuildOptions,\r\n  IDownloadOptions,\r\n  IBuildStats,\r\n  BuilderEventType,\r\n  IBuilderEvent,\r\n  ErrorType\r\n} from '../types/builder.types';\r\nimport {\r\n  IWorksheet,\r\n  IWorksheetConfig\r\n} from '../types/worksheet.types';\r\nimport { \r\n  Result,\r\n  ISuccessResult,\r\n  IErrorResult\r\n} from '../types/core.types';\r\n\r\n/**\r\n * ExcelBuilder class for creating Excel workbooks\r\n */\r\nexport class ExcelBuilder implements IExcelBuilder {\r\n  public config: IExcelBuilderConfig;\r\n  public worksheets: Map<string, IWorksheet> = new Map();\r\n  public currentWorksheet: IWorksheet | undefined;\r\n  public isBuilding = false;\r\n  public stats: IBuildStats;\r\n\r\n  private eventEmitter: EventEmitter;\r\n\r\n  constructor(config: IExcelBuilderConfig = {}) {\r\n    this.config = {\r\n      enableValidation: true,\r\n      enableEvents: true,\r\n      enablePerformanceMonitoring: false,\r\n      maxWorksheets: 255,\r\n      maxRowsPerWorksheet: 1048576,\r\n      maxColumnsPerWorksheet: 16384,\r\n      memoryLimit: 100 * 1024 * 1024, // 100MB\r\n      ...config\r\n    };\r\n\r\n    this.stats = this.initializeStats();\r\n    this.eventEmitter = new EventEmitter();\r\n  }\r\n\r\n  /**\r\n   * Add a new worksheet to the workbook\r\n   */\r\n  addWorksheet(name: string, worksheetConfig: Partial<IWorksheetConfig> = {}): IWorksheet {\r\n    if (this.worksheets.has(name)) {\r\n      throw new Error(`Worksheet \"${name}\" already exists`);\r\n    }\r\n\r\n    const config: IWorksheetConfig = {\r\n      name,\r\n      defaultRowHeight: 20,\r\n      defaultColWidth: 10,\r\n      ...this.config.defaultWorksheetConfig,\r\n      ...worksheetConfig\r\n    };\r\n\r\n    const worksheet = new Worksheet(config);\r\n    this.worksheets.set(name, worksheet);\r\n    this.currentWorksheet = worksheet;\r\n    \r\n    this.emitEvent(BuilderEventType.WORKSHEET_ADDED, { worksheetName: name });\r\n    \r\n    return worksheet;\r\n  }\r\n\r\n  /**\r\n   * Get a worksheet by name\r\n   */\r\n  getWorksheet(name: string): IWorksheet | undefined {\r\n    return this.worksheets.get(name);\r\n  }\r\n\r\n  /**\r\n   * Remove a worksheet by name\r\n   */\r\n  removeWorksheet(name: string): boolean {\r\n    const worksheet = this.worksheets.get(name);\r\n    if (!worksheet) {\r\n      return false;\r\n    }\r\n\r\n    this.worksheets.delete(name);\r\n    \r\n    // If this was the current worksheet, clear it\r\n    if (this.currentWorksheet === worksheet) {\r\n      this.currentWorksheet = undefined;\r\n    }\r\n    \r\n    this.emitEvent(BuilderEventType.WORKSHEET_REMOVED, { worksheetName: name });\r\n    \r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Set the current worksheet\r\n   */\r\n  setCurrentWorksheet(name: string): boolean {\r\n    const worksheet = this.worksheets.get(name);\r\n    if (!worksheet) {\r\n      return false;\r\n    }\r\n    \r\n    this.currentWorksheet = worksheet;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Build the workbook and return as ArrayBuffer\r\n   */\r\n  async build(options: IBuildOptions = {}): Promise<Result<ArrayBuffer>> {\r\n    if (this.isBuilding) {\r\n      return {\r\n        success: false,\r\n        error: {\r\n          type: ErrorType.BUILD_ERROR,\r\n          message: 'Build already in progress',\r\n          stack: new Error().stack || ''\r\n        }\r\n      };\r\n    }\r\n\r\n    this.isBuilding = true;\r\n    const startTime = Date.now();\r\n    \r\n    try {\r\n      this.emitEvent(BuilderEventType.BUILD_STARTED);\r\n      \r\n      const workbook = new ExcelJS.Workbook();\r\n      \r\n      // Add metadata\r\n      if (this.config.metadata) {\r\n        workbook.creator = this.config.metadata.author || 'Han Excel Builder';\r\n        workbook.lastModifiedBy = this.config.metadata.author || 'Han Excel Builder';\r\n        workbook.created = this.config.metadata.created || new Date();\r\n        workbook.modified = this.config.metadata.modified || new Date();\r\n        if (this.config.metadata.title) workbook.title = this.config.metadata.title;\r\n        if (this.config.metadata.subject) workbook.subject = this.config.metadata.subject;\r\n        if (this.config.metadata.keywords) workbook.keywords = this.config.metadata.keywords;\r\n        if (this.config.metadata.category) workbook.category = this.config.metadata.category;\r\n        if (this.config.metadata.description) workbook.description = this.config.metadata.description;\r\n      }\r\n\r\n      // Build each worksheet\r\n      for (const worksheet of this.worksheets.values()) {\r\n        await (worksheet as Worksheet).build(workbook, options);\r\n      }\r\n\r\n      // Write to buffer\r\n      const buffer = await workbook.xlsx.writeBuffer({\r\n        compression: options.compressionLevel || 6\r\n      } as any);\r\n\r\n      const endTime = Date.now();\r\n      this.stats.buildTime = endTime - startTime;\r\n      this.stats.fileSize = buffer.byteLength;\r\n      \r\n      const successResult: ISuccessResult<ArrayBuffer> = {\r\n        success: true,\r\n        data: buffer\r\n      };\r\n\r\n      this.emitEvent(BuilderEventType.BUILD_COMPLETED, {\r\n        buildTime: this.stats.buildTime,\r\n        fileSize: this.stats.fileSize\r\n      });\r\n\r\n      return successResult;\r\n\r\n    } catch (error) {\r\n      const errorResult: IErrorResult = {\r\n        success: false,\r\n        error: {\r\n          type: ErrorType.BUILD_ERROR,\r\n          message: error instanceof Error ? error.message : 'Unknown build error',\r\n          stack: error instanceof Error ? error.stack || '' : ''\r\n        }\r\n      };\r\n\r\n      this.emitEvent(BuilderEventType.BUILD_ERROR, { error: errorResult.error });\r\n      return errorResult;\r\n\r\n    } finally {\r\n      this.isBuilding = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate and download the file\r\n   */\r\n  async generateAndDownload(fileName: string, options: IDownloadOptions = {}): Promise<Result<void>> {\r\n    const buildResult = await this.build(options);\r\n    \r\n    if (!buildResult.success) {\r\n      return buildResult;\r\n    }\r\n\r\n    try {\r\n      this.emitEvent(BuilderEventType.DOWNLOAD_STARTED, { fileName });\r\n      \r\n      const blob = new Blob([buildResult.data], { \r\n        type: options.mimeType || 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' \r\n      });\r\n      \r\n      saveAs(blob, fileName);\r\n      \r\n      this.emitEvent(BuilderEventType.DOWNLOAD_COMPLETED, { fileName });\r\n      \r\n      return { success: true, data: undefined };\r\n\r\n    } catch (error) {\r\n      const errorResult: IErrorResult = {\r\n        success: false,\r\n        error: {\r\n          type: ErrorType.BUILD_ERROR,\r\n          message: error instanceof Error ? error.message : 'Download failed',\r\n          stack: error instanceof Error ? error.stack || '' : ''\r\n        }\r\n      };\r\n\r\n      this.emitEvent(BuilderEventType.DOWNLOAD_ERROR, { error: errorResult.error });\r\n      return errorResult;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get workbook as buffer\r\n   */\r\n  async toBuffer(options: IBuildOptions = {}): Promise<Result<ArrayBuffer>> {\r\n    return this.build(options);\r\n  }\r\n\r\n  /**\r\n   * Get workbook as blob\r\n   */\r\n  async toBlob(options: IBuildOptions = {}): Promise<Result<Blob>> {\r\n    const buildResult = await this.build(options);\r\n    \r\n    if (!buildResult.success) {\r\n      return buildResult;\r\n    }\r\n\r\n    const blob = new Blob([buildResult.data], { \r\n      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' \r\n    });\r\n    \r\n    return { success: true, data: blob };\r\n  }\r\n\r\n  /**\r\n   * Validate the workbook\r\n   */\r\n  validate(): Result<boolean> {\r\n    const errors: string[] = [];\r\n    \r\n    if (this.worksheets.size === 0) {\r\n      errors.push('No worksheets found');\r\n    }\r\n\r\n    // Validate each worksheet\r\n    for (const [name, worksheet] of this.worksheets.entries()) {\r\n      const worksheetValidation = (worksheet as Worksheet).validate();\r\n      if (!worksheetValidation.success) {\r\n        errors.push(`Worksheet \"${name}\": ${worksheetValidation.error?.message}`);\r\n      }\r\n    }\r\n\r\n    if (errors.length > 0) {\r\n      return {\r\n        success: false,\r\n        error: {\r\n          type: ErrorType.VALIDATION_ERROR,\r\n          message: errors.join('; '),\r\n          stack: new Error().stack || ''\r\n        }\r\n      };\r\n    }\r\n\r\n    return { success: true, data: true };\r\n  }\r\n\r\n  /**\r\n   * Clear all worksheets\r\n   */\r\n  clear(): void {\r\n    this.worksheets.clear();\r\n    this.currentWorksheet = undefined;\r\n  }\r\n\r\n  /**\r\n   * Get workbook statistics\r\n   */\r\n  getStats(): IBuildStats {\r\n    return { ...this.stats };\r\n  }\r\n\r\n  /**\r\n   * Event handling methods\r\n   */\r\n  on(eventType: BuilderEventType, listener: (event: IBuilderEvent) => void): string {\r\n    return this.eventEmitter.on(eventType, listener);\r\n  }\r\n\r\n  off(eventType: BuilderEventType, listenerId: string): boolean {\r\n    return this.eventEmitter.off(eventType, listenerId);\r\n  }\r\n\r\n  removeAllListeners(eventType?: BuilderEventType): void {\r\n    if (eventType) {\r\n      this.eventEmitter.offAll(eventType);\r\n    } else {\r\n      this.eventEmitter.clear();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Private methods\r\n   */\r\n  private emitEvent(type: BuilderEventType, data?: Record<string, unknown>): void {\r\n    const event: IBuilderEvent = {\r\n      type,\r\n      data: data || {},\r\n      timestamp: new Date()\r\n    };\r\n    this.eventEmitter.emitSync(event);\r\n  }\r\n\r\n  private initializeStats(): IBuildStats {\r\n    return {\r\n      totalWorksheets: 0,\r\n      totalCells: 0,\r\n      memoryUsage: 0,\r\n      buildTime: 0,\r\n      fileSize: 0,\r\n      stylesUsed: 0,\r\n      formulasUsed: 0,\r\n      conditionalFormatsUsed: 0,\r\n      performance: {\r\n        headersTime: 0,\r\n        dataTime: 0,\r\n        stylesTime: 0,\r\n        writeTime: 0\r\n      }\r\n    };\r\n  }\r\n} ","/**\r\n * Types for Excel Reader functionality\r\n */\r\n\r\nimport { Result } from './core.types';\r\n\r\n/**\r\n * Output format types\r\n */\r\nexport enum OutputFormat {\r\n  /** Format by worksheet (structured with sheets, rows, cells) */\r\n  WORKSHEET = 'worksheet',\r\n  /** Detailed format with text, column, row information */\r\n  DETAILED = 'detailed',\r\n  /** Flat format - just the data without structure */\r\n  FLAT = 'flat'\r\n}\r\n\r\n/**\r\n * Mapper function types for different output formats\r\n */\r\nexport type WorksheetMapper = (data: IJsonWorkbook) => unknown;\r\nexport type DetailedMapper = (data: IDetailedFormat) => unknown;\r\nexport type FlatMapper = (data: IFlatFormat | IFlatFormatMultiSheet) => unknown;\r\n\r\n/**\r\n * Options for reading Excel files\r\n */\r\nexport interface IExcelReaderOptions {\r\n  /** Output format (default: 'worksheet') */\r\n  outputFormat?: OutputFormat | 'worksheet' | 'detailed' | 'flat';\r\n  /** Mapper function to transform the response data */\r\n  mapper?: WorksheetMapper | DetailedMapper | FlatMapper;\r\n  /** Whether to include empty rows */\r\n  includeEmptyRows?: boolean;\r\n  /** Whether to use first row as headers */\r\n  useFirstRowAsHeaders?: boolean;\r\n  /** Custom headers mapping (column index -> header name) */\r\n  headers?: string[] | Record<number, string>;\r\n  /** Sheet name or index to read (if not specified, reads all sheets) */\r\n  sheetName?: string | number;\r\n  /** Starting row (1-based, default: 1) */\r\n  startRow?: number;\r\n  /** Ending row (1-based, if not specified, reads until end) */\r\n  endRow?: number;\r\n  /** Starting column (1-based, default: 1) */\r\n  startColumn?: number;\r\n  /** Ending column (1-based, if not specified, reads until end) */\r\n  endColumn?: number;\r\n  /** Whether to include cell formatting information */\r\n  includeFormatting?: boolean;\r\n  /** Whether to include formulas */\r\n  includeFormulas?: boolean;\r\n  /** Date format for date cells */\r\n  dateFormat?: string;\r\n  /** Whether to convert dates to ISO strings */\r\n  datesAsISO?: boolean;\r\n}\r\n\r\n/**\r\n * Cell data in JSON format\r\n */\r\nexport interface IJsonCell {\r\n  /** Cell value */\r\n  value: unknown;\r\n  /** Cell type */\r\n  type?: string;\r\n  /** Cell reference (e.g., A1) */\r\n  reference?: string;\r\n  /** Formatted value (if includeFormatting is true) */\r\n  formattedValue?: string;\r\n  /** Formula (if includeFormulas is true) */\r\n  formula?: string;\r\n}\r\n\r\n/**\r\n * Row data in JSON format\r\n */\r\nexport interface IJsonRow {\r\n  /** Row number (1-based) */\r\n  rowNumber: number;\r\n  /** Cells in the row */\r\n  cells: IJsonCell[];\r\n  /** Row as object (if useFirstRowAsHeaders is true) */\r\n  data?: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * Sheet data in JSON format\r\n */\r\nexport interface IJsonSheet {\r\n  /** Sheet name */\r\n  name: string;\r\n  /** Sheet index */\r\n  index: number;\r\n  /** Rows in the sheet */\r\n  rows: IJsonRow[];\r\n  /** Headers (if useFirstRowAsHeaders is true) */\r\n  headers?: string[];\r\n  /** Total number of rows */\r\n  totalRows: number;\r\n  /** Total number of columns */\r\n  totalColumns: number;\r\n}\r\n\r\n/**\r\n * Workbook data in JSON format\r\n */\r\nexport interface IJsonWorkbook {\r\n  /** Workbook metadata */\r\n  metadata?: {\r\n    title?: string;\r\n    author?: string;\r\n    company?: string;\r\n    created?: Date | string;\r\n    modified?: Date | string;\r\n    description?: string;\r\n  };\r\n  /** Sheets in the workbook */\r\n  sheets: IJsonSheet[];\r\n  /** Total number of sheets */\r\n  totalSheets: number;\r\n}\r\n\r\n/**\r\n * Detailed cell format - includes position information\r\n */\r\nexport interface IDetailedCell {\r\n  /** Cell value */\r\n  value: unknown;\r\n  /** Cell text (string representation) */\r\n  text: string;\r\n  /** Column number (1-based) */\r\n  column: number;\r\n  /** Column letter (e.g., A, B, C) */\r\n  columnLetter: string;\r\n  /** Row number (1-based) */\r\n  row: number;\r\n  /** Cell reference (e.g., A1) */\r\n  reference: string;\r\n  /** Sheet name */\r\n  sheet: string;\r\n  /** Cell type */\r\n  type?: string;\r\n  /** Formatted value (if includeFormatting is true) */\r\n  formattedValue?: string;\r\n  /** Formula (if includeFormulas is true) */\r\n  formula?: string;\r\n}\r\n\r\n/**\r\n * Detailed format result - array of cells with position\r\n */\r\nexport interface IDetailedFormat {\r\n  /** Array of all cells with detailed information */\r\n  cells: IDetailedCell[];\r\n  /** Total number of cells */\r\n  totalCells: number;\r\n  /** Workbook metadata */\r\n  metadata?: {\r\n    title?: string;\r\n    author?: string;\r\n    company?: string;\r\n    created?: Date | string;\r\n    modified?: Date | string;\r\n    description?: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Flat format result - just the data values\r\n */\r\nexport interface IFlatFormat {\r\n  /** Array of row data (as objects if useFirstRowAsHeaders is true, or as arrays) */\r\n  data: Array<Record<string, unknown> | unknown[]>;\r\n  /** Headers (if useFirstRowAsHeaders is true) */\r\n  headers?: string[];\r\n  /** Sheet name */\r\n  sheet?: string;\r\n  /** Total number of rows */\r\n  totalRows: number;\r\n}\r\n\r\n/**\r\n * Flat format result for multiple sheets\r\n */\r\nexport interface IFlatFormatMultiSheet {\r\n  /** Data organized by sheet name */\r\n  sheets: Record<string, IFlatFormat>;\r\n  /** Total number of sheets */\r\n  totalSheets: number;\r\n  /** Workbook metadata */\r\n  metadata?: {\r\n    title?: string;\r\n    author?: string;\r\n    company?: string;\r\n    created?: Date | string;\r\n    modified?: Date | string;\r\n    description?: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Reader result - generic type based on output format\r\n */\r\nexport type ExcelReaderResult<T extends OutputFormat = OutputFormat.WORKSHEET> = \r\n  T extends OutputFormat.DETAILED\r\n    ? Result<IDetailedFormat> & { processingTime?: number }\r\n    : T extends OutputFormat.FLAT\r\n    ? Result<IFlatFormat | IFlatFormatMultiSheet> & { processingTime?: number }\r\n    : Result<IJsonWorkbook> & { processingTime?: number };\r\n\r\n/**\r\n * Legacy reader result (for backward compatibility)\r\n */\r\nexport type IExcelReaderResult = Result<IJsonWorkbook> & {\r\n  /** Processing time in milliseconds */\r\n  processingTime?: number;\r\n}\r\n\r\n","/**\r\n * StyleBuilder - Fluent API for creating Excel styles\r\n */\r\n\r\nimport {\r\n  IStyle,\r\n  IBorder,\r\n  IConditionalFormat,\r\n  IStyleBuilder as IStyleBuilderInterface\r\n} from '../types/style.types';\r\nimport { \r\n  Color, \r\n  HorizontalAlignment,\r\n  VerticalAlignment,\r\n  BorderStyle, \r\n  FontStyle \r\n} from '../types/core.types';\r\n\r\n/**\r\n * StyleBuilder class providing a fluent API for creating Excel styles\r\n */\r\nexport class StyleBuilder implements IStyleBuilderInterface {\r\n  private style: Partial<IStyle> = {};\r\n\r\n  constructor() {\r\n    // Configuración por defecto: wrapText true y alineación al centro\r\n    this.style.alignment = {\r\n      horizontal: HorizontalAlignment.CENTER,\r\n      vertical: VerticalAlignment.MIDDLE,\r\n      wrapText: true,\r\n      shrinkToFit: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create a new StyleBuilder instance\r\n   */\r\n  static create(): StyleBuilder {\r\n    return new StyleBuilder();\r\n  }\r\n\r\n  /**\r\n   * Set font name\r\n   */\r\n  fontName(name: string): StyleBuilder {\r\n    if (!this.style.font) {\r\n      this.style.font = {};\r\n    }\r\n    this.style.font.name = name;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set font size\r\n   */\r\n  fontSize(size: number): StyleBuilder {\r\n    if (!this.style.font) {\r\n      this.style.font = {};\r\n    }\r\n    this.style.font.size = size;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set font style\r\n   */\r\n  fontStyle(style: FontStyle): StyleBuilder {\r\n    if (!this.style.font) {\r\n      this.style.font = {};\r\n    }\r\n    this.style.font.style = style;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set font color\r\n   */\r\n  fontColor(color: Color): StyleBuilder {\r\n    if (!this.style.font) {\r\n      this.style.font = {};\r\n    }\r\n    this.style.font.color = color;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Make font bold\r\n   */\r\n  fontBold(): StyleBuilder {\r\n    if (!this.style.font) {\r\n      this.style.font = {};\r\n    }\r\n    this.style.font.bold = true;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Make font italic\r\n   */\r\n  fontItalic(): StyleBuilder {\r\n    if (!this.style.font) {\r\n      this.style.font = {};\r\n    }\r\n    this.style.font.italic = true;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Make font underlined\r\n   */\r\n  fontUnderline(): StyleBuilder {\r\n    if (!this.style.font) {\r\n      this.style.font = {};\r\n    }\r\n    this.style.font.underline = true;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set border on all sides\r\n   */\r\n  border(style: BorderStyle, color?: Color): StyleBuilder {\r\n    if (!this.style.border) {\r\n      this.style.border = {};\r\n    }\r\n    const border: IBorder = { style };\r\n    if (color !== undefined) {\r\n      border.color = color;\r\n    }\r\n    this.style.border.top = border;\r\n    this.style.border.left = border;\r\n    this.style.border.bottom = border;\r\n    this.style.border.right = border;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set top border\r\n   */\r\n  borderTop(style: BorderStyle, color?: Color): StyleBuilder {\r\n    if (!this.style.border) {\r\n      this.style.border = {};\r\n    }\r\n    const border: IBorder = { style };\r\n    if (color !== undefined) {\r\n      border.color = color;\r\n    }\r\n    this.style.border.top = border;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set left border\r\n   */\r\n  borderLeft(style: BorderStyle, color?: Color): StyleBuilder {\r\n    if (!this.style.border) {\r\n      this.style.border = {};\r\n    }\r\n    const border: IBorder = { style };\r\n    if (color !== undefined) {\r\n      border.color = color;\r\n    }\r\n    this.style.border.left = border;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set bottom border\r\n   */\r\n  borderBottom(style: BorderStyle, color?: Color): StyleBuilder {\r\n    if (!this.style.border) {\r\n      this.style.border = {};\r\n    }\r\n    const border: IBorder = { style };\r\n    if (color !== undefined) {\r\n      border.color = color;\r\n    }\r\n    this.style.border.bottom = border;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set right border\r\n   */\r\n  borderRight(style: BorderStyle, color?: Color): StyleBuilder {\r\n    if (!this.style.border) {\r\n      this.style.border = {};\r\n    }\r\n    const border: IBorder = { style };\r\n    if (color !== undefined) {\r\n      border.color = color;\r\n    }\r\n    this.style.border.right = border;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set background color\r\n   */\r\n  backgroundColor(color: Color): StyleBuilder {\r\n    if (!this.style.fill) {\r\n      this.style.fill = { type: 'pattern' };\r\n    }\r\n    this.style.fill.backgroundColor = color;\r\n    this.style.fill.pattern = 'solid';\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set horizontal alignment\r\n   */\r\n  horizontalAlign(alignment: HorizontalAlignment): StyleBuilder {\r\n    if (!this.style.alignment) {\r\n      this.style.alignment = {};\r\n    }\r\n    this.style.alignment.horizontal = alignment;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set vertical alignment\r\n   */\r\n  verticalAlign(alignment: VerticalAlignment): StyleBuilder {\r\n    if (!this.style.alignment) {\r\n      this.style.alignment = {};\r\n    }\r\n    this.style.alignment.vertical = alignment;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Center align text\r\n   */\r\n  centerAlign(): StyleBuilder {\r\n    if (!this.style.alignment) {\r\n      this.style.alignment = {};\r\n    }\r\n    this.style.alignment.horizontal = HorizontalAlignment.CENTER;\r\n    this.style.alignment.vertical = VerticalAlignment.MIDDLE;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Left align text\r\n   */\r\n  leftAlign(): StyleBuilder {\r\n    if (!this.style.alignment) {\r\n      this.style.alignment = {};\r\n    }\r\n    this.style.alignment.horizontal = HorizontalAlignment.LEFT;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Right align text\r\n   */\r\n  rightAlign(): StyleBuilder {\r\n    if (!this.style.alignment) {\r\n      this.style.alignment = {};\r\n    }\r\n    this.style.alignment.horizontal = HorizontalAlignment.RIGHT;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Wrap text\r\n   */\r\n  wrapText(): StyleBuilder {\r\n    if (!this.style.alignment) {\r\n      this.style.alignment = {};\r\n    }\r\n    this.style.alignment.wrapText = true;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set number format\r\n   */\r\n  numberFormat(format: string): StyleBuilder {\r\n    this.style.numberFormat = format;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set striped rows\r\n   */\r\n  striped(): StyleBuilder {\r\n    this.style.striped = true;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add conditional formatting\r\n   */\r\n  conditionalFormat(format: IConditionalFormat): StyleBuilder {\r\n    if (!this.style.conditionalFormats) {\r\n      this.style.conditionalFormats = [];\r\n    }\r\n    this.style.conditionalFormats.push(format);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Build the final style\r\n   */\r\n  build(): IStyle {\r\n    return this.style as IStyle;\r\n  }\r\n\r\n  /**\r\n   * Reset the builder\r\n   */\r\n  reset(): StyleBuilder {\r\n    this.style = {};\r\n    // Restaurar configuración por defecto\r\n    this.style.alignment = {\r\n      horizontal: HorizontalAlignment.CENTER,\r\n      vertical: VerticalAlignment.MIDDLE,\r\n      wrapText: true\r\n    };\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Clone the current style\r\n   */\r\n  clone(): StyleBuilder {\r\n    const cloned = new StyleBuilder();\r\n    cloned.style = JSON.parse(JSON.stringify(this.style));\r\n    return cloned;\r\n  }\r\n} ","/**\r\n * Cell-specific type definitions\r\n */\r\n\r\nimport { IBaseCell } from './core.types';\r\nimport type { CellValue } from 'exceljs';\r\n\r\n/**\r\n * Header cell interface\r\n */\r\nexport interface IHeaderCell extends IBaseCell {\r\n  /** Reference to parent header key */\r\n  mainHeaderKey?: string;\r\n  /** Child headers */\r\n  children?: IHeaderCell[];\r\n  /** Whether this is a main header */\r\n  isMainHeader?: boolean;\r\n  /** Header level (1 = main, 2 = sub, etc.) */\r\n  level?: number;\r\n}\r\n\r\n/**\r\n * Data cell interface\r\n */\r\nexport interface IDataCell extends IBaseCell {\r\n  /** Reference to header key */\r\n  header: string;\r\n  /** Reference to main header key */\r\n  mainHeaderKey?: string;\r\n  /** Child data cells */\r\n  children?: IDataCell[];\r\n  /** Whether this cell has alternating row color */\r\n  striped?: boolean;\r\n  /** Row index */\r\n  rowIndex?: number;\r\n  /** Column index */\r\n  colIndex?: number;\r\n}\r\n\r\n/**\r\n * Footer cell interface\r\n */\r\nexport interface IFooterCell extends IBaseCell {\r\n  /** Reference to header key */\r\n  header: string;\r\n  /** Child footer cells */\r\n  children?: IDataCell[];\r\n  /** Whether this is a total row */\r\n  isTotal?: boolean;\r\n  /** Footer type */\r\n  footerType?: 'total' | 'subtotal' | 'average' | 'count' | 'custom';\r\n}\r\n\r\n/**\r\n * Cell position interface\r\n */\r\nexport interface ICellPosition {\r\n  /** Row index (1-based) */\r\n  row: number;\r\n  /** Column index (1-based) */\r\n  col: number;\r\n  /** Cell reference (e.g., A1) */\r\n  reference: string;\r\n}\r\n\r\n/**\r\n * Cell range interface\r\n */\r\nexport interface ICellRange {\r\n  /** Start position */\r\n  start: ICellPosition;\r\n  /** End position */\r\n  end: ICellPosition;\r\n  /** Range reference (e.g., A1:B10) */\r\n  reference: string;\r\n}\r\n\r\n/**\r\n * Cell data for different types\r\n */\r\nexport interface ICellData {\r\n  /** String cell data */\r\n  string?: {\r\n    value: string;\r\n    maxLength?: number;\r\n    trim?: boolean;\r\n  };\r\n  /** Number cell data */\r\n  number?: {\r\n    value: number;\r\n    min?: number;\r\n    max?: number;\r\n    precision?: number;\r\n    allowNegative?: boolean;\r\n  };\r\n  /** Date cell data */\r\n  date?: {\r\n    value: Date;\r\n    min?: Date;\r\n    max?: Date;\r\n    format?: string;\r\n  };\r\n  /** Boolean cell data */\r\n  boolean?: {\r\n    value: boolean;\r\n    trueText?: string;\r\n    falseText?: string;\r\n  };\r\n  /** Percentage cell data */\r\n  percentage?: {\r\n    value: number;\r\n    min?: number;\r\n    max?: number;\r\n    precision?: number;\r\n    showSymbol?: boolean;\r\n  };\r\n  /** Currency cell data */\r\n  currency?: {\r\n    value: number;\r\n    currency?: string;\r\n    precision?: number;\r\n    showSymbol?: boolean;\r\n  };\r\n  /** Link cell data */\r\n  link?: {\r\n    value: string;\r\n    text?: string;\r\n    tooltip?: string;\r\n  };\r\n  /** Formula cell data */\r\n  formula?: {\r\n    value: string;\r\n    result?: CellValue;\r\n  };\r\n}\r\n\r\n/**\r\n * Cell validation result\r\n */\r\nexport interface ICellValidationResult {\r\n  /** Whether the cell is valid */\r\n  isValid: boolean;\r\n  /** Validation errors */\r\n  errors: string[];\r\n  /** Validation warnings */\r\n  warnings: string[];\r\n}\r\n\r\n/**\r\n * Cell event types\r\n */\r\nexport enum CellEventType {\r\n  CREATED = 'created',\r\n  UPDATED = 'updated',\r\n  DELETED = 'deleted',\r\n  STYLED = 'styled',\r\n  VALIDATED = 'validated'\r\n}\r\n\r\n/**\r\n * Cell event interface\r\n */\r\nexport interface ICellEvent {\r\n  type: CellEventType;\r\n  cell: IDataCell | IHeaderCell | IFooterCell;\r\n  position: ICellPosition;\r\n  timestamp: Date;\r\n  data?: Record<string, unknown>;\r\n} ","/**\n * Worksheet-specific type definitions\n */\n\nimport { IHeaderCell, IDataCell, IFooterCell, ICellPosition, ICellRange } from './cell.types';\nimport { Color, Result } from './core.types';\n\n/**\n * Worksheet configuration interface\n */\nexport interface IWorksheetConfig {\n  /** Worksheet name */\n  name: string;\n  /** Tab color */\n  tabColor?: Color;\n  /** Default row height */\n  defaultRowHeight?: number;\n  /** Default column width */\n  defaultColWidth?: number;\n  /** Whether the worksheet is hidden */\n  hidden?: boolean;\n  /** Whether the worksheet is protected */\n  protected?: boolean;\n  /** Protection password */\n  protectionPassword?: string;\n  /** Whether to show grid lines */\n  showGridLines?: boolean;\n  /** Whether to show row and column headers */\n  showRowColHeaders?: boolean;\n  /** Zoom level (1-400) */\n  zoom?: number;\n  /** Freeze panes position */\n  freezePanes?: ICellPosition;\n  /** Print area */\n  printArea?: ICellRange;\n  /** Fit to page settings */\n  fitToPage?: {\n    fitToWidth?: number;\n    fitToHeight?: number;\n  };\n  /** Page setup */\n  pageSetup?: {\n    orientation?: 'portrait' | 'landscape';\n    paperSize?: number;\n    fitToPage?: boolean;\n    fitToWidth?: number;\n    fitToHeight?: number;\n    scale?: number;\n    horizontalCentered?: boolean;\n    verticalCentered?: boolean;\n    margins?: {\n      top?: number;\n      left?: number;\n      bottom?: number;\n      right?: number;\n      header?: number;\n      footer?: number;\n    };\n  };\n}\n\n/**\n * Table structure interface\n */\nexport interface ITable {\n  /** Table name */\n  name?: string;\n  /** Table headers */\n  headers?: IHeaderCell[];\n  /** Table sub-headers */\n  subHeaders?: IHeaderCell[];\n  /** Table data rows */\n  body?: IDataCell[];\n  /** Table footers */\n  footers?: IFooterCell[];\n  /** Table range */\n  range?: ICellRange;\n  /** Whether to show table borders */\n  showBorders?: boolean;\n  /** Whether to show alternating row colors */\n  showStripes?: boolean;\n  /** Table style */\n  style?: 'TableStyleLight1' | 'TableStyleLight2' | 'TableStyleMedium1' | 'TableStyleMedium2' | 'TableStyleDark1' | 'TableStyleDark2';\n}\n\n/**\n * Worksheet interface\n */\nexport interface IWorksheet {\n  /** Worksheet configuration */\n  config: IWorksheetConfig;\n  /** Tables in the worksheet */\n  tables: ITable[];\n  /** Current row pointer */\n  currentRow: number;\n  /** Current column pointer */\n  currentCol: number;\n  /** Header pointers for navigation */\n  headerPointers: Map<string, ICellPosition>;\n  /** Whether the worksheet has been built */\n  isBuilt: boolean;\n\n  /** Add a header */\n  addHeader(header: IHeaderCell): this;\n  /** Add subheaders */\n  addSubHeaders(subHeaders: IHeaderCell[]): this;\n  /** Add a row or rows */\n  addRow(row: IDataCell[] | IDataCell): this;\n  /** Add a footer or footers */\n  addFooter(footer: IFooterCell[] | IFooterCell): this;\n  /** Add a new table to the worksheet */\n  addTable(tableConfig?: Partial<ITable>): this;\n  /** Finalize the current table with temporary data */\n  finalizeTable(): this;\n  /** Get a table by name */\n  getTable(name: string): ITable | undefined;\n  /** Build the worksheet */\n  build(workbook: any, options?: any): Promise<void>;\n  /** Validate the worksheet */\n  validate(): Result<boolean>;\n}\n\n/**\n * Worksheet event types\n */\nexport enum WorksheetEventType {\n  CREATED = 'created',\n  UPDATED = 'updated',\n  DELETED = 'deleted',\n  TABLE_ADDED = 'tableAdded',\n  TABLE_REMOVED = 'tableRemoved',\n  CELL_ADDED = 'cellAdded',\n  CELL_UPDATED = 'cellUpdated',\n  CELL_DELETED = 'cellDeleted'\n}\n\n/**\n * Worksheet event interface\n */\nexport interface IWorksheetEvent {\n  type: WorksheetEventType;\n  worksheet: IWorksheet;\n  data?: Record<string, unknown>;\n  timestamp: Date;\n}\n\n/**\n * Worksheet validation result\n */\nexport interface IWorksheetValidationResult {\n  /** Whether the worksheet is valid */\n  isValid: boolean;\n  /** Validation errors */\n  errors: string[];\n  /** Validation warnings */\n  warnings: string[];\n  /** Cell validation results */\n  cellResults: Map<string, boolean>;\n}\n\n/**\n * Worksheet statistics\n */\nexport interface IWorksheetStats {\n  /** Total number of cells */\n  totalCells: number;\n  /** Number of header cells */\n  headerCells: number;\n  /** Number of data cells */\n  dataCells: number;\n  /** Number of footer cells */\n  footerCells: number;\n  /** Number of tables */\n  tables: number;\n  /** Used range */\n  usedRange: ICellRange;\n  /** Memory usage in bytes */\n  memoryUsage: number;\n} ","/**\r\n * Style-specific type definitions\r\n */\r\n\r\nimport { \r\n  Color, \r\n  HorizontalAlignment, \r\n  VerticalAlignment, \r\n  BorderStyle, \r\n  FontStyle \r\n} from './core.types';\r\n\r\n/**\r\n * Font configuration interface\r\n */\r\nexport interface IFont {\r\n  /** Font name */\r\n  name?: string;\r\n  /** Font size */\r\n  size?: number;\r\n  /** Font style */\r\n  style?: FontStyle;\r\n  /** Font color */\r\n  color?: Color;\r\n  /** Whether the font is bold */\r\n  bold?: boolean;\r\n  /** Whether the font is italic */\r\n  italic?: boolean;\r\n  /** Whether the font is underlined */\r\n  underline?: boolean;\r\n  /** Whether the font is strikethrough */\r\n  strikethrough?: boolean;\r\n  /** Font family */\r\n  family?: string;\r\n  /** Font scheme */\r\n  scheme?: 'major' | 'minor' | 'none';\r\n}\r\n\r\n/**\r\n * Border configuration interface\r\n */\r\nexport interface IBorder {\r\n  /** Border style */\r\n  style?: BorderStyle;\r\n  /** Border color */\r\n  color?: Color;\r\n  /** Border width */\r\n  width?: number;\r\n}\r\n\r\n/**\r\n * Border sides interface\r\n */\r\nexport interface IBorderSides {\r\n  /** Top border */\r\n  top?: IBorder;\r\n  /** Left border */\r\n  left?: IBorder;\r\n  /** Bottom border */\r\n  bottom?: IBorder;\r\n  /** Right border */\r\n  right?: IBorder;\r\n  /** Diagonal border */\r\n  diagonal?: IBorder;\r\n  /** Diagonal direction */\r\n  diagonalDirection?: 'up' | 'down' | 'both';\r\n}\r\n\r\n/**\r\n * Fill pattern interface\r\n */\r\nexport interface IFill {\r\n  /** Fill type */\r\n  type: 'pattern' | 'gradient';\r\n  /** Pattern type (for pattern fills) */\r\n  pattern?: 'none' | 'solid' | 'darkGray' | 'mediumGray' | 'lightGray' | 'gray125' | 'gray0625' | 'darkHorizontal' | 'darkVertical' | 'darkDown' | 'darkUp' | 'darkGrid' | 'darkTrellis' | 'lightHorizontal' | 'lightVertical' | 'lightDown' | 'lightUp' | 'lightGrid' | 'lightTrellis';\r\n  /** Background color */\r\n  backgroundColor?: Color;\r\n  /** Foreground color */\r\n  foregroundColor?: Color;\r\n  /** Gradient type (for gradient fills) */\r\n  gradient?: 'linear' | 'path';\r\n  /** Gradient stops */\r\n  stops?: Array<{\r\n    position: number;\r\n    color: Color;\r\n  }>;\r\n  /** Gradient angle (for linear gradients) */\r\n  angle?: number;\r\n}\r\n\r\n/**\r\n * Alignment configuration interface\r\n */\r\nexport interface IAlignment {\r\n  /** Horizontal alignment */\r\n  horizontal?: HorizontalAlignment;\r\n  /** Vertical alignment */\r\n  vertical?: VerticalAlignment;\r\n  /** Text rotation (0-180 degrees) */\r\n  textRotation?: number;\r\n  /** Whether to wrap text */\r\n  wrapText?: boolean;\r\n  /** Whether to shrink text to fit */\r\n  shrinkToFit?: boolean;\r\n  /** Indent level */\r\n  indent?: number;\r\n  /** Whether to merge cells */\r\n  mergeCell?: boolean;\r\n  /** Reading order */\r\n  readingOrder?: 'left-to-right' | 'right-to-left';\r\n}\r\n\r\n/**\r\n * Protection configuration interface\r\n */\r\nexport interface IProtection {\r\n  /** Whether the cell is locked */\r\n  locked?: boolean;\r\n  /** Whether the cell is hidden */\r\n  hidden?: boolean;\r\n}\r\n\r\n/**\r\n * Conditional formatting interface\r\n */\r\nexport interface IConditionalFormat {\r\n  /** Condition type */\r\n  type: 'cellIs' | 'containsText' | 'beginsWith' | 'endsWith' | 'containsBlanks' | 'notContainsBlanks' | 'containsErrors' | 'notContainsErrors' | 'timePeriod' | 'top' | 'bottom' | 'aboveAverage' | 'belowAverage' | 'duplicateValues' | 'uniqueValues' | 'expression' | 'colorScale' | 'dataBar' | 'iconSet';\r\n  /** Condition operator */\r\n  operator?: 'between' | 'notBetween' | 'equal' | 'notEqual' | 'greaterThan' | 'lessThan' | 'greaterThanOrEqual' | 'lessThanOrEqual';\r\n  /** Condition values */\r\n  values?: Array<string | number | Date>;\r\n  /** Condition formula */\r\n  formula?: string;\r\n  /** Style to apply when condition is met */\r\n  style?: IStyle;\r\n  /** Priority of the condition */\r\n  priority?: number;\r\n  /** Whether to stop if true */\r\n  stopIfTrue?: boolean;\r\n}\r\n\r\n/**\r\n * Main style interface\r\n */\r\nexport interface IStyle {\r\n  /** Font configuration */\r\n  font?: IFont;\r\n  /** Border configuration */\r\n  border?: IBorderSides;\r\n  /** Fill configuration */\r\n  fill?: IFill;\r\n  /** Alignment configuration */\r\n  alignment?: IAlignment;\r\n  /** Protection configuration */\r\n  protection?: IProtection;\r\n  /** Conditional formatting */\r\n  conditionalFormats?: IConditionalFormat[];\r\n  /** Number format */\r\n  numberFormat?: string;\r\n  /** Whether to apply alternating row colors */\r\n  striped?: boolean;\r\n  /** Custom CSS-like properties */\r\n  custom?: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * Style preset types\r\n */\r\nexport enum StylePreset {\r\n  HEADER = 'header',\r\n  SUBHEADER = 'subheader',\r\n  DATA = 'data',\r\n  FOOTER = 'footer',\r\n  TOTAL = 'total',\r\n  HIGHLIGHT = 'highlight',\r\n  WARNING = 'warning',\r\n  ERROR = 'error',\r\n  SUCCESS = 'success',\r\n  INFO = 'info'\r\n}\r\n\r\n/**\r\n * Style theme interface\r\n */\r\nexport interface IStyleTheme {\r\n  /** Theme name */\r\n  name: string;\r\n  /** Theme description */\r\n  description?: string;\r\n  /** Color palette */\r\n  colors: {\r\n    primary: Color;\r\n    secondary: Color;\r\n    accent: Color;\r\n    background: Color;\r\n    text: Color;\r\n    border: Color;\r\n    success: Color;\r\n    warning: Color;\r\n    error: Color;\r\n    info: Color;\r\n  };\r\n  /** Font family */\r\n  fontFamily: string;\r\n  /** Base font size */\r\n  fontSize: number;\r\n  /** Style presets */\r\n  presets: Record<StylePreset, IStyle>;\r\n}\r\n\r\n/**\r\n * Style builder interface\r\n */\r\nexport interface IStyleBuilder {\r\n  /** Set font name */\r\n  fontName(name: string): IStyleBuilder;\r\n  /** Set font size */\r\n  fontSize(size: number): IStyleBuilder;\r\n  /** Set font style */\r\n  fontStyle(style: FontStyle): IStyleBuilder;\r\n  /** Set font color */\r\n  fontColor(color: Color): IStyleBuilder;\r\n  /** Make font bold */\r\n  fontBold(): IStyleBuilder;\r\n  /** Make font italic */\r\n  fontItalic(): IStyleBuilder;\r\n  /** Make font underlined */\r\n  fontUnderline(): IStyleBuilder;\r\n  /** Set border */\r\n  border(style: BorderStyle, color?: Color): IStyleBuilder;\r\n  /** Set specific border */\r\n  borderTop(style: BorderStyle, color?: Color): IStyleBuilder;\r\n  borderLeft(style: BorderStyle, color?: Color): IStyleBuilder;\r\n  borderBottom(style: BorderStyle, color?: Color): IStyleBuilder;\r\n  borderRight(style: BorderStyle, color?: Color): IStyleBuilder;\r\n  /** Set background color */\r\n  backgroundColor(color: Color): IStyleBuilder;\r\n  /** Set horizontal alignment */\r\n  horizontalAlign(alignment: HorizontalAlignment): IStyleBuilder;\r\n  /** Set vertical alignment */\r\n  verticalAlign(alignment: VerticalAlignment): IStyleBuilder;\r\n  /** Center align text */\r\n  centerAlign(): IStyleBuilder;\r\n  /** Left align text */\r\n  leftAlign(): IStyleBuilder;\r\n  /** Right align text */\r\n  rightAlign(): IStyleBuilder;\r\n  /** Wrap text */\r\n  wrapText(): IStyleBuilder;\r\n  /** Set number format */\r\n  numberFormat(format: string): IStyleBuilder;\r\n  /** Set striped rows */\r\n  striped(): IStyleBuilder;\r\n  /** Add conditional formatting */\r\n  conditionalFormat(format: IConditionalFormat): IStyleBuilder;\r\n  /** Build the final style */\r\n  build(): IStyle;\r\n} ","/**\r\n * ExcelReader - Class for reading Excel files and converting them to JSON\r\n */\r\n\r\nimport ExcelJS from 'exceljs';\r\nimport {\r\n  IExcelReaderOptions,\r\n  IJsonWorkbook,\r\n  IJsonSheet,\r\n  IJsonRow,\r\n  IJsonCell,\r\n  OutputFormat,\r\n  IDetailedFormat,\r\n  IDetailedCell,\r\n  IFlatFormat,\r\n  IFlatFormatMultiSheet,\r\n  ExcelReaderResult\r\n} from '../types/reader.types';\r\nimport { IErrorResult, ErrorType } from '../types/core.types';\r\n\r\n/**\r\n * ExcelReader class for reading Excel files and converting to JSON\r\n */\r\nexport class ExcelReader {\r\n  /**\r\n   * Read Excel file from ArrayBuffer\r\n   */\r\n  static async fromBuffer<T extends OutputFormat = OutputFormat.WORKSHEET>(\r\n    buffer: ArrayBuffer,\r\n    options: IExcelReaderOptions = {}\r\n  ): Promise<ExcelReaderResult<T>> {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      const workbook = new ExcelJS.Workbook();\r\n      await workbook.xlsx.load(buffer);\r\n\r\n      const outputFormat = (options.outputFormat || OutputFormat.WORKSHEET) as OutputFormat;\r\n      const processingTime = Date.now() - startTime;\r\n\r\n      let result: unknown;\r\n\r\n      switch (outputFormat) {\r\n        case OutputFormat.DETAILED:\r\n          result = this.convertToDetailedFormat(workbook, options);\r\n          break;\r\n        case OutputFormat.FLAT:\r\n          result = this.convertToFlatFormat(workbook, options);\r\n          break;\r\n        case OutputFormat.WORKSHEET:\r\n        default:\r\n          result = this.convertWorkbookToJson(workbook, options);\r\n          break;\r\n      }\r\n\r\n      // Apply mapper function if provided\r\n      if (options.mapper) {\r\n        try {\r\n          // Apply mapper based on output format\r\n          switch (outputFormat) {\r\n            case OutputFormat.DETAILED:\r\n              result = (options.mapper as (data: IDetailedFormat) => unknown)(result as IDetailedFormat);\r\n              break;\r\n            case OutputFormat.FLAT:\r\n              result = (options.mapper as (data: IFlatFormat | IFlatFormatMultiSheet) => unknown)(result as IFlatFormat | IFlatFormatMultiSheet);\r\n              break;\r\n            case OutputFormat.WORKSHEET:\r\n            default:\r\n              result = (options.mapper as (data: IJsonWorkbook) => unknown)(result as IJsonWorkbook);\r\n              break;\r\n          }\r\n        } catch (mapperError) {\r\n          const errorResult: IErrorResult = {\r\n            success: false,\r\n            error: {\r\n              type: ErrorType.VALIDATION_ERROR,\r\n              message: mapperError instanceof Error \r\n                ? `Mapper function error: ${mapperError.message}` \r\n                : 'Error in mapper function',\r\n              stack: mapperError instanceof Error ? (mapperError.stack || '') : ''\r\n            }\r\n          };\r\n          return {\r\n            ...errorResult,\r\n            processingTime: Date.now() - startTime\r\n          } as unknown as ExcelReaderResult<T>;\r\n        }\r\n      }\r\n\r\n      const successResult = {\r\n        success: true as const,\r\n        data: result,\r\n        processingTime\r\n      };\r\n\r\n      return successResult as ExcelReaderResult<T>;\r\n    } catch (error) {\r\n      const errorResult: IErrorResult = {\r\n        success: false,\r\n        error: {\r\n          type: ErrorType.VALIDATION_ERROR,\r\n          message: error instanceof Error ? error.message : 'Error reading Excel file',\r\n          stack: error instanceof Error ? (error.stack || '') : ''\r\n        }\r\n      };\r\n\r\n      const errorResponse = {\r\n        success: false as const,\r\n        error: errorResult.error,\r\n        processingTime: Date.now() - startTime\r\n      };\r\n      return errorResponse as unknown as ExcelReaderResult<T>;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read Excel file from Blob\r\n   */\r\n  static async fromBlob<T extends OutputFormat = OutputFormat.WORKSHEET>(\r\n    blob: Blob,\r\n    options: IExcelReaderOptions = {}\r\n  ): Promise<ExcelReaderResult<T>> {\r\n    const arrayBuffer = await blob.arrayBuffer();\r\n    return this.fromBuffer<T>(arrayBuffer, options);\r\n  }\r\n\r\n  /**\r\n   * Read Excel file from File (browser)\r\n   */\r\n  static async fromFile<T extends OutputFormat = OutputFormat.WORKSHEET>(\r\n    file: File,\r\n    options: IExcelReaderOptions = {}\r\n  ): Promise<ExcelReaderResult<T>> {\r\n    return this.fromBlob<T>(file, options);\r\n  }\r\n\r\n  /**\r\n   * Read Excel file from path (Node.js)\r\n   * Note: This method only works in Node.js environment\r\n   */\r\n  /**\r\n   * Read Excel file from path (Node.js only)\r\n   * Note: This method only works in Node.js environment\r\n   */\r\n  static async fromPath<T extends OutputFormat = OutputFormat.WORKSHEET>(\r\n    filePath: string,\r\n    options: IExcelReaderOptions = {}\r\n  ): Promise<ExcelReaderResult<T>> {\r\n    try {\r\n      // Dynamic import - only loads fs in Node.js environment\r\n      // This allows the code to work in both browser and Node.js\r\n      // @ts-expect-error - fs/promises is a Node.js module, not available in browser\r\n      const fs = await import('fs/promises');\r\n      const buffer = await fs.readFile(filePath);\r\n      const arrayBuffer = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\r\n      return this.fromBuffer(arrayBuffer, options);\r\n    } catch (error) {\r\n      // Check if error is because fs is not available (browser environment)\r\n      const isBrowserError = error instanceof Error && \r\n        (error.message.includes('Cannot find module') || \r\n         error.message.includes('fs') ||\r\n         (typeof window !== 'undefined'));\r\n      \r\n      const errorResult: IErrorResult = {\r\n        success: false,\r\n        error: {\r\n          type: ErrorType.VALIDATION_ERROR,\r\n          message: isBrowserError \r\n            ? 'fromPath() method requires Node.js environment. Use fromFile() or fromBlob() in browser.'\r\n            : (error instanceof Error ? error.message : 'Error reading file from path'),\r\n          stack: error instanceof Error ? (error.stack || '') : ''\r\n        }\r\n      };\r\n\r\n      const errorResponse = {\r\n        ...errorResult,\r\n        processingTime: 0\r\n      };\r\n      return errorResponse as unknown as ExcelReaderResult<T>;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert ExcelJS Workbook to JSON\r\n   */\r\n  private static convertWorkbookToJson(\r\n    workbook: ExcelJS.Workbook,\r\n    options: IExcelReaderOptions\r\n  ): IJsonWorkbook {\r\n    const {\r\n      includeEmptyRows = false,\r\n      useFirstRowAsHeaders = false,\r\n      headers,\r\n      sheetName,\r\n      startRow = 1,\r\n      endRow,\r\n      startColumn = 1,\r\n      endColumn,\r\n      includeFormatting = false,\r\n      includeFormulas = false,\r\n      datesAsISO = true\r\n    } = options;\r\n\r\n    // Get metadata\r\n    const metadata = {\r\n      title: workbook.title,\r\n      author: workbook.creator,\r\n      company: workbook.company,\r\n      created: workbook.created,\r\n      modified: workbook.modified,\r\n      description: workbook.description\r\n    };\r\n\r\n    // Filter sheets\r\n    let sheetsToProcess: ExcelJS.Worksheet[] = [];\r\n    \r\n    if (sheetName !== undefined) {\r\n      if (typeof sheetName === 'number') {\r\n        const sheet = workbook.worksheets[sheetName];\r\n        if (sheet) sheetsToProcess.push(sheet);\r\n      } else {\r\n        const sheet = workbook.getWorksheet(sheetName);\r\n        if (sheet) sheetsToProcess.push(sheet);\r\n      }\r\n    } else {\r\n      sheetsToProcess = workbook.worksheets;\r\n    }\r\n\r\n    // Convert each sheet\r\n    const sheets: IJsonSheet[] = sheetsToProcess.map((worksheet) => {\r\n      const sheetOptions: {\r\n        includeEmptyRows: boolean;\r\n        useFirstRowAsHeaders: boolean;\r\n        headers?: string[] | Record<number, string>;\r\n        startRow: number;\r\n        endRow?: number;\r\n        startColumn: number;\r\n        endColumn?: number;\r\n        includeFormatting: boolean;\r\n        includeFormulas: boolean;\r\n        datesAsISO: boolean;\r\n      } = {\r\n        includeEmptyRows: includeEmptyRows ?? false,\r\n        useFirstRowAsHeaders: useFirstRowAsHeaders ?? false,\r\n        startRow: startRow ?? 1,\r\n        startColumn: startColumn ?? 1,\r\n        includeFormatting: includeFormatting ?? false,\r\n        includeFormulas: includeFormulas ?? false,\r\n        datesAsISO: datesAsISO ?? true\r\n      };\r\n\r\n      if (headers !== undefined) {\r\n        sheetOptions.headers = headers;\r\n      }\r\n      if (endRow !== undefined) {\r\n        sheetOptions.endRow = endRow;\r\n      }\r\n      if (endColumn !== undefined) {\r\n        sheetOptions.endColumn = endColumn;\r\n      }\r\n\r\n      return this.convertSheetToJson(worksheet, sheetOptions);\r\n    });\r\n\r\n    const workbookResult: IJsonWorkbook = {\r\n      sheets,\r\n      totalSheets: sheets.length\r\n    };\r\n\r\n    // Only add metadata if it has at least one property\r\n    const hasMetadata = Object.values(metadata).some(val => val !== undefined && val !== null);\r\n    if (hasMetadata) {\r\n      workbookResult.metadata = metadata;\r\n    }\r\n\r\n    return workbookResult;\r\n  }\r\n\r\n  /**\r\n   * Convert ExcelJS Worksheet to JSON\r\n   */\r\n  private static convertSheetToJson(\r\n    worksheet: ExcelJS.Worksheet,\r\n    options: {\r\n      includeEmptyRows: boolean;\r\n      useFirstRowAsHeaders: boolean;\r\n      headers?: string[] | Record<number, string>;\r\n      startRow: number;\r\n      endRow?: number;\r\n      startColumn: number;\r\n      endColumn?: number;\r\n      includeFormatting: boolean;\r\n      includeFormulas: boolean;\r\n      datesAsISO: boolean;\r\n    }\r\n  ): IJsonSheet {\r\n    const {\r\n      includeEmptyRows,\r\n      useFirstRowAsHeaders,\r\n      headers,\r\n      startRow,\r\n      endRow,\r\n      startColumn,\r\n      endColumn,\r\n      includeFormatting,\r\n      includeFormulas,\r\n      datesAsISO\r\n    } = options;\r\n\r\n    const rows: IJsonRow[] = [];\r\n    let headerRow: string[] | undefined;\r\n    let maxColumns = 0;\r\n\r\n    // Determine row range\r\n    const actualStartRow = Math.max(startRow, 1);\r\n    const actualEndRow = endRow || worksheet.rowCount || worksheet.lastRow?.number || 1;\r\n    const actualStartCol = Math.max(startColumn, 1);\r\n    const actualEndCol = endColumn || worksheet.columnCount || worksheet.lastColumn?.number || 1;\r\n\r\n    // Process rows\r\n    for (let rowNum = actualStartRow; rowNum <= actualEndRow; rowNum++) {\r\n      const excelRow = worksheet.getRow(rowNum);\r\n      const cells: IJsonCell[] = [];\r\n      let hasData = false;\r\n\r\n      // Process cells in row\r\n      for (let colNum = actualStartCol; colNum <= actualEndCol; colNum++) {\r\n        const cell = excelRow.getCell(colNum);\r\n        \r\n        // Skip if cell is empty and we're not including empty rows\r\n        if (!cell.value && !includeEmptyRows) {\r\n          continue;\r\n        }\r\n\r\n        const jsonCell = this.convertCellToJson(cell, {\r\n          includeFormatting,\r\n          includeFormulas,\r\n          datesAsISO\r\n        });\r\n\r\n        cells.push(jsonCell);\r\n        hasData = true;\r\n      }\r\n\r\n      // Track max columns\r\n      if (cells.length > maxColumns) {\r\n        maxColumns = cells.length;\r\n      }\r\n\r\n      // Skip empty rows if configured\r\n      if (!hasData && !includeEmptyRows) {\r\n        continue;\r\n      }\r\n\r\n      // Handle headers\r\n      if (useFirstRowAsHeaders && rowNum === actualStartRow) {\r\n        headerRow = cells.map(cell => {\r\n          if (headers && Array.isArray(headers)) {\r\n            return headers[cells.indexOf(cell)] || String(cell.value || '');\r\n          } else if (headers && typeof headers === 'object') {\r\n            return headers[actualStartCol + cells.indexOf(cell)] || String(cell.value || '');\r\n          }\r\n          return String(cell.value || '');\r\n        });\r\n        continue; // Skip header row in data\r\n      }\r\n\r\n      // Create row data object if headers are used\r\n      let rowData: Record<string, unknown> | undefined;\r\n      if (useFirstRowAsHeaders && headerRow) {\r\n        rowData = {};\r\n        cells.forEach((cell, index) => {\r\n          const header = headerRow![index] || `column_${index + 1}`;\r\n          rowData![header] = cell.value;\r\n        });\r\n      }\r\n\r\n      const jsonRow: IJsonRow = {\r\n        rowNumber: rowNum,\r\n        cells\r\n      };\r\n\r\n      if (rowData) {\r\n        jsonRow.data = rowData;\r\n      }\r\n\r\n      rows.push(jsonRow);\r\n    }\r\n\r\n    const sheet: IJsonSheet = {\r\n      name: worksheet.name,\r\n      index: worksheet.id || 0,\r\n      rows,\r\n      totalRows: rows.length,\r\n      totalColumns: maxColumns\r\n    };\r\n\r\n    if (headerRow) {\r\n      sheet.headers = headerRow;\r\n    }\r\n\r\n    return sheet;\r\n  }\r\n\r\n  /**\r\n   * Convert ExcelJS Cell to JSON\r\n   */\r\n  private static convertCellToJson(\r\n    cell: ExcelJS.Cell,\r\n    options: {\r\n      includeFormatting: boolean;\r\n      includeFormulas: boolean;\r\n      datesAsISO: boolean;\r\n    }\r\n  ): IJsonCell {\r\n    const { includeFormatting, includeFormulas, datesAsISO } = options;\r\n\r\n    let value: unknown = cell.value;\r\n    let type: string | undefined;\r\n\r\n    // Determine type and convert value\r\n    if (cell.type === ExcelJS.ValueType.Null || cell.value === null || cell.value === undefined) {\r\n      value = null;\r\n      type = 'null';\r\n    } else if (cell.type === ExcelJS.ValueType.Number) {\r\n      value = cell.value as number;\r\n      type = 'number';\r\n    } else if (cell.type === ExcelJS.ValueType.String) {\r\n      value = cell.value as string;\r\n      type = 'string';\r\n    } else if (cell.type === ExcelJS.ValueType.Date) {\r\n      const dateValue = cell.value as Date;\r\n      value = datesAsISO ? dateValue.toISOString() : dateValue;\r\n      type = 'date';\r\n    } else if (cell.type === ExcelJS.ValueType.Boolean) {\r\n      value = cell.value as boolean;\r\n      type = 'boolean';\r\n    } else if (cell.type === ExcelJS.ValueType.Formula) {\r\n      if (includeFormulas && cell.formula) {\r\n        value = cell.result || cell.value;\r\n        type = 'formula';\r\n      } else {\r\n        value = cell.result || cell.value;\r\n        type = typeof cell.result === 'number' ? 'number' : typeof cell.result === 'string' ? 'string' : 'unknown';\r\n      }\r\n    } else if (cell.type === ExcelJS.ValueType.Hyperlink) {\r\n      // Handle hyperlink - ExcelJS stores hyperlinks as objects with text and hyperlink properties\r\n      const hyperlinkValue = cell.value as { text?: string; hyperlink?: string } | string;\r\n      if (typeof hyperlinkValue === 'object' && hyperlinkValue !== null) {\r\n        value = hyperlinkValue.text || hyperlinkValue.hyperlink || cell.value;\r\n      } else {\r\n        value = hyperlinkValue;\r\n      }\r\n      type = 'hyperlink';\r\n    } else {\r\n      value = cell.value;\r\n      type = 'unknown';\r\n    }\r\n\r\n    const jsonCell: IJsonCell = {\r\n      value,\r\n      type,\r\n      reference: cell.address\r\n    };\r\n\r\n    // Add formatted value if requested\r\n    if (includeFormatting && cell.numFmt) {\r\n      // Try to get formatted value (ExcelJS doesn't always provide this easily)\r\n      jsonCell.formattedValue = String(value);\r\n    }\r\n\r\n    // Add formula if requested\r\n    if (includeFormulas && cell.formula) {\r\n      jsonCell.formula = cell.formula;\r\n    }\r\n\r\n    return jsonCell;\r\n  }\r\n\r\n  /**\r\n   * Convert workbook to detailed format (with position information)\r\n   */\r\n  private static convertToDetailedFormat(\r\n    workbook: ExcelJS.Workbook,\r\n    options: IExcelReaderOptions\r\n  ): IDetailedFormat {\r\n    const {\r\n      includeEmptyRows = false,\r\n      includeFormatting = false,\r\n      includeFormulas = false,\r\n      datesAsISO = true,\r\n      sheetName,\r\n      startRow = 1,\r\n      endRow,\r\n      startColumn = 1,\r\n      endColumn\r\n    } = options;\r\n\r\n    const cells: IDetailedCell[] = [];\r\n\r\n    // Get metadata\r\n    const metadata = {\r\n      title: workbook.title,\r\n      author: workbook.creator,\r\n      company: workbook.company,\r\n      created: workbook.created,\r\n      modified: workbook.modified,\r\n      description: workbook.description\r\n    };\r\n\r\n    // Filter sheets\r\n    let sheetsToProcess: ExcelJS.Worksheet[] = [];\r\n    \r\n    if (sheetName !== undefined) {\r\n      if (typeof sheetName === 'number') {\r\n        const sheet = workbook.worksheets[sheetName];\r\n        if (sheet) sheetsToProcess.push(sheet);\r\n      } else {\r\n        const sheet = workbook.getWorksheet(sheetName);\r\n        if (sheet) sheetsToProcess.push(sheet);\r\n      }\r\n    } else {\r\n      sheetsToProcess = workbook.worksheets;\r\n    }\r\n\r\n    // Process each sheet\r\n    for (const worksheet of sheetsToProcess) {\r\n      const actualStartRow = Math.max(startRow, 1);\r\n      const actualEndRow = endRow || worksheet.rowCount || worksheet.lastRow?.number || 1;\r\n      const actualStartCol = Math.max(startColumn, 1);\r\n      const actualEndCol = endColumn || worksheet.columnCount || worksheet.lastColumn?.number || 1;\r\n\r\n      for (let rowNum = actualStartRow; rowNum <= actualEndRow; rowNum++) {\r\n        const excelRow = worksheet.getRow(rowNum);\r\n\r\n        for (let colNum = actualStartCol; colNum <= actualEndCol; colNum++) {\r\n          const cell = excelRow.getCell(colNum);\r\n\r\n          // Skip empty cells if configured\r\n          if (!cell.value && !includeEmptyRows) {\r\n            continue;\r\n          }\r\n\r\n          // Convert column number to letter (1 = A, 2 = B, etc.)\r\n          const columnLetter = this.numberToColumnLetter(colNum);\r\n          const cellValue = this.getCellValue(cell, { includeFormatting, includeFormulas, datesAsISO });\r\n\r\n          const detailedCell: IDetailedCell = {\r\n            value: cellValue.value,\r\n            text: String(cellValue.value ?? ''),\r\n            column: colNum,\r\n            columnLetter,\r\n            row: rowNum,\r\n            reference: cell.address || `${columnLetter}${rowNum}`,\r\n            sheet: worksheet.name\r\n          };\r\n\r\n          if (cellValue.type) {\r\n            detailedCell.type = cellValue.type;\r\n          }\r\n          if (cellValue.formattedValue) {\r\n            detailedCell.formattedValue = cellValue.formattedValue;\r\n          }\r\n          if (cellValue.formula) {\r\n            detailedCell.formula = cellValue.formula;\r\n          }\r\n\r\n          cells.push(detailedCell);\r\n        }\r\n      }\r\n    }\r\n\r\n    const result: IDetailedFormat = {\r\n      cells,\r\n      totalCells: cells.length\r\n    };\r\n\r\n    const hasMetadata = Object.values(metadata).some(val => val !== undefined && val !== null);\r\n    if (hasMetadata) {\r\n      result.metadata = metadata;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Convert workbook to flat format (just data)\r\n   */\r\n  private static convertToFlatFormat(\r\n    workbook: ExcelJS.Workbook,\r\n    options: IExcelReaderOptions\r\n  ): IFlatFormat | IFlatFormatMultiSheet {\r\n    const {\r\n      useFirstRowAsHeaders = false,\r\n      includeEmptyRows = false,\r\n      sheetName,\r\n      startRow = 1,\r\n      endRow,\r\n      startColumn = 1,\r\n      endColumn\r\n    } = options;\r\n\r\n    // Get metadata\r\n    const metadata = {\r\n      title: workbook.title,\r\n      author: workbook.creator,\r\n      company: workbook.company,\r\n      created: workbook.created,\r\n      modified: workbook.modified,\r\n      description: workbook.description\r\n    };\r\n\r\n    // Filter sheets\r\n    let sheetsToProcess: ExcelJS.Worksheet[] = [];\r\n    \r\n    if (sheetName !== undefined) {\r\n      if (typeof sheetName === 'number') {\r\n        const sheet = workbook.worksheets[sheetName];\r\n        if (sheet) sheetsToProcess.push(sheet);\r\n      } else {\r\n        const sheet = workbook.getWorksheet(sheetName);\r\n        if (sheet) sheetsToProcess.push(sheet);\r\n      }\r\n    } else {\r\n      sheetsToProcess = workbook.worksheets;\r\n    }\r\n\r\n    // If single sheet, return single format\r\n    if (sheetsToProcess.length === 1) {\r\n      const worksheet = sheetsToProcess[0]!;\r\n      const flatOptions: {\r\n        useFirstRowAsHeaders: boolean;\r\n        includeEmptyRows: boolean;\r\n        startRow: number;\r\n        endRow?: number;\r\n        startColumn?: number;\r\n        endColumn?: number;\r\n      } = {\r\n        useFirstRowAsHeaders,\r\n        includeEmptyRows,\r\n        startRow\r\n      };\r\n\r\n      if (endRow !== undefined) {\r\n        flatOptions.endRow = endRow;\r\n      }\r\n      if (startColumn !== undefined) {\r\n        flatOptions.startColumn = startColumn;\r\n      }\r\n      if (endColumn !== undefined) {\r\n        flatOptions.endColumn = endColumn;\r\n      }\r\n\r\n      const flatData = this.convertSheetToFlat(worksheet, flatOptions);\r\n      return flatData;\r\n    }\r\n\r\n    // Multiple sheets - return multi-sheet format\r\n    const sheets: Record<string, IFlatFormat> = {};\r\n    \r\n    for (const worksheet of sheetsToProcess) {\r\n      const flatOptions: {\r\n        useFirstRowAsHeaders: boolean;\r\n        includeEmptyRows: boolean;\r\n        startRow: number;\r\n        endRow?: number;\r\n        startColumn?: number;\r\n        endColumn?: number;\r\n      } = {\r\n        useFirstRowAsHeaders,\r\n        includeEmptyRows,\r\n        startRow\r\n      };\r\n\r\n      if (endRow !== undefined) {\r\n        flatOptions.endRow = endRow;\r\n      }\r\n      if (startColumn !== undefined) {\r\n        flatOptions.startColumn = startColumn;\r\n      }\r\n      if (endColumn !== undefined) {\r\n        flatOptions.endColumn = endColumn;\r\n      }\r\n\r\n      const flatData = this.convertSheetToFlat(worksheet, flatOptions);\r\n      sheets[worksheet.name] = flatData;\r\n    }\r\n\r\n    const result: IFlatFormatMultiSheet = {\r\n      sheets,\r\n      totalSheets: Object.keys(sheets).length\r\n    };\r\n\r\n    const hasMetadata = Object.values(metadata).some(val => val !== undefined && val !== null);\r\n    if (hasMetadata) {\r\n      result.metadata = metadata;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Convert a single sheet to flat format\r\n   */\r\n  private static convertSheetToFlat(\r\n    worksheet: ExcelJS.Worksheet,\r\n    options: {\r\n      useFirstRowAsHeaders: boolean;\r\n      includeEmptyRows: boolean;\r\n      startRow: number;\r\n      endRow?: number;\r\n      startColumn?: number;\r\n      endColumn?: number;\r\n    }\r\n  ): IFlatFormat {\r\n    const {\r\n      useFirstRowAsHeaders,\r\n      includeEmptyRows,\r\n      startRow,\r\n      endRow,\r\n      startColumn,\r\n      endColumn\r\n    } = options;\r\n\r\n    const actualStartRow = Math.max(startRow, 1);\r\n    const actualEndRow = endRow || worksheet.rowCount || worksheet.lastRow?.number || 1;\r\n    const actualStartCol = Math.max(startColumn || 1, 1);\r\n    const actualEndCol = endColumn || worksheet.columnCount || worksheet.lastColumn?.number || 1;\r\n\r\n    const data: Array<Record<string, unknown> | unknown[]> = [];\r\n    let headers: string[] | undefined;\r\n\r\n    // Get headers if needed\r\n    if (useFirstRowAsHeaders) {\r\n      const headerRow = worksheet.getRow(actualStartRow);\r\n      headers = [];\r\n      for (let colNum = actualStartCol; colNum <= actualEndCol; colNum++) {\r\n        const cell = headerRow.getCell(colNum);\r\n        headers.push(String(cell.value || `Column${colNum}`));\r\n      }\r\n    }\r\n\r\n    // Process data rows\r\n    const dataStartRow = useFirstRowAsHeaders ? actualStartRow + 1 : actualStartRow;\r\n    \r\n    for (let rowNum = dataStartRow; rowNum <= actualEndRow; rowNum++) {\r\n      const excelRow = worksheet.getRow(rowNum);\r\n      const rowValues: unknown[] = [];\r\n      let hasData = false;\r\n\r\n      for (let colNum = actualStartCol; colNum <= actualEndCol; colNum++) {\r\n        const cell = excelRow.getCell(colNum);\r\n        const cellValue = this.getCellValue(cell, { includeFormatting: false, includeFormulas: false, datesAsISO: true });\r\n        rowValues.push(cellValue.value);\r\n        if (cellValue.value !== null && cellValue.value !== undefined && cellValue.value !== '') {\r\n          hasData = true;\r\n        }\r\n      }\r\n\r\n      if (!hasData && !includeEmptyRows) {\r\n        continue;\r\n      }\r\n\r\n      if (useFirstRowAsHeaders && headers) {\r\n        // Convert to object\r\n        const rowObject: Record<string, unknown> = {};\r\n        headers.forEach((header, index) => {\r\n          rowObject[header] = rowValues[index];\r\n        });\r\n        data.push(rowObject);\r\n      } else {\r\n        // Keep as array\r\n        data.push(rowValues);\r\n      }\r\n    }\r\n\r\n    const result: IFlatFormat = {\r\n      data,\r\n      totalRows: data.length,\r\n      sheet: worksheet.name\r\n    };\r\n\r\n    if (headers) {\r\n      result.headers = headers;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get cell value with type information\r\n   */\r\n  private static getCellValue(\r\n    cell: ExcelJS.Cell,\r\n    options: {\r\n      includeFormatting: boolean;\r\n      includeFormulas: boolean;\r\n      datesAsISO: boolean;\r\n    }\r\n  ): {\r\n    value: unknown;\r\n    type?: string;\r\n    formattedValue?: string;\r\n    formula?: string;\r\n  } {\r\n    const { includeFormatting, includeFormulas, datesAsISO } = options;\r\n\r\n    let value: unknown = cell.value;\r\n    let type: string | undefined;\r\n    let formattedValue: string | undefined;\r\n    let formula: string | undefined;\r\n\r\n    if (cell.type === ExcelJS.ValueType.Null || cell.value === null || cell.value === undefined) {\r\n      value = null;\r\n      type = 'null';\r\n    } else if (cell.type === ExcelJS.ValueType.Number) {\r\n      value = cell.value as number;\r\n      type = 'number';\r\n    } else if (cell.type === ExcelJS.ValueType.String) {\r\n      value = cell.value as string;\r\n      type = 'string';\r\n    } else if (cell.type === ExcelJS.ValueType.Date) {\r\n      const dateValue = cell.value as Date;\r\n      value = datesAsISO ? dateValue.toISOString() : dateValue;\r\n      type = 'date';\r\n    } else if (cell.type === ExcelJS.ValueType.Boolean) {\r\n      value = cell.value as boolean;\r\n      type = 'boolean';\r\n    } else if (cell.type === ExcelJS.ValueType.Formula) {\r\n      if (includeFormulas && cell.formula) {\r\n        formula = cell.formula;\r\n        value = cell.result || cell.value;\r\n        type = 'formula';\r\n      } else {\r\n        value = cell.result || cell.value;\r\n        type = typeof cell.result === 'number' ? 'number' : typeof cell.result === 'string' ? 'string' : 'unknown';\r\n      }\r\n    } else if (cell.type === ExcelJS.ValueType.Hyperlink) {\r\n      const hyperlinkValue = cell.value as { text?: string; hyperlink?: string } | string;\r\n      if (typeof hyperlinkValue === 'object' && hyperlinkValue !== null) {\r\n        value = hyperlinkValue.text || hyperlinkValue.hyperlink || cell.value;\r\n      } else {\r\n        value = hyperlinkValue;\r\n      }\r\n      type = 'hyperlink';\r\n    } else {\r\n      value = cell.value;\r\n      type = 'unknown';\r\n    }\r\n\r\n    if (includeFormatting && cell.numFmt) {\r\n      formattedValue = String(value);\r\n    }\r\n\r\n    return {\r\n      value,\r\n      type,\r\n      ...(formattedValue && { formattedValue }),\r\n      ...(formula && { formula })\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Convert column number to letter (1 = A, 2 = B, 27 = AA, etc.)\r\n   */\r\n  private static numberToColumnLetter(columnNumber: number): string {\r\n    let result = '';\r\n    while (columnNumber > 0) {\r\n      columnNumber--;\r\n      result = String.fromCharCode(65 + (columnNumber % 26)) + result;\r\n      columnNumber = Math.floor(columnNumber / 26);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\n"],"names":["EventEmitter","listeners","Map","on","type","listener","options","this","has","set","registration","once","async","priority","stopPropagation","id","generateId","active","timestamp","Date","get","push","sort","a","b","off","listenerId","index","findIndex","reg","splice","offAll","count","length","delete","emit","event","activeListeners","filter","error","console","cleanupInactiveListeners","emitSync","clear","getListeners","getListenerCount","getEventTypes","Array","from","keys","Math","random","toString","substr","CellType","NumberFormat","HorizontalAlignment","VerticalAlignment","BorderStyle","FontStyle","ErrorType","Worksheet","config","tables","currentRow","currentCol","headerPointers","isBuilt","headers","subHeaders","body","footers","constructor","addHeader","header","addSubHeaders","addRow","row","isArray","addFooter","footer","addTable","tableConfig","table","name","showBorders","showStripes","style","finalizeTable","currentTable","Error","getTable","find","build","workbook","_options","ws","addWorksheet","properties","defaultRowHeight","tabColor","pageSetup","rowPointer","i","buildTable","buildLegacyContent","startRow","addSpacing","processCellValue","mergeCell","maxCols","calculateTableMaxColumns","mergeCells","styles","getRow","eachCell","cell","convertStyle","applyCellDimensions","buildNestedHeaders","addDataRowRecursive","addFooterRow","applyTableStyle","forEach","getMaxColumns","calculateHeaderColSpan","endRow","col","getCell","border","top","color","argb","left","bottom","right","fill","pattern","fgColor","maxDepth","getMaxHeaderDepth","depth","colIndex","headerInfo","getHeaderAtDepth","value","colSpan","children","child","applyAllMerges","startCol","mergeRange","start","end","String","childColSpan","applySmartMerges","applySmartMergesForHeader","headerColSpan","childColIndex","reduce","total","childDepth","max","validate","success","data","VALIDATION_ERROR","message","calculateDataColumnPositions","positions","key","columnPositions","footerColPosition","excelRow","footerCell","numberFormat","numFmt","mergeTo","colPosition","childCell","jump","rowHeight","height","colWidth","getColumn","width","link","LINK","linkUrl","trim","displayText","mask","text","hyperlink","mainColPosition","mainCell","convertColor","r","padStart","g","toUpperCase","hex","replace","split","map","c","join","converted","font","family","size","bold","italic","underline","backgroundColor","foregroundColor","bgColor","alignment","horizontal","includes","vertical","wrapText","Boolean","shrinkToFit","indent","textRotation","readingOrder","Object","BuilderEventType","ExcelBuilder","worksheets","currentWorksheet","isBuilding","stats","eventEmitter","enableValidation","enableEvents","enablePerformanceMonitoring","maxWorksheets","maxRowsPerWorksheet","maxColumnsPerWorksheet","memoryLimit","initializeStats","worksheetConfig","defaultColWidth","defaultWorksheetConfig","worksheet","emitEvent","WORKSHEET_ADDED","worksheetName","getWorksheet","removeWorksheet","WORKSHEET_REMOVED","setCurrentWorksheet","BUILD_ERROR","stack","startTime","now","BUILD_STARTED","ExcelJS","Workbook","metadata","creator","author","lastModifiedBy","created","modified","title","subject","keywords","category","description","values","buffer","xlsx","writeBuffer","compression","compressionLevel","endTime","buildTime","fileSize","byteLength","successResult","BUILD_COMPLETED","errorResult","generateAndDownload","fileName","buildResult","DOWNLOAD_STARTED","blob","Blob","mimeType","saveAs","DOWNLOAD_COMPLETED","DOWNLOAD_ERROR","toBuffer","toBlob","errors","entries","worksheetValidation","getStats","eventType","removeAllListeners","totalWorksheets","totalCells","memoryUsage","stylesUsed","formulasUsed","conditionalFormatsUsed","performance","headersTime","dataTime","stylesTime","writeTime","OutputFormat","StyleBuilder","CENTER","MIDDLE","create","fontName","fontSize","fontStyle","fontColor","fontBold","fontItalic","fontUnderline","borderTop","borderLeft","borderBottom","borderRight","horizontalAlign","verticalAlign","centerAlign","leftAlign","LEFT","rightAlign","RIGHT","format","striped","conditionalFormat","conditionalFormats","reset","clone","cloned","JSON","parse","stringify","CellEventType","WorksheetEventType","StylePreset","fromBuffer","load","outputFormat","WORKSHEET","processingTime","result","DETAILED","convertToDetailedFormat","FLAT","convertToFlatFormat","convertWorkbookToJson","mapper","mapperError","fromBlob","arrayBuffer","fromFile","file","fromPath","filePath","fs","Promise","resolve","then","require","readFile","slice","byteOffset","isBrowserError","window","includeEmptyRows","useFirstRowAsHeaders","sheetName","startColumn","endColumn","includeFormatting","includeFormulas","datesAsISO","company","sheetsToProcess","sheet","sheets","sheetOptions","convertSheetToJson","workbookResult","totalSheets","some","val","rows","headerRow","maxColumns","actualStartRow","actualEndRow","rowCount","lastRow","number","actualStartCol","actualEndCol","columnCount","lastColumn","rowNum","cells","rowData","hasData","colNum","jsonCell","convertCellToJson","indexOf","jsonRow","rowNumber","totalRows","totalColumns","ValueType","Null","Number","dateValue","toISOString","Formula","formula","Hyperlink","hyperlinkValue","reference","address","formattedValue","columnLetter","numberToColumnLetter","cellValue","getCellValue","detailedCell","column","flatOptions","convertSheetToFlat","flatData","rowValues","rowObject","columnNumber","fromCharCode","floor"],"mappings":"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"}