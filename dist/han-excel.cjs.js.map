{"version":3,"file":"han-excel.cjs.js","sources":["../src/utils/EventEmitter.ts","../src/types/core.types.ts","../src/core/Worksheet.ts","../src/types/builder.types.ts","../src/core/ExcelBuilder.ts","../src/types/reader.types.ts","../src/styles/StyleBuilder.ts","../src/types/cell.types.ts","../src/types/worksheet.types.ts","../src/types/style.types.ts","../src/core/ExcelReader.ts"],"sourcesContent":["/**\r\n * Simple EventEmitter implementation\r\n */\r\n\r\n/**\r\n * Event listener function type\r\n */\r\nexport type EventListener<T = any> = (event: T) => void | Promise<void>;\r\n\r\n/**\r\n * Event listener options\r\n */\r\nexport interface EventListenerOptions {\r\n  /** Whether to execute the listener only once */\r\n  once?: boolean;\r\n  /** Whether to execute the listener asynchronously */\r\n  async?: boolean;\r\n  /** Priority of the listener (higher = executed first) */\r\n  priority?: number;\r\n  /** Whether to stop event propagation */\r\n  stopPropagation?: boolean;\r\n}\r\n\r\n/**\r\n * Event listener registration\r\n */\r\nexport interface EventListenerRegistration {\r\n  /** Event type */\r\n  type: string;\r\n  /** Listener function */\r\n  listener: EventListener;\r\n  /** Listener options */\r\n  options: EventListenerOptions;\r\n  /** Registration ID */\r\n  id: string;\r\n  /** Whether the listener is active */\r\n  active: boolean;\r\n  /** Registration timestamp */\r\n  timestamp: Date;\r\n}\r\n\r\n/**\r\n * EventEmitter class for handling events\r\n */\r\nexport class EventEmitter {\r\n  private listeners: Map<string, EventListenerRegistration[]> = new Map();\r\n\r\n  /**\r\n   * Add an event listener\r\n   */\r\n  on<T = any>(type: string, listener: EventListener<T>, options: EventListenerOptions = {}): string {\r\n    if (!this.listeners.has(type)) {\r\n      this.listeners.set(type, []);\r\n    }\r\n\r\n    const registration: EventListenerRegistration = {\r\n      type,\r\n      listener: listener as EventListener,\r\n      options: {\r\n        once: false,\r\n        async: false,\r\n        priority: 0,\r\n        stopPropagation: false,\r\n        ...options\r\n      },\r\n      id: this.generateId(),\r\n      active: true,\r\n      timestamp: new Date()\r\n    };\r\n\r\n    this.listeners.get(type)!.push(registration);\r\n    \r\n    // Sort by priority (higher priority first)\r\n    this.listeners.get(type)!.sort((a, b) => (b.options.priority || 0) - (a.options.priority || 0));\r\n\r\n    return registration.id;\r\n  }\r\n\r\n  /**\r\n   * Add a one-time event listener\r\n   */\r\n  once<T = any>(type: string, listener: EventListener<T>, options: EventListenerOptions = {}): string {\r\n    return this.on(type, listener, { ...options, once: true });\r\n  }\r\n\r\n  /**\r\n   * Remove an event listener\r\n   */\r\n  off(type: string, listenerId: string): boolean {\r\n    const listeners = this.listeners.get(type);\r\n    if (!listeners) {\r\n      return false;\r\n    }\r\n\r\n    const index = listeners.findIndex(reg => reg.id === listenerId);\r\n    if (index === -1) {\r\n      return false;\r\n    }\r\n\r\n    listeners.splice(index, 1);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Remove all listeners for an event type\r\n   */\r\n  offAll(type: string): number {\r\n    const listeners = this.listeners.get(type);\r\n    if (!listeners) {\r\n      return 0;\r\n    }\r\n\r\n    const count = listeners.length;\r\n    this.listeners.delete(type);\r\n    return count;\r\n  }\r\n\r\n  /**\r\n   * Emit an event\r\n   */\r\n  async emit<T = any>(event: T): Promise<void> {\r\n    const type = (event as any).type || 'default';\r\n    const listeners = this.listeners.get(type);\r\n    \r\n    if (!listeners || listeners.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const activeListeners = listeners.filter(reg => reg.active);\r\n    \r\n    for (const registration of activeListeners) {\r\n      try {\r\n        if (registration.options.once) {\r\n          registration.active = false;\r\n        }\r\n\r\n        if (registration.options.async) {\r\n          await registration.listener(event);\r\n        } else {\r\n          registration.listener(event);\r\n        }\r\n\r\n        if (registration.options.stopPropagation) {\r\n          break;\r\n        }\r\n      } catch (error) {\r\n        console.error(`Error in event listener for ${type}:`, error);\r\n      }\r\n    }\r\n\r\n    // Clean up inactive listeners\r\n    this.cleanupInactiveListeners(type);\r\n  }\r\n\r\n  /**\r\n   * Emit an event synchronously\r\n   */\r\n  emitSync<T = any>(event: T): void {\r\n    const type = (event as any).type || 'default';\r\n    const listeners = this.listeners.get(type);\r\n    \r\n    if (!listeners || listeners.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const activeListeners = listeners.filter(reg => reg.active);\r\n    \r\n    for (const registration of activeListeners) {\r\n      try {\r\n        if (registration.options.once) {\r\n          registration.active = false;\r\n        }\r\n\r\n        registration.listener(event);\r\n\r\n        if (registration.options.stopPropagation) {\r\n          break;\r\n        }\r\n      } catch (error) {\r\n        console.error(`Error in event listener for ${type}:`, error);\r\n      }\r\n    }\r\n\r\n    // Clean up inactive listeners\r\n    this.cleanupInactiveListeners(type);\r\n  }\r\n\r\n  /**\r\n   * Clear all listeners\r\n   */\r\n  clear(): void {\r\n    this.listeners.clear();\r\n  }\r\n\r\n  /**\r\n   * Get listeners for an event type\r\n   */\r\n  getListeners(type: string): EventListenerRegistration[] {\r\n    return this.listeners.get(type) || [];\r\n  }\r\n\r\n  /**\r\n   * Get listener count for an event type\r\n   */\r\n  getListenerCount(type: string): number {\r\n    return this.listeners.get(type)?.length || 0;\r\n  }\r\n\r\n  /**\r\n   * Get all registered event types\r\n   */\r\n  getEventTypes(): string[] {\r\n    return Array.from(this.listeners.keys());\r\n  }\r\n\r\n  // Private methods\r\n\r\n  private generateId(): string {\r\n    return Math.random().toString(36).substr(2, 9);\r\n  }\r\n\r\n  private cleanupInactiveListeners(type: string): void {\r\n    const listeners = this.listeners.get(type);\r\n    if (listeners) {\r\n      const activeListeners = listeners.filter(reg => reg.active);\r\n      if (activeListeners.length !== listeners.length) {\r\n        this.listeners.set(type, activeListeners);\r\n      }\r\n    }\r\n  }\r\n} ","/**\n * Core type definitions for Han Excel Builder\n */\n\nimport { CellValue } from 'exceljs';\n\n/**\n * Supported cell data types\n */\nexport enum CellType {\n  STRING = 'string',\n  NUMBER = 'number',\n  BOOLEAN = 'boolean',\n  DATE = 'date',\n  PERCENTAGE = 'percentage',\n  CURRENCY = 'currency',\n  LINK = 'link',\n  FORMULA = 'formula'\n}\n\n/**\n * Number format options\n */\nexport enum NumberFormat {\n  GENERAL = 'General',\n  NUMBER = '#,##0',\n  NUMBER_DECIMALS = '#,##0.00',\n  CURRENCY = '$#,##0.00',\n  CURRENCY_INTEGER = '$#,##0',\n  PERCENTAGE = '0%',\n  PERCENTAGE_DECIMALS = '0.00%',\n  DATE = 'dd/mm/yyyy',\n  DATE_TIME = 'dd/mm/yyyy hh:mm',\n  TIME = 'hh:mm:ss',\n  CUSTOM = 'custom'\n}\n\n/**\n * Horizontal alignment options\n */\nexport enum HorizontalAlignment {\n  LEFT = 'left',\n  CENTER = 'center',\n  RIGHT = 'right',\n  FILL = 'fill',\n  JUSTIFY = 'justify',\n  CENTER_CONTINUOUS = 'centerContinuous',\n  DISTRIBUTED = 'distributed'\n}\n\n/**\n * Vertical alignment options\n */\nexport enum VerticalAlignment {\n  TOP = 'top',\n  MIDDLE = 'middle',\n  BOTTOM = 'bottom',\n  DISTRIBUTED = 'distributed',\n  JUSTIFY = 'justify'\n}\n\n/**\n * Border style options\n */\nexport enum BorderStyle {\n  THIN = 'thin',\n  MEDIUM = 'medium',\n  THICK = 'thick',\n  DOTTED = 'dotted',\n  DASHED = 'dashed',\n  DOUBLE = 'double',\n  HAIR = 'hair',\n  MEDIUM_DASHED = 'mediumDashed',\n  DASH_DOT = 'dashDot',\n  MEDIUM_DASH_DOT = 'mediumDashDot',\n  DASH_DOT_DOT = 'dashDotDot',\n  MEDIUM_DASH_DOT_DOT = 'mediumDashDotDot',\n  SLANT_DASH_DOT = 'slantDashDot'\n}\n\n/**\n * Font style options\n */\nexport enum FontStyle {\n  NORMAL = 'normal',\n  BOLD = 'bold',\n  ITALIC = 'italic',\n  BOLD_ITALIC = 'bold italic'\n}\n\n/**\n * Color type - can be hex string, RGB object, or theme color\n */\nexport type Color = string | { r: number; g: number; b: number } | { theme: number };\n\n/**\n * Base cell properties interface\n */\nexport interface IBaseCell {\n  /** Unique identifier for the cell */\n  key: string;\n  /** Cell data type */\n  type: CellType;\n  /** Cell value */\n  value: CellValue;\n  /** Optional cell reference (e.g., A1, B2) */\n  reference?: string;\n  /** Whether to merge this cell with others */\n  mergeCell?: boolean;\n  /** Number of columns to merge (if mergeCell is true) */\n  mergeTo?: number;\n  /** Row height for this cell */\n  rowHeight?: number;\n  /** Column width for this cell */\n  colWidth?: number;\n  /** Whether to move to next row after this cell */\n  jump?: boolean;\n  /** Hyperlink URL */\n  link?: string;\n  /** Text mask for hyperlink (displayed text when link is present) */\n  mask?: string;\n  /** Excel formula */\n  formula?: string;\n  /** Number format for numeric cells */\n  numberFormat?: NumberFormat | string;\n  /** Custom number format string */\n  customNumberFormat?: string;\n  /** Whether the cell is protected */\n  protected?: boolean;\n  /** Whether the cell is hidden */\n  hidden?: boolean;\n  /** Cell comment */\n  comment?: string;\n  /** Data validation rules */\n  validation?: IDataValidation;\n  /** Optional styles for the cell */\n  styles?: import('./style.types').IStyle;\n  /** Predefined style name (references a style added via addCellStyle) */\n  styleName?: string;\n  /** Legacy children cells */\n  childrens?: IBaseCell[];\n  /** Modern children cells */\n  children?: IBaseCell[];\n}\n\n/**\n * Data validation interface\n */\nexport interface IDataValidation {\n  /** Validation type */\n  type: 'list' | 'whole' | 'decimal' | 'textLength' | 'date' | 'time' | 'custom';\n  /** Validation operator */\n  operator?: 'between' | 'notBetween' | 'equal' | 'notEqual' | 'greaterThan' | 'lessThan' | 'greaterThanOrEqual' | 'lessThanOrEqual';\n  /** Validation formula or values */\n  formula1?: string | number | Date;\n  /** Second validation formula or value (for between/notBetween) */\n  formula2?: string | number | Date;\n  /** Whether to show error message */\n  showErrorMessage?: boolean;\n  /** Error message text */\n  errorMessage?: string;\n  /** Whether to show input message */\n  showInputMessage?: boolean;\n  /** Input message text */\n  inputMessage?: string;\n  /** Whether to allow blank values */\n  allowBlank?: boolean;\n}\n\n/**\n * Workbook metadata interface\n */\nexport interface IWorkbookMetadata {\n  /** Workbook author */\n  author?: string;\n  /** Workbook title */\n  title?: string;\n  /** Workbook subject */\n  subject?: string;\n  /** Workbook keywords */\n  keywords?: string;\n  /** Workbook category */\n  category?: string;\n  /** Workbook description */\n  description?: string;\n  /** Workbook company */\n  company?: string;\n  /** Workbook manager */\n  manager?: string;\n  /** Creation date */\n  created?: Date;\n  /** Last modified date */\n  modified?: Date;\n  /** Application name */\n  application?: string;\n  /** Application version */\n  appVersion?: string;\n  /** Hyperlink base */\n  hyperlinkBase?: string;\n}\n\n/**\n * Error types for validation\n */\nexport enum ErrorType {\n  VALIDATION_ERROR = 'VALIDATION_ERROR',\n  BUILD_ERROR = 'BUILD_ERROR',\n  STYLE_ERROR = 'STYLE_ERROR',\n  WORKSHEET_ERROR = 'WORKSHEET_ERROR',\n  CELL_ERROR = 'CELL_ERROR'\n}\n\n/**\n * Error interface\n */\nexport interface IError {\n  type: ErrorType;\n  message: string;\n  code?: string;\n  details?: Record<string, unknown>;\n  stack?: string;\n}\n\n/**\n * Success result interface\n */\nexport interface ISuccessResult<T = unknown> {\n  success: true;\n  data: T;\n  message?: string;\n}\n\n/**\n * Error result interface\n */\nexport interface IErrorResult {\n  success: false;\n  error: IError;\n}\n\n/**\n * Result union type\n */\nexport type Result<T = unknown> = ISuccessResult<T> | IErrorResult; ","import ExcelJS from 'exceljs';\nimport {\n  IWorksheet,\n  IWorksheetConfig,\n  ITable,\n  IWorksheetImage,\n  IExcelTable,\n  IPivotTable,\n  ISlicer,\n  IWatermark,\n  IDataConnection\n} from '../types/worksheet.types';\nimport {\n  IDataCell,\n  IHeaderCell,\n  IFooterCell,\n  ICellRange,\n  IRichTextRun\n} from '../types/cell.types';\nimport { IBuildOptions } from '../types/builder.types';\nimport { Result, ErrorType, CellType, IDataValidation } from '../types/core.types';\nimport { IConditionalFormat } from '../types/style.types';\n\n/**\n * Worksheet - Representa una hoja de cálculo dentro del builder\n *\n2 * Soporta headers, subheaders anidados, rows, footers, children y estilos por celda.\n */\nexport class Worksheet implements IWorksheet {\n  public config: IWorksheetConfig;\n  public tables: ITable[] = [];\n  public currentRow = 1;\n  public currentCol = 1;\n  public headerPointers: Map<string, any> = new Map();\n  public isBuilt = false;\n\n  // Estructuras temporales para la tabla actual\n  private headers: IHeaderCell[] = [];\n  private subHeaders: IHeaderCell[] = [];\n  private body: IDataCell[] = [];\n  private footers: IFooterCell[] = [];\n  \n  // Features adicionales\n  private images: IWorksheetImage[] = [];\n  private rowGroups: Array<{ start: number; end: number; collapsed?: boolean }> = [];\n  private columnGroups: Array<{ start: number; end: number; collapsed?: boolean }> = [];\n  private namedRanges: Array<{ name: string; range: string; scope?: string }> = [];\n  private excelTables: IExcelTable[] = [];\n  private hiddenRows: Set<number> = new Set();\n  private hiddenColumns: Set<number> = new Set();\n  private pivotTables: IPivotTable[] = [];\n  private slicers: ISlicer[] = [];\n  private watermarks: IWatermark[] = [];\n  private dataConnections: IDataConnection[] = [];\n  \n  // Estilos y tema del workbook (no se guardan en el objeto de ExcelJS)\n  private customStyles?: Record<string, import('../types/style.types').IStyle>;\n  private theme?: import('../types/builder.types').IWorkbookTheme;\n\n  constructor(config: IWorksheetConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Agrega un header principal\n   */\n  addHeader(header: IHeaderCell): this {\n    this.headers.push(header);\n    return this;\n  }\n\n  /**\n   * Agrega subheaders (ahora soporta anidación)\n   */\n  addSubHeaders(subHeaders: IHeaderCell[]): this {\n    this.subHeaders.push(...subHeaders);\n    return this;\n  }\n\n  /**\n   * Agrega una fila de datos (puede ser jerárquica con childrens)\n   */\n  addRow(row: IDataCell[] | IDataCell): this {\n    if (Array.isArray(row)) {\n      this.body.push(...row);\n    } else {\n      this.body.push(row);\n    }\n    return this;\n  }\n\n  /**\n   * Agrega un footer o varios\n   */\n  addFooter(footer: IFooterCell[] | IFooterCell): this {\n    if (Array.isArray(footer)) {\n      this.footers.push(...footer);\n    } else {\n      this.footers.push(footer);\n    }\n    return this;\n  }\n\n  /**\n   * Crea una nueva tabla y la agrega al worksheet\n   */\n  addTable(tableConfig: Partial<ITable> = {}): this {\n    const table: ITable = {\n      name: tableConfig.name || `Table_${this.tables.length + 1}`,\n      headers: tableConfig.headers || [],\n      subHeaders: tableConfig.subHeaders || [],\n      body: tableConfig.body || [],\n      footers: tableConfig.footers || [],\n      showBorders: tableConfig.showBorders !== false,\n      showStripes: tableConfig.showStripes !== false,\n      style: tableConfig.style || 'TableStyleLight1',\n      ...tableConfig\n    };\n    \n    this.tables.push(table);\n    return this;\n  }\n\n  /**\n   * Finaliza la tabla actual agregando todos los elementos temporales a la última tabla\n   */\n  finalizeTable(): this {\n    if (this.tables.length === 0) {\n      // Si no hay tablas, crear una nueva con los datos temporales\n      this.addTable();\n    }\n    \n    const currentTable = this.tables[this.tables.length - 1];\n    if (!currentTable) {\n      throw new Error('No se pudo obtener la tabla actual');\n    }\n    \n    // Agregar headers, subheaders, body y footers a la tabla actual\n    if (this.headers.length > 0) {\n      currentTable.headers = [...(currentTable.headers || []), ...this.headers];\n    }\n    \n    if (this.subHeaders.length > 0) {\n      currentTable.subHeaders = [...(currentTable.subHeaders || []), ...this.subHeaders];\n    }\n    \n    if (this.body.length > 0) {\n      currentTable.body = [...(currentTable.body || []), ...this.body];\n    }\n    \n    if (this.footers.length > 0) {\n      currentTable.footers = [...(currentTable.footers || []), ...this.footers];\n    }\n    \n    // Limpiar las estructuras temporales\n    this.headers = [];\n    this.subHeaders = [];\n    this.body = [];\n    this.footers = [];\n    \n    return this;\n  }\n\n  /**\n   * Obtiene una tabla por nombre\n   */\n  getTable(name: string): ITable | undefined {\n    return this.tables.find(table => table.name === name);\n  }\n\n  /**\n   * Agrega una imagen al worksheet\n   */\n  addImage(image: IWorksheetImage): this {\n    this.images.push(image);\n    return this;\n  }\n\n  /**\n   * Agrupa filas (crea esquema colapsable)\n   */\n  groupRows(startRow: number, endRow: number, collapsed: boolean = false): this {\n    this.rowGroups.push({ start: startRow, end: endRow, collapsed });\n    return this;\n  }\n\n  /**\n   * Agrupa columnas (crea esquema colapsable)\n   */\n  groupColumns(startCol: number, endCol: number, collapsed: boolean = false): this {\n    this.columnGroups.push({ start: startCol, end: endCol, collapsed });\n    return this;\n  }\n\n  /**\n   * Agrega un rango con nombre\n   */\n  addNamedRange(name: string, range: string | ICellRange, scope?: string): this {\n    let rangeString: string;\n    \n    if (typeof range === 'string') {\n      rangeString = range;\n    } else {\n      // Convertir ICellRange a string (e.g., \"A1:B10\")\n      const startRef = range.start.reference || `${this.numberToColumnLetter(range.start.col)}${range.start.row}`;\n      const endRef = range.end.reference || `${this.numberToColumnLetter(range.end.col)}${range.end.row}`;\n      rangeString = `${startRef}:${endRef}`;\n    }\n    \n    const namedRange: { name: string; range: string; scope?: string } = { name, range: rangeString };\n    if (scope !== undefined) {\n      namedRange.scope = scope;\n    }\n    this.namedRanges.push(namedRange);\n    return this;\n  }\n\n  /**\n   * Agrega una tabla estructurada de Excel\n   */\n  addExcelTable(table: IExcelTable): this {\n    this.excelTables.push(table);\n    return this;\n  }\n\n  /**\n   * Oculta filas\n   */\n  hideRows(rows: number | number[]): this {\n    const rowsArray = Array.isArray(rows) ? rows : [rows];\n    rowsArray.forEach(row => this.hiddenRows.add(row));\n    return this;\n  }\n\n  /**\n   * Muestra filas\n   */\n  showRows(rows: number | number[]): this {\n    const rowsArray = Array.isArray(rows) ? rows : [rows];\n    rowsArray.forEach(row => this.hiddenRows.delete(row));\n    return this;\n  }\n\n  /**\n   * Oculta columnas\n   */\n  hideColumns(columns: number | string | (number | string)[]): this {\n    const columnsArray = Array.isArray(columns) ? columns : [columns];\n    columnsArray.forEach(col => {\n      const colNum = typeof col === 'string' ? this.columnLetterToNumber(col) : col;\n      this.hiddenColumns.add(colNum);\n    });\n    return this;\n  }\n\n  /**\n   * Muestra columnas\n   */\n  showColumns(columns: number | string | (number | string)[]): this {\n    const columnsArray = Array.isArray(columns) ? columns : [columns];\n    columnsArray.forEach(col => {\n      const colNum = typeof col === 'string' ? this.columnLetterToNumber(col) : col;\n      this.hiddenColumns.delete(colNum);\n    });\n    return this;\n  }\n\n  /**\n   * Agrega una tabla dinámica (pivot table)\n   */\n  addPivotTable(pivotTable: IPivotTable): this {\n    this.pivotTables.push(pivotTable);\n    return this;\n  }\n\n  /**\n   * Agrega un slicer a una tabla o tabla dinámica\n   */\n  addSlicer(slicer: ISlicer): this {\n    this.slicers.push(slicer);\n    return this;\n  }\n\n  /**\n   * Agrega una marca de agua al worksheet\n   */\n  addWatermark(watermark: IWatermark): this {\n    this.watermarks.push(watermark);\n    return this;\n  }\n\n  /**\n   * Agrega una conexión de datos\n   */\n  addDataConnection(connection: IDataConnection): this {\n    this.dataConnections.push(connection);\n    return this;\n  }\n\n  /**\n   * Construye la hoja en el workbook de ExcelJS\n   */\n  async build(workbook: ExcelJS.Workbook, _options: IBuildOptions = {}): Promise<void> {\n    const ws = workbook.addWorksheet(this.config.name, {\n      properties: {\n        defaultRowHeight: this.config.defaultRowHeight || 20,\n        tabColor: this.config.tabColor as any\n      },\n      pageSetup: this.config.pageSetup as any\n    });\n\n    // Guardar estilos predefinidos y tema en la instancia de Worksheet (no en el objeto de ExcelJS)\n    this.customStyles = (workbook as any).__customStyles;\n    this.theme = (workbook as any).__theme;\n\n    let rowPointer = 1;\n    \n    // Si hay tablas definidas, construir cada tabla\n    if (this.tables.length > 0) {\n      let tableStartRow = rowPointer;\n      for (let i = 0; i < this.tables.length; i++) {\n        const table = this.tables[i];\n        if (table) {\n          tableStartRow = rowPointer;\n          rowPointer = await this.buildTable(ws, table, rowPointer, i > 0);\n          \n          // Aplicar filtro automático a la tabla si está configurado\n          if (table.autoFilter && rowPointer > tableStartRow) {\n            this.applyAutoFilter(ws, table, tableStartRow, rowPointer - 1);\n          }\n        }\n      }\n    } else {\n      // Construcción tradicional para compatibilidad hacia atrás\n      rowPointer = await this.buildLegacyContent(ws, rowPointer);\n    }\n    \n    // Aplicar filtro automático a nivel de worksheet si está configurado\n    if (this.config.autoFilter?.enabled) {\n      this.applyWorksheetAutoFilter(ws, rowPointer);\n    }\n    \n    // Aplicar views (freeze panes, split panes, sheet views)\n    this.applyViews(ws);\n    \n    // Aplicar protección si está configurada\n    if (this.config.protected) {\n      ws.protect(this.config.protectionPassword || '', {\n        selectLockedCells: false,\n        selectUnlockedCells: true,\n        formatCells: false,\n        formatColumns: false,\n        formatRows: false,\n        insertColumns: false,\n        insertRows: false,\n        insertHyperlinks: false,\n        deleteColumns: false,\n        deleteRows: false,\n        sort: false,\n        autoFilter: false,\n        pivotTables: false\n      });\n    }\n    \n    // Aplicar imágenes\n    for (const image of this.images) {\n      await this.applyImage(ws, image);\n    }\n    \n    // Aplicar agrupación de filas\n    for (const group of this.rowGroups) {\n      this.applyRowGrouping(ws, group.start, group.end, group.collapsed);\n    }\n    \n    // Aplicar agrupación de columnas\n    for (const group of this.columnGroups) {\n      this.applyColumnGrouping(ws, group.start, group.end, group.collapsed);\n    }\n    \n    // Aplicar rangos con nombre\n    for (const namedRange of this.namedRanges) {\n      // ExcelJS addDefinedName - solo acepta name y range (scope se maneja de otra manera)\n      workbook.definedNames.add(namedRange.name, namedRange.range);\n    }\n    \n    // Aplicar tablas estructuradas de Excel\n    for (const excelTable of this.excelTables) {\n      this.applyExcelTable(ws, excelTable);\n    }\n    \n    // Aplicar configuración de impresión avanzada\n    this.applyAdvancedPrintSettings(ws);\n    \n    // Aplicar filas y columnas ocultas\n    this.applyHiddenRowsColumns(ws);\n    \n    // Aplicar tablas dinámicas\n    for (const pivotTable of this.pivotTables) {\n      await this.applyPivotTable(ws, pivotTable);\n    }\n    \n    // Aplicar slicers\n    for (const slicer of this.slicers) {\n      await this.applySlicer(ws, slicer);\n    }\n    \n    // Aplicar marcas de agua\n    for (const watermark of this.watermarks) {\n      await this.applyWatermark(ws, watermark);\n    }\n    \n    // Aplicar conexiones de datos\n    for (const connection of this.dataConnections) {\n      await this.applyDataConnection(workbook, connection);\n    }\n    \n    this.isBuilt = true;\n  }\n\n  /**\n   * Construye una tabla individual en el worksheet\n   */\n  private async buildTable(ws: ExcelJS.Worksheet, table: ITable, startRow: number, addSpacing: boolean = false): Promise<number> {\n    let rowPointer = startRow;\n    \n    // Agregar espacio entre tablas si no es la primera\n    if (addSpacing) {\n      rowPointer += 2; // 2 filas de espacio\n    }\n    \n    // Headers principales de la tabla\n    if (table.headers && table.headers.length > 0) {\n      for (const header of table.headers) {\n        const cell = ws.getRow(rowPointer).getCell(1);\n        \n        // Aplicar rich text si existe\n        if ((header as any).richText && (header as any).richText.length > 0) {\n          cell.value = {\n            richText: (header as any).richText.map((run: IRichTextRun) => ({\n              text: run.text,\n              font: run.font ? { name: run.font } : undefined,\n              size: run.size,\n                  color: run.color ? this.convertColorToExcelJS(run.color) : undefined,\n              bold: run.bold,\n              italic: run.italic,\n              underline: run.underline,\n              strike: run.strikethrough\n            })).filter((run: any) => run.text !== undefined)\n          } as any;\n        } else {\n          cell.value = this.processCellValue(header);\n        }\n        \n        if (header.mergeCell) {\n          const maxCols = this.calculateTableMaxColumns(table);\n          ws.mergeCells(rowPointer, 1, rowPointer, maxCols);\n        }\n        if (header.styles) {\n          ws.getRow(rowPointer).eachCell((cell: any) => {\n            cell.style = this.convertStyle(header.styles);\n          });\n        }\n        \n        // Aplicar protección de celda si existe\n        if ((header as any).cellProtection) {\n          cell.protection = {\n            locked: (header as any).cellProtection.locked ?? true,\n            hidden: (header as any).cellProtection.hidden ?? false\n          };\n        } else if (header.protected !== undefined) {\n          cell.protection = {\n            locked: header.protected,\n            hidden: false\n          };\n        }\n        \n        // Aplicar dimensiones de celda\n        this.applyCellDimensions(ws, rowPointer, 1, header);\n        // Aplicar comentario si existe\n        if (header.comment) {\n          this.applyCellComment(ws, rowPointer, 1, header.comment);\n        }\n        // Aplicar validación de datos si existe\n        if (header.validation) {\n          this.applyDataValidation(ws, rowPointer, 1, header.validation);\n        }\n        // Aplicar formato condicional si existe\n        if (header.styles?.conditionalFormats) {\n          this.applyConditionalFormatting(ws, rowPointer, 1, header.styles.conditionalFormats);\n        }\n        rowPointer++;\n      }\n    }\n    \n    // SubHeaders con soporte para anidación\n    if (table.subHeaders && table.subHeaders.length > 0) {\n      rowPointer = this.buildNestedHeaders(ws, rowPointer, table.subHeaders);\n    }\n    \n    // Body (soporta children)\n    if (table.body && table.body.length > 0) {\n      for (const row of table.body) {\n        rowPointer = this.addDataRowRecursive(ws, rowPointer, row);\n      }\n    }\n    \n    // Footers\n    if (table.footers && table.footers.length > 0) {\n      for (const footer of table.footers) {\n        rowPointer = this.addFooterRow(ws, rowPointer, footer);\n      }\n    }\n    \n    // Aplicar estilo de tabla si está configurado\n    if (table.showBorders || table.showStripes) {\n      this.applyTableStyle(ws, table, startRow, rowPointer - 1);\n    }\n    \n    // Nota: El filtro automático se aplica en el método build() después de construir todas las tablas\n    // para tener el rowPointer final correcto\n    \n    return rowPointer;\n  }\n\n  /**\n   * Construcción tradicional para compatibilidad hacia atrás\n   */\n  private async buildLegacyContent(ws: ExcelJS.Worksheet, startRow: number): Promise<number> {\n    let rowPointer = startRow;\n    \n    // Headers principales\n    if (this.headers.length > 0) {\n      this.headers.forEach(header => {\n        ws.addRow([this.processCellValue(header)]);\n        if (header.mergeCell) {\n          ws.mergeCells(rowPointer, 1, rowPointer, (this.getMaxColumns() || 1));\n        }\n        if (header.styles) {\n          ws.getRow(rowPointer).eachCell((cell: any) => {\n            cell.style = this.convertStyle(header.styles);\n          });\n        }\n        // Aplicar dimensiones de celda\n        this.applyCellDimensions(ws, rowPointer, 1, header);\n        // Aplicar comentario si existe\n        if (header.comment) {\n          this.applyCellComment(ws, rowPointer, 1, header.comment);\n        }\n        // Aplicar validación de datos si existe\n        if (header.validation) {\n          this.applyDataValidation(ws, rowPointer, 1, header.validation);\n        }\n        // Aplicar formato condicional si existe\n        if (header.styles?.conditionalFormats) {\n          this.applyConditionalFormatting(ws, rowPointer, 1, header.styles.conditionalFormats);\n        }\n        rowPointer++;\n      });\n    }\n    \n    // SubHeaders con soporte para anidación\n    if (this.subHeaders.length > 0) {\n      rowPointer = this.buildNestedHeaders(ws, rowPointer, this.subHeaders);\n    }\n    \n    // Body (soporta children)\n    for (const row of this.body) {\n      rowPointer = this.addDataRowRecursive(ws, rowPointer, row);\n    }\n    \n    // Footers\n    if (this.footers.length > 0) {\n      for (const footer of this.footers) {\n        rowPointer = this.addFooterRow(ws, rowPointer, footer);\n      }\n    }\n    \n    return rowPointer;\n  }\n\n  /**\n   * Calcula el número máximo de columnas para una tabla\n   */\n  private calculateTableMaxColumns(table: ITable): number {\n    let maxCols = 0;\n    \n    if (table.subHeaders && table.subHeaders.length > 0) {\n      for (const header of table.subHeaders) {\n        maxCols += this.calculateHeaderColSpan(header);\n      }\n    }\n    \n    return maxCols || 1;\n  }\n\n  /**\n   * Aplica el estilo de tabla a un rango específico\n   */\n  private applyTableStyle(ws: ExcelJS.Worksheet, table: ITable, startRow: number, endRow: number): void {\n    const maxCols = this.calculateTableMaxColumns(table);\n    \n    // Aplicar bordes si está configurado\n    if (table.showBorders) {\n      for (let row = startRow; row <= endRow; row++) {\n        for (let col = 1; col <= maxCols; col++) {\n          const cell = ws.getRow(row).getCell(col);\n          if (!cell.style) cell.style = {};\n          if (!cell.style.border) {\n            cell.style.border = {\n              top: { style: 'thin', color: { argb: 'FF8EAADB' } },\n              left: { style: 'thin', color: { argb: 'FF8EAADB' } },\n              bottom: { style: 'thin', color: { argb: 'FF8EAADB' } },\n              right: { style: 'thin', color: { argb: 'FF8EAADB' } }\n            };\n          }\n        }\n      }\n    }\n    \n    // Aplicar rayas alternadas si está configurado\n    if (table.showStripes) {\n      for (let row = startRow; row <= endRow; row++) {\n        if ((row - startRow) % 2 === 1) { // Filas impares (empezando desde 0)\n          for (let col = 1; col <= maxCols; col++) {\n            const cell = ws.getRow(row).getCell(col);\n            if (!cell.style) cell.style = {};\n            if (!cell.style.fill) {\n              cell.style.fill = {\n                type: 'pattern',\n                pattern: 'solid',\n                fgColor: { argb: 'FFF2F2F2' }\n              };\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Construye headers anidados recursivamente\n   * @param ws - Worksheet de ExcelJS\n   * @param startRow - Fila inicial\n   * @param headers - Array de headers a procesar\n   * @returns La siguiente fila disponible\n   */\n    private buildNestedHeaders(ws: ExcelJS.Worksheet, startRow: number, headers: IHeaderCell[]): number {\n    let currentRow = startRow;\n    const maxDepth = this.getMaxHeaderDepth(headers);\n    \n    // Crear filas para cada nivel de profundidad\n    for (let depth = 0; depth < maxDepth; depth++) {\n      // Crear la fila primero\n      const row = ws.getRow(currentRow);\n      \n      // Procesar cada header en este nivel\n      let colIndex = 1;\n      for (const header of headers) {\n        if (depth === 0) {\n          // Nivel principal del header\n          const headerInfo = this.getHeaderAtDepth(header, depth, colIndex);\n          const cell = row.getCell(colIndex);\n          cell.value = this.processCellValue(header);\n          if (headerInfo.style) {\n            cell.style = this.convertStyle(headerInfo.style);\n          }\n          // Aplicar dimensiones de celda\n          this.applyCellDimensions(ws, currentRow, colIndex, header);\n          // Aplicar comentario si existe\n          if (header.comment) {\n            this.applyCellComment(ws, currentRow, colIndex, header.comment);\n          }\n          // Aplicar validación de datos si existe\n          if (header.validation) {\n            this.applyDataValidation(ws, currentRow, colIndex, header.validation);\n          }\n          // Aplicar formato condicional si existe\n          if (header.styles?.conditionalFormats) {\n            this.applyConditionalFormatting(ws, currentRow, colIndex, header.styles.conditionalFormats);\n          }\n          colIndex += headerInfo.colSpan;\n        } else {\n          // Nivel de children - procesar todos los children directos\n          if (header.children && header.children.length > 0) {\n            for (const child of header.children) {\n              const cell = row.getCell(colIndex);\n              cell.value = this.processCellValue(child);\n              if (child.styles || header.styles) {\n                cell.style = this.convertStyle(child.styles || header.styles);\n              }\n              // Aplicar dimensiones de celda para children\n              this.applyCellDimensions(ws, currentRow, colIndex, child);\n              // Aplicar comentario si existe\n              if (child.comment) {\n                this.applyCellComment(ws, currentRow, colIndex, child.comment);\n              }\n              // Aplicar validación de datos si existe\n              if (child.validation) {\n                this.applyDataValidation(ws, currentRow, colIndex, child.validation);\n              }\n              // Aplicar formato condicional si existe\n              if (child.styles?.conditionalFormats) {\n                this.applyConditionalFormatting(ws, currentRow, colIndex, child.styles.conditionalFormats);\n              }\n              colIndex += this.calculateHeaderColSpan(child);\n            }\n          } else {\n            // Si no tiene children, agregar celda vacía\n            const cell = row.getCell(colIndex);\n            cell.value = null;\n            colIndex += 1;\n          }\n        }\n      }\n      \n      currentRow++;\n    }\n    \n    // Aplicar todos los merges después de crear todas las filas\n    this.applyAllMerges(ws, startRow, currentRow - 1, headers);\n    \n    return currentRow;\n  }\n\n  /**\n   * Obtiene información del header en una profundidad específica\n   */\n  private getHeaderAtDepth(header: IHeaderCell, depth: number, startCol: number): {\n    value: string | null;\n    style: any;\n    colSpan: number;\n    mergeRange?: { start: number; end: number } | null;\n  } {\n    const colSpan = this.calculateHeaderColSpan(header);\n    if (depth === 0) {\n      // Nivel principal del header\n      const mergeRange = colSpan > 1 ? { start: startCol, end: startCol + colSpan - 1 } : null;\n      return {\n        value: typeof header.value === 'string' ? header.value : String(header.value || ''),\n        style: header.styles,\n        colSpan,\n        mergeRange: mergeRange\n      };\n    } else if (header.children && header.children.length > 0) {\n      // Nivel de children\n      const child = header.children[depth];\n      if (child) {\n        const childColSpan = this.calculateHeaderColSpan(child);\n        // Los children también pueden hacer merge si tienen múltiples childrens\n        const mergeRange = childColSpan > 1 ? { start: startCol, end: startCol + childColSpan - 1 } : null;\n        \n        return {\n          value: typeof child.value === 'string' ? child.value : String(child.value || ''),\n          style: child.styles || header.styles,\n          colSpan: childColSpan,\n          mergeRange: mergeRange\n        };\n      }\n    }\n    \n    // Celda vacía para mantener alineación\n    return {\n      value: null,\n      style: null,\n      colSpan: 1\n    };\n  }\n\n\n\n\n  /**\n   * Aplica todos los merges (horizontales y verticales) después de crear todas las filas\n   */\n  private applyAllMerges(ws: ExcelJS.Worksheet, startRow: number, endRow: number, headers: IHeaderCell[]): void {\n    const maxDepth = this.getMaxHeaderDepth(headers);\n    \n    // Solo aplicar merges si hay más de una fila de headers\n    if (maxDepth <= 1) return;\n    \n    // Aplicar merges inteligentes basados en la estructura\n    this.applySmartMerges(ws, startRow, endRow, headers);\n  }\n\n  /**\n   * Aplica merges inteligentes basados en la estructura de headers\n   */\n  private applySmartMerges(ws: ExcelJS.Worksheet, startRow: number, endRow: number, headers: IHeaderCell[]): void {\n    const maxDepth = this.getMaxHeaderDepth(headers);\n    \n    // Solo aplicar merges si hay más de una fila de headers\n    if (maxDepth <= 1) return;\n    \n    // Aplicar merges para cada header\n    let colIndex = 1;\n    for (const header of headers) {\n      this.applySmartMergesForHeader(ws, startRow, endRow, header, colIndex);\n      colIndex += this.calculateHeaderColSpan(header);\n    }\n  }\n\n  /**\n   * Aplica merges inteligentes para un header específico\n   */\n  private applySmartMergesForHeader(ws: ExcelJS.Worksheet, startRow: number, endRow: number, header: IHeaderCell, startCol: number): void {\n    const headerColSpan = this.calculateHeaderColSpan(header);\n    \n    if (!header.children || header.children.length === 0) {\n      // Si no tiene children, hacer merge vertical desde la primera fila hasta la última\n      ws.mergeCells(startRow, startCol, endRow, startCol + headerColSpan - 1);\n    } else {\n      // Si tiene children, aplicar merge horizontal en la primera fila\n      if (headerColSpan > 1) {\n        ws.mergeCells(startRow, startCol, startRow, startCol + headerColSpan - 1);\n      }\n      \n      // Procesar children recursivamente\n      let childColIndex = startCol;\n      for (const child of header.children) {\n        this.applySmartMergesForHeader(ws, startRow + 1, endRow, child, childColIndex);\n        childColIndex += this.calculateHeaderColSpan(child);\n      }\n    }\n  }\n\n\n \n  /**\n   * Calcula el span de columnas para un header\n   */\n  private calculateHeaderColSpan(header: IHeaderCell): number {\n    if (!header.children || header.children.length === 0) {\n      return 1;\n    }\n    \n    return header.children.reduce((total, child) => {\n      return total + this.calculateHeaderColSpan(child);\n    }, 0);\n  }\n\n  /**\n   * Obtiene la profundidad máxima de headers anidados\n   */\n  private getMaxHeaderDepth(headers: IHeaderCell[]): number {\n    let maxDepth = 1;\n    \n    for (const header of headers) {\n      if (header.children && header.children.length > 0) {\n        const childDepth = this.getMaxHeaderDepth(header.children);\n        maxDepth = Math.max(maxDepth, childDepth + 1);\n      }\n    }\n    \n    return maxDepth;\n  }\n\n  /**\n   * Obtiene el número máximo de columnas\n   */\n  private getMaxColumns(): number {\n    let maxCols = 0;\n    \n    for (const header of this.subHeaders) {\n      maxCols += this.calculateHeaderColSpan(header);\n    }\n    \n    return maxCols;\n  }\n\n  /**\n   * Valida la hoja\n   */\n  validate(): Result<boolean> {\n    if (!this.headers.length && !this.body.length) {\n      return {\n        success: false,\n        error: {\n          type: ErrorType.VALIDATION_ERROR,\n          message: 'La hoja no tiene datos',\n        }\n      };\n    }\n    return { success: true, data: true };\n  }\n\n  /**\n   * Calcula las posiciones de columnas para los datos basándose en la estructura de subheaders\n   */\n  private calculateDataColumnPositions(): { [key: string]: number } {\n    const positions: { [key: string]: number } = {};\n    let currentCol = 1;\n    \n    for (const header of this.subHeaders) {\n      if (header.children && header.children.length > 0) {\n        // Si el header tiene children, cada child ocupa una columna\n        for (const child of header.children) {\n          if (child.key) {\n            positions[child.key] = currentCol;\n          }\n          if (child.value) {\n            positions[String(child.value)] = currentCol;\n          }\n          currentCol++;\n        }\n      } else {\n        // Si el header no tiene children, ocupa una columna\n        if (header.key) {\n          positions[header.key] = currentCol;\n        }\n        if (header.value) {\n          positions[String(header.value)] = currentCol;\n        }\n        currentCol++;\n      }\n    }\n    \n    return positions;\n  }\n\n  /**\n   * Agrega una fila de footer\n   * @returns el siguiente rowPointer disponible\n   */\n  private addFooterRow(ws: ExcelJS.Worksheet, rowPointer: number, footer: IFooterCell): number {\n    // Calcular las columnas basándose en la estructura de subheaders\n    const columnPositions = this.calculateDataColumnPositions();\n    \n    // Buscar la columna correcta para el footer\n    let footerColPosition: number | undefined;\n    \n    // Intentar encontrar por key primero\n    if (footer.key && columnPositions[footer.key]) {\n      footerColPosition = columnPositions[footer.key];\n    }\n    // Si no se encuentra por key, intentar por header\n    else if (footer.header && columnPositions[footer.header]) {\n      footerColPosition = columnPositions[footer.header];\n    }\n    \n    // Si no se encuentra la posición, usar columna 1 por defecto\n    if (footerColPosition === undefined) {\n      footerColPosition = 1;\n    }\n    \n    // Escribir el footer en la columna correcta\n    const excelRow = ws.getRow(rowPointer);\n    const footerCell = excelRow.getCell(footerColPosition);\n    footerCell.value = this.processCellValue(footer);\n    // Aplicar estilo: primero explícito, luego styleName, luego tema\n    if (footer.styles) {\n      footerCell.style = this.convertStyle(footer.styles);\n    } else if (footer.styleName) {\n      const style = this.getPredefinedStyle(footer.styleName);\n      if (style) {\n        footerCell.style = this.convertStyle(style);\n      }\n    } else {\n      // Aplicar estilo del tema si está disponible y auto-apply está habilitado\n      const themeStyle = this.getThemeStyle('footer');\n      if (themeStyle) {\n        footerCell.style = this.convertStyle(themeStyle);\n      }\n    }\n    if (footer.numberFormat) {\n      footerCell.numFmt = footer.numberFormat;\n    }\n    \n    // Aplicar dimensiones de celda\n    this.applyCellDimensions(ws, rowPointer, footerColPosition, footer);\n    // Aplicar comentario si existe\n    if (footer.comment) {\n      this.applyCellComment(ws, rowPointer, footerColPosition, footer.comment);\n    }\n    // Aplicar validación de datos si existe\n    if (footer.validation) {\n      this.applyDataValidation(ws, rowPointer, footerColPosition, footer.validation);\n    }\n    // Aplicar formato condicional si existe\n    if (footer.styles?.conditionalFormats) {\n      this.applyConditionalFormatting(ws, rowPointer, footerColPosition, footer.styles.conditionalFormats);\n    }\n    \n    // Aplicar merge si está configurado\n    if (footer.mergeCell && footer.mergeTo) {\n      ws.mergeCells(rowPointer, footerColPosition, rowPointer, footer.mergeTo);\n    }\n    \n    // Si hay children, escribirlos en las columnas correspondientes\n    if (footer.children && footer.children.length > 0) {\n      for (const child of footer.children) {\n        if (child) {\n          // Buscar la columna correcta basándose en el header del child\n          let colPosition: number | undefined;\n          \n          // Intentar encontrar por key primero\n          if (child.key && columnPositions[child.key]) {\n            colPosition = columnPositions[child.key];\n          }\n          // Si no se encuentra por key, intentar por header\n          else if (child.header && columnPositions[child.header]) {\n            colPosition = columnPositions[child.header];\n          }\n          \n          if (colPosition !== undefined) {\n            const childCell = excelRow.getCell(colPosition);\n            childCell.value = this.processCellValue(child);\n            if (child.styles) {\n              childCell.style = this.convertStyle(child.styles);\n            }\n            if (child.numberFormat) {\n              childCell.numFmt = child.numberFormat;\n            }\n            \n            // Aplicar dimensiones de celda para children\n            this.applyCellDimensions(ws, rowPointer, colPosition, child);\n            // Aplicar comentario si existe\n            if (child.comment) {\n              this.applyCellComment(ws, rowPointer, colPosition, child.comment);\n            }\n            // Aplicar validación de datos si existe\n            if (child.validation) {\n              this.applyDataValidation(ws, rowPointer, colPosition, child.validation);\n            }\n            // Aplicar formato condicional si existe\n            if (child.styles?.conditionalFormats) {\n              this.applyConditionalFormatting(ws, rowPointer, colPosition, child.styles.conditionalFormats);\n            }\n          }\n        }\n      }\n    }\n    \n    // Incrementar rowPointer solo si el footer tiene la propiedad jump\n    if (footer.jump) {\n      return rowPointer + 1;\n    }\n    \n    return rowPointer;\n  }\n\n  /**\n   * Aplica width y height a una celda/fila\n   */\n  private applyCellDimensions(ws: ExcelJS.Worksheet, row: number, col: number, cell: IDataCell | IHeaderCell | IFooterCell): void {\n    // Aplicar rowHeight si está definido\n    if (cell.rowHeight !== undefined) {\n      const excelRow = ws.getRow(row);\n      excelRow.height = cell.rowHeight;\n    }\n    \n    // Aplicar colWidth si está definido\n    if (cell.colWidth !== undefined) {\n      const excelCol = ws.getColumn(col);\n      excelCol.width = cell.colWidth;\n    }\n  }\n\n  /**\n   * Aplica comentario a una celda\n   */\n  private applyCellComment(ws: ExcelJS.Worksheet, row: number, col: number, comment: string): void {\n    if (!comment || comment.trim() === '') {\n      return;\n    }\n\n    const cell = ws.getRow(row).getCell(col);\n    \n    // ExcelJS usa 'note' para comentarios\n    // Puede ser string o objeto con más propiedades\n    if (typeof comment === 'string') {\n      cell.note = comment;\n    }\n  }\n\n  /**\n   * Aplica validación de datos a una celda\n   */\n  private applyDataValidation(ws: ExcelJS.Worksheet, row: number, col: number, validation: IDataValidation): void {\n    if (!validation) {\n      return;\n    }\n\n    const cell = ws.getRow(row).getCell(col);\n    \n    // ExcelJS usa dataValidation para validaciones\n    // Nota: ExcelJS no soporta 'time' como tipo, se convierte a 'date'\n    const validationType = validation.type === 'time' ? 'date' : validation.type;\n    \n    const dataValidation: ExcelJS.DataValidation = {\n      type: validationType as 'list' | 'whole' | 'decimal' | 'textLength' | 'date' | 'custom',\n      allowBlank: validation.allowBlank ?? true,\n      formulae: [] // Inicializar como array vacío, se llenará si hay fórmulas\n    };\n\n    // Agregar operador si existe\n    if (validation.operator) {\n      dataValidation.operator = validation.operator;\n    }\n\n    // Agregar fórmulas/valores\n    if (validation.formula1 !== undefined) {\n      if (typeof validation.formula1 === 'string') {\n        dataValidation.formulae = [validation.formula1];\n      } else if (validation.formula1 instanceof Date) {\n        dataValidation.formulae = [validation.formula1.toISOString()];\n      } else {\n        dataValidation.formulae = [validation.formula1];\n      }\n    }\n\n    if (validation.formula2 !== undefined) {\n      if (!dataValidation.formulae) {\n        dataValidation.formulae = [];\n      }\n      if (typeof validation.formula2 === 'string') {\n        dataValidation.formulae.push(validation.formula2);\n      } else if (validation.formula2 instanceof Date) {\n        dataValidation.formulae.push(validation.formula2.toISOString());\n      } else {\n        dataValidation.formulae.push(validation.formula2);\n      }\n    }\n\n    // Agregar mensajes de error e input\n    if (validation.showErrorMessage) {\n      dataValidation.showErrorMessage = true;\n      if (validation.errorMessage) {\n        dataValidation.error = validation.errorMessage;\n      }\n    }\n\n    if (validation.showInputMessage) {\n      dataValidation.showInputMessage = true;\n      if (validation.inputMessage) {\n        dataValidation.prompt = validation.inputMessage;\n      }\n    }\n\n    cell.dataValidation = dataValidation;\n  }\n\n  /**\n   * Aplica formato condicional a una celda\n   */\n  private applyConditionalFormatting(ws: ExcelJS.Worksheet, row: number, col: number, conditionalFormats?: IConditionalFormat[]): void {\n    if (!conditionalFormats || conditionalFormats.length === 0) {\n      return;\n    }\n\n    const cell = ws.getRow(row).getCell(col);\n    const cellAddress = cell.address;\n    \n    // ExcelJS usa addConditionalFormatting para agregar formato condicional\n    conditionalFormats.forEach((format, index) => {\n      const rule: any = {\n        type: format.type,\n        priority: format.priority ?? (index + 1),\n        stopIfTrue: format.stopIfTrue ?? false\n      };\n\n      // Agregar operador si existe\n      if (format.operator) {\n        rule.operator = format.operator;\n      }\n\n      // Agregar fórmulas/valores\n      if (format.formula) {\n        rule.formulae = [format.formula];\n      } else if (format.values && format.values.length > 0) {\n        rule.formulae = format.values.map(v => {\n          if (typeof v === 'string') {\n            return v;\n          } else if (v instanceof Date) {\n            return v.toISOString();\n          } else {\n            return String(v);\n          }\n        });\n      }\n\n      // Convertir el estilo si existe y aplicarlo a la regla\n      if (format.style) {\n        const style = this.convertStyle(format.style);\n        // ExcelJS aplica el estilo directamente en la regla\n        rule.style = style;\n      }\n\n      // Agregar la regla de formato condicional usando addConditionalFormatting\n      ws.addConditionalFormatting({\n        ref: cellAddress,\n        rules: [rule]\n      });\n    });\n  }\n\n  /**\n   * Aplica filtro automático a una tabla\n   */\n  private applyAutoFilter(ws: ExcelJS.Worksheet, table: ITable, startRow: number, endRow: number): void {\n    if (!table.autoFilter) {\n      return;\n    }\n\n    // Calcular el rango de columnas\n    const maxCols = this.calculateTableMaxColumns(table);\n    \n    // Aplicar filtro automático al rango de la tabla\n    // El filtro se aplica desde la fila de headers hasta la última fila de datos\n    const headerRow = startRow;\n    const dataEndRow = endRow;\n    \n    if (maxCols > 0 && dataEndRow >= headerRow) {\n      ws.autoFilter = {\n        from: {\n          row: headerRow,\n          column: 1\n        },\n        to: {\n          row: dataEndRow,\n          column: maxCols\n        }\n      };\n    }\n  }\n\n  /**\n   * Aplica filtro automático a nivel de worksheet\n   */\n  private applyWorksheetAutoFilter(ws: ExcelJS.Worksheet, lastRow: number): void {\n    const autoFilterConfig = this.config.autoFilter;\n    if (!autoFilterConfig || !autoFilterConfig.enabled) {\n      return;\n    }\n\n    // Si hay un rango específico, usarlo\n    if (autoFilterConfig.range) {\n      ws.autoFilter = {\n        from: {\n          row: autoFilterConfig.range.start?.row || 1,\n          column: autoFilterConfig.range.start?.col || 1\n        },\n        to: {\n          row: autoFilterConfig.range.end?.row || lastRow,\n          column: autoFilterConfig.range.end?.col || ws.columnCount || 1\n        }\n      };\n      return;\n    }\n\n    // Si hay configuración de filas/columnas específicas\n    if (autoFilterConfig.startRow !== undefined || autoFilterConfig.endRow !== undefined ||\n        autoFilterConfig.startColumn !== undefined || autoFilterConfig.endColumn !== undefined) {\n      ws.autoFilter = {\n        from: {\n          row: autoFilterConfig.startRow || 1,\n          column: autoFilterConfig.startColumn || 1\n        },\n        to: {\n          row: autoFilterConfig.endRow || lastRow,\n          column: autoFilterConfig.endColumn || ws.columnCount || 1\n        }\n      };\n      return;\n    }\n\n    // Por defecto, aplicar a todo el contenido (desde la primera fila hasta la última)\n    // Excluyendo headers si existen\n    const startRow = this.headers.length > 0 ? this.headers.length + (this.subHeaders.length > 0 ? this.getMaxHeaderDepth(this.subHeaders) : 0) : 1;\n    const maxCols = this.getMaxColumns() || ws.columnCount || 1;\n    \n    if (lastRow >= startRow && maxCols > 0) {\n      ws.autoFilter = {\n        from: {\n          row: startRow,\n          column: 1\n        },\n        to: {\n          row: lastRow,\n          column: maxCols\n        }\n      };\n    }\n  }\n\n  /**\n   * Procesa el valor de una celda considerando links y máscaras\n   * Si el tipo es LINK o hay un link, crea un hipervínculo en Excel\n   */\n  private processCellValue(cell: IDataCell | IHeaderCell | IFooterCell): ExcelJS.CellValue {\n    // Si hay un link o el tipo es LINK, crear hipervínculo\n    if (cell.link || cell.type === CellType.LINK) {\n      const linkUrl = cell.link || (typeof cell.value === 'string' ? cell.value : '');\n      \n      // Si no hay URL válida, retornar el valor normal\n      if (!linkUrl || linkUrl.trim() === '') {\n        return cell.value;\n      }\n      \n      // Determinar el texto visible: usar máscara si existe, sino usar value, sino usar la URL\n      const displayText = cell.mask || cell.value || linkUrl;\n      \n      // Crear objeto de hipervínculo para ExcelJS\n      return {\n        text: String(displayText),\n        hyperlink: linkUrl\n      } as any;\n    }\n    \n    // Si no hay link, retornar el valor normal\n    return cell.value;\n  }\n\n  /**\n   * Agrega una fila de datos y sus children recursivamente\n   * @returns el siguiente rowPointer disponible\n   */\n  private addDataRowRecursive(ws: ExcelJS.Worksheet, rowPointer: number, row: IDataCell): number {\n    // Calcular las columnas basándose en la estructura de subheaders\n    const columnPositions = this.calculateDataColumnPositions();\n\n    // Buscar la columna correcta para el dato principal\n    let mainColPosition: number | undefined;\n    \n    // Intentar encontrar por key primero\n    if (row.key && columnPositions[row.key]) {\n      mainColPosition = columnPositions[row.key];\n    }\n    // Si no se encuentra por key, intentar por header\n    else if (row.header && columnPositions[row.header]) {\n      mainColPosition = columnPositions[row.header];\n    }\n    \n    // Si no se encuentra la posición, usar columna 1 por defecto\n    if (mainColPosition === undefined) {\n      mainColPosition = 1;\n    }\n    \n    // Escribir el dato principal en la columna correcta\n    const excelRow = ws.getRow(rowPointer);\n    const mainCell = excelRow.getCell(mainColPosition);\n    \n    // Aplicar rich text si existe\n    if ((row as any).richText && (row as any).richText.length > 0) {\n      mainCell.value = {\n            richText: (row as any).richText.map((run: IRichTextRun) => ({\n          text: run.text,\n          font: run.font ? { name: run.font } : undefined,\n          size: run.size,\n                  color: run.color ? this.convertColorToExcelJS(run.color) : undefined,\n          bold: run.bold,\n          italic: run.italic,\n          underline: run.underline,\n          strike: run.strikethrough\n        })).filter((run: any) => run.text !== undefined)\n      } as any;\n    } else {\n      mainCell.value = this.processCellValue(row);\n    }\n    \n    // Aplicar estilo: primero explícito, luego styleName, luego tema\n    if (row.styles) {\n      mainCell.style = this.convertStyle(row.styles);\n    } else if (row.styleName) {\n      const style = this.getPredefinedStyle(row.styleName);\n      if (style) {\n        mainCell.style = this.convertStyle(style);\n      }\n    } else {\n      // Aplicar estilo del tema si está disponible y auto-apply está habilitado\n      // Usar el número de fila actual como índice para alternar\n      const themeStyle = this.getThemeStyle('body', rowPointer);\n      if (themeStyle) {\n        mainCell.style = this.convertStyle(themeStyle);\n      }\n    }\n    if (row.numberFormat) {\n      mainCell.numFmt = row.numberFormat;\n    }\n    \n    // Aplicar protección de celda si existe\n    if ((row as any).cellProtection) {\n      mainCell.protection = {\n        locked: (row as any).cellProtection.locked ?? true,\n        hidden: (row as any).cellProtection.hidden ?? false\n      };\n    } else if (row.protected !== undefined) {\n      // Soporte legacy\n      mainCell.protection = {\n        locked: row.protected,\n        hidden: false\n      };\n    }\n    \n    // Aplicar dimensiones de celda\n    this.applyCellDimensions(ws, rowPointer, mainColPosition, row);\n    // Aplicar comentario si existe\n    if (row.comment) {\n      this.applyCellComment(ws, rowPointer, mainColPosition, row.comment);\n    }\n    // Aplicar validación de datos si existe\n    if (row.validation) {\n      this.applyDataValidation(ws, rowPointer, mainColPosition, row.validation);\n    }\n    // Aplicar formato condicional si existe\n    if (row.styles?.conditionalFormats) {\n      this.applyConditionalFormatting(ws, rowPointer, mainColPosition, row.styles.conditionalFormats);\n    }\n    \n    // Si hay children, escribirlos en las columnas correspondientes\n    if (row.children && row.children.length > 0) {\n      for (const child of row.children) {\n        if (child) {\n          // Buscar la columna correcta basándose en el header del child\n          let colPosition: number | undefined;\n          \n          // Intentar encontrar por key primero\n          if (child.key && columnPositions[child.key]) {\n            colPosition = columnPositions[child.key];\n          }\n          // Si no se encuentra por key, intentar por header\n          else if (child.header && columnPositions[child.header]) {\n            colPosition = columnPositions[child.header];\n          }\n          \n          if (colPosition !== undefined) {\n            const childCell = excelRow.getCell(colPosition);\n            childCell.value = this.processCellValue(child);\n            if (child.styles) {\n              childCell.style = this.convertStyle(child.styles);\n            }\n            if (child.numberFormat) {\n              childCell.numFmt = child.numberFormat;\n            }\n            \n            // Aplicar dimensiones de celda para children\n            this.applyCellDimensions(ws, rowPointer, colPosition, child);\n            // Aplicar comentario si existe\n            if (child.comment) {\n              this.applyCellComment(ws, rowPointer, colPosition, child.comment);\n            }\n            // Aplicar validación de datos si existe\n            if (child.validation) {\n              this.applyDataValidation(ws, rowPointer, colPosition, child.validation);\n            }\n            // Aplicar formato condicional si existe\n            if (child.styles?.conditionalFormats) {\n              this.applyConditionalFormatting(ws, rowPointer, colPosition, child.styles.conditionalFormats);\n            }\n          }\n        }\n      }\n    }\n    \n    // Incrementar rowPointer solo si la celda tiene la propiedad jump\n    if (row.jump) {\n      return rowPointer + 1;\n    }\n    \n    return rowPointer;\n  }\n\n  /**\n   * Convierte un color a formato ExcelJS (ARGB)\n   */\n  private convertColor(color: any): any {\n    if (!color) return undefined;\n    \n    // Si ya es un objeto con argb, retornarlo\n    if (typeof color === 'object' && color.argb) {\n      return color;\n    }\n    \n    // Si es un objeto con r, g, b\n    if (typeof color === 'object' && 'r' in color && 'g' in color && 'b' in color) {\n      const r = color.r.toString(16).padStart(2, '0');\n      const g = color.g.toString(16).padStart(2, '0');\n      const b = color.b.toString(16).padStart(2, '0');\n      return { argb: `FF${r}${g}${b}`.toUpperCase() };\n    }\n    \n    // Si es un string (hex)\n    if (typeof color === 'string') {\n      // Remover # si existe\n      let hex = color.replace('#', '');\n      \n      // Si es formato corto (RGB), expandirlo\n      if (hex.length === 3) {\n        hex = hex.split('').map(c => c + c).join('');\n      }\n      \n      // Asegurar que tenga alpha (FF = completamente opaco)\n      if (hex.length === 6) {\n        hex = 'FF' + hex.toUpperCase();\n      }\n      \n      return { argb: hex };\n    }\n    \n    // Si es un objeto theme\n    if (typeof color === 'object' && 'theme' in color) {\n      return color;\n    }\n    \n    return undefined;\n  }\n\n  /**\n   * Convierte el estilo personalizado a formato compatible con ExcelJS\n   */\n  private convertStyle(style: any): Partial<ExcelJS.Style> {\n    if (!style) return {};\n    \n    const converted: Partial<ExcelJS.Style> = {};\n    \n    if (style.font) {\n      converted.font = {\n        name: style.font.family || style.font.name,\n        size: style.font.size,\n        bold: style.font.bold,\n        italic: style.font.italic,\n        underline: style.font.underline,\n        color: this.convertColor(style.font.color)\n      };\n    }\n    \n    if (style.fill) {\n      // En ExcelJS, para patrón sólido, el color de fondo debe ir en fgColor\n      // backgroundColor es el color que queremos mostrar como fondo de la celda\n      const pattern = style.fill.pattern || 'solid';\n      \n      // Para patrón sólido: backgroundColor va en fgColor (es el color visible)\n      // Para otros patrones: foregroundColor es el color del patrón, backgroundColor es el fondo\n      const fgColor = pattern === 'solid' \n        ? (style.fill.backgroundColor || style.fill.foregroundColor)\n        : (style.fill.foregroundColor || style.fill.backgroundColor);\n      \n      // bgColor solo es relevante para patrones no sólidos\n      const bgColor = pattern !== 'solid' ? style.fill.backgroundColor : undefined;\n      \n      converted.fill = {\n        type: style.fill.type || 'pattern',\n        pattern: pattern,\n        fgColor: this.convertColor(fgColor),\n        bgColor: bgColor ? this.convertColor(bgColor) : undefined\n      };\n      \n      // Limpiar bgColor si es undefined para evitar problemas\n      if (!converted.fill.bgColor) {\n        delete converted.fill.bgColor;\n      }\n    }\n    \n    if (style.border) {\n      converted.border = {};\n      \n      if (style.border.top) {\n        converted.border.top = {\n          style: style.border.top.style,\n          color: this.convertColor(style.border.top.color)\n        };\n      }\n      \n      if (style.border.left) {\n        converted.border.left = {\n          style: style.border.left.style,\n          color: this.convertColor(style.border.left.color)\n        };\n      }\n      \n      if (style.border.bottom) {\n        converted.border.bottom = {\n          style: style.border.bottom.style,\n          color: this.convertColor(style.border.bottom.color)\n        };\n      }\n      \n      if (style.border.right) {\n        converted.border.right = {\n          style: style.border.right.style,\n          color: this.convertColor(style.border.right.color)\n        };\n      }\n    }\n    \n    // Conditional formatting se aplica directamente a la celda, no al estilo base\n    // Se maneja en applyConditionalFormatting()\n    \n    if (style.alignment) {\n      converted.alignment = {};\n      \n      // Horizontal alignment - validar valores permitidos\n      if (style.alignment.horizontal !== undefined) {\n        const validHorizontal = ['left', 'center', 'right', 'fill', 'justify', 'centerContinuous', 'distributed'];\n        if (validHorizontal.includes(style.alignment.horizontal)) {\n          converted.alignment.horizontal = style.alignment.horizontal as any;\n        }\n      }\n      \n      // Vertical alignment - validar valores permitidos\n      if (style.alignment.vertical !== undefined) {\n        const validVertical = ['top', 'middle', 'bottom', 'distributed', 'justify'];\n        if (validVertical.includes(style.alignment.vertical)) {\n          converted.alignment.vertical = style.alignment.vertical as any;\n        }\n      }\n      \n      // Wrap text\n      if (style.alignment.wrapText !== undefined) {\n        converted.alignment.wrapText = Boolean(style.alignment.wrapText);\n      }\n      \n      // Shrink to fit\n      if (style.alignment.shrinkToFit !== undefined) {\n        converted.alignment.shrinkToFit = Boolean(style.alignment.shrinkToFit);\n      }\n      \n      // Indent\n      if (style.alignment.indent !== undefined && typeof style.alignment.indent === 'number') {\n        converted.alignment.indent = style.alignment.indent;\n      }\n      \n      // Text rotation (0-180 grados)\n      if (style.alignment.textRotation !== undefined && typeof style.alignment.textRotation === 'number') {\n        converted.alignment.textRotation = style.alignment.textRotation;\n      }\n      \n      // Reading order\n      if (style.alignment.readingOrder !== undefined) {\n        const validReadingOrder = ['left-to-right', 'right-to-left', 'context'];\n        if (validReadingOrder.includes(style.alignment.readingOrder)) {\n          converted.alignment.readingOrder = style.alignment.readingOrder as any;\n        }\n      }\n      \n      // Solo agregar alignment si tiene al menos una propiedad\n      if (Object.keys(converted.alignment).length === 0) {\n        delete converted.alignment;\n      }\n    }\n    \n    if (style.numFmt) {\n      converted.numFmt = style.numFmt;\n    }\n    \n    return converted;\n  }\n\n  /**\n   * Convierte un número de columna a letra (1 = A, 2 = B, etc.)\n   */\n  private numberToColumnLetter(columnNumber: number): string {\n    let result = '';\n    while (columnNumber > 0) {\n      columnNumber--;\n      result = String.fromCharCode(65 + (columnNumber % 26)) + result;\n      columnNumber = Math.floor(columnNumber / 26);\n    }\n    return result;\n  }\n\n  /**\n   * Convierte letra de columna a número (A = 1, B = 2, etc.)\n   */\n  private columnLetterToNumber(columnLetter: string): number {\n    let result = 0;\n    for (let i = 0; i < columnLetter.length; i++) {\n      result = result * 26 + (columnLetter.charCodeAt(i) - 64);\n    }\n    return result;\n  }\n\n  /**\n   * Aplica una imagen al worksheet\n   */\n  private async applyImage(ws: ExcelJS.Worksheet, image: IWorksheetImage): Promise<void> {\n    try {\n      // Convertir posición\n      let row: number;\n      let col: number;\n      \n      if (typeof image.position.row === 'string') {\n        // Parsear referencia de celda (e.g., \"A1\" -> row 1)\n        const match = image.position.row.match(/([A-Z]+)(\\d+)/);\n        if (match && match[1] && match[2]) {\n          col = this.columnLetterToNumber(match[1]);\n          row = parseInt(match[2], 10);\n        } else {\n          row = parseInt(image.position.row, 10) || 1;\n          col = typeof image.position.col === 'string' \n            ? this.columnLetterToNumber(image.position.col)\n            : (typeof image.position.col === 'number' ? image.position.col : 1);\n        }\n      } else {\n        row = image.position.row;\n        col = typeof image.position.col === 'string' \n          ? this.columnLetterToNumber(image.position.col)\n          : (typeof image.position.col === 'number' ? image.position.col : 1);\n      }\n\n      // Preparar el buffer de imagen\n      let imageBuffer: Uint8Array;\n      if (typeof image.buffer === 'string') {\n        // Base64 string\n        let base64Data: string;\n        if (image.buffer.startsWith('data:')) {\n          // Data URL - extraer base64\n          const parts = image.buffer.split(',');\n          base64Data = parts[1] || image.buffer;\n        } else {\n          // Base64 directo\n          base64Data = image.buffer;\n        }\n        // Convertir base64 a Uint8Array\n        const binaryString = atob(base64Data);\n        const bytes = new Uint8Array(binaryString.length);\n        for (let i = 0; i < binaryString.length; i++) {\n          bytes[i] = binaryString.charCodeAt(i);\n        }\n        imageBuffer = bytes;\n      } else if (image.buffer instanceof ArrayBuffer) {\n        imageBuffer = new Uint8Array(image.buffer);\n      } else {\n        imageBuffer = image.buffer;\n      }\n\n      // Calcular posición y tamaño\n      const imagePosition: any = {\n        tl: { col: col - 1, row: row - 1 }\n      };\n\n      if (image.size) {\n        if (image.size.width && image.size.height) {\n          imagePosition.ext = {\n            width: image.size.width,\n            height: image.size.height\n          };\n        } else if (image.size.scaleX && image.size.scaleY) {\n          // Usar escala si no hay dimensiones absolutas\n          // Nota: ExcelJS no soporta escala directamente, necesitamos calcular dimensiones\n          imagePosition.ext = {\n            width: 100 * (image.size.scaleX || 1),\n            height: 100 * (image.size.scaleY || 1)\n          };\n        }\n      }\n\n      // ExcelJS addImage - primer parámetro es el objeto con buffer y extension, segundo es la posición\n      ws.addImage({\n        buffer: imageBuffer,\n        extension: image.extension\n      } as any, imagePosition as any);\n\n      // Agregar hipervínculo si existe\n      if (image.hyperlink) {\n        const cell = ws.getRow(row).getCell(col);\n        cell.value = {\n          text: image.description || '',\n          hyperlink: image.hyperlink\n        } as any;\n      }\n    } catch (error) {\n      console.warn('Error adding image to worksheet:', error);\n    }\n  }\n\n  /**\n   * Aplica agrupación de filas\n   */\n  private applyRowGrouping(ws: ExcelJS.Worksheet, startRow: number, endRow: number, collapsed: boolean = false): void {\n    for (let row = startRow; row <= endRow; row++) {\n      const excelRow = ws.getRow(row);\n      if (!excelRow.outlineLevel) {\n        excelRow.outlineLevel = 1;\n      }\n      // Nota: collapsed es read-only en ExcelJS, se maneja a través de outlineLevel\n      if (collapsed && row === startRow) {\n        try {\n          (excelRow as any).collapsed = true;\n        } catch {\n          // Ignorar si no está disponible\n        }\n      }\n    }\n  }\n\n  /**\n   * Aplica agrupación de columnas\n   */\n  private applyColumnGrouping(ws: ExcelJS.Worksheet, startCol: number, endCol: number, collapsed: boolean = false): void {\n    for (let col = startCol; col <= endCol; col++) {\n      const excelCol = ws.getColumn(col);\n      if (!excelCol.outlineLevel) {\n        excelCol.outlineLevel = 1;\n      }\n      // Nota: collapsed es read-only en ExcelJS, se maneja a través de outlineLevel\n      if (collapsed && col === startCol) {\n        try {\n          (excelCol as any).collapsed = true;\n        } catch {\n          // Ignorar si no está disponible\n        }\n      }\n    }\n  }\n\n  /**\n   * Aplica una tabla estructurada de Excel\n   */\n  private applyExcelTable(ws: ExcelJS.Worksheet, table: IExcelTable): void {\n    try {\n      const range = `${table.range.start}:${table.range.end}`;\n      \n      const tableConfig: any = {\n        name: table.name,\n        ref: range,\n        headerRow: table.headerRow !== false,\n        totalsRow: table.totalRow === true\n      };\n\n      if (table.style) {\n        tableConfig.style = {\n          theme: table.style,\n          showFirstColumn: false,\n          showLastColumn: false,\n          showRowStripes: true,\n          showColumnStripes: false\n        };\n      }\n\n      if (table.columns && table.columns.length > 0) {\n        tableConfig.columns = table.columns.map(col => ({\n          name: col.name,\n          filterButton: col.filterButton !== false,\n          totalsRowFunction: col.totalsRowFunction || 'none',\n          totalsRowFormula: col.totalsRowFormula\n        }));\n      }\n\n      ws.addTable(tableConfig);\n    } catch (error) {\n      console.warn('Error adding Excel table:', error);\n    }\n  }\n\n  /**\n   * Aplica configuración avanzada de impresión\n   */\n  private applyAdvancedPrintSettings(ws: ExcelJS.Worksheet): void {\n    // Headers y footers\n    if (this.config.printHeadersFooters) {\n      const headerFooter: any = {};\n      \n      if (this.config.printHeadersFooters.header) {\n        const left = this.config.printHeadersFooters.header.left || '';\n        const center = this.config.printHeadersFooters.header.center || '';\n        const right = this.config.printHeadersFooters.header.right || '';\n        headerFooter.oddHeader = `${left}&C${center}&R${right}`;\n      }\n      \n      if (this.config.printHeadersFooters.footer) {\n        const left = this.config.printHeadersFooters.footer.left || '';\n        const center = this.config.printHeadersFooters.footer.center || '';\n        const right = this.config.printHeadersFooters.footer.right || '';\n        headerFooter.oddFooter = `${left}&C${center}&R${right}`;\n      }\n      \n      if (Object.keys(headerFooter).length > 0) {\n        ws.headerFooter = headerFooter;\n      }\n    }\n\n    // Repeat rows/columns\n    if (this.config.printRepeat) {\n      if (this.config.printRepeat.rows) {\n        if (Array.isArray(this.config.printRepeat.rows)) {\n          const rowsStr = this.config.printRepeat.rows.map(r => r.toString()).join(':');\n          ws.pageSetup.printTitlesRow = `$${rowsStr}`;\n        } else {\n          ws.pageSetup.printTitlesRow = `$${this.config.printRepeat.rows}`;\n        }\n      }\n      \n      if (this.config.printRepeat.columns) {\n        if (Array.isArray(this.config.printRepeat.columns)) {\n          const colsStr = this.config.printRepeat.columns\n            .map(c => typeof c === 'number' ? this.numberToColumnLetter(c) : c)\n            .join(':');\n          ws.pageSetup.printTitlesColumn = `$${colsStr}`;\n        } else {\n          ws.pageSetup.printTitlesColumn = `$${this.config.printRepeat.columns}`;\n        }\n      }\n    }\n  }\n\n  /**\n   * Aplica filas y columnas ocultas\n   */\n  private applyHiddenRowsColumns(ws: ExcelJS.Worksheet): void {\n    // Ocultar filas\n    for (const rowNum of this.hiddenRows) {\n      const row = ws.getRow(rowNum);\n      row.hidden = true;\n    }\n\n    // Ocultar columnas\n    for (const colNum of this.hiddenColumns) {\n      const column = ws.getColumn(colNum);\n      column.hidden = true;\n    }\n  }\n\n  /**\n   * Aplica una tabla dinámica (pivot table)\n   */\n  private async applyPivotTable(ws: ExcelJS.Worksheet, pivotTable: IPivotTable): Promise<void> {\n    try {\n      // Verificar si la hoja de origen existe si es diferente\n      if (pivotTable.sourceSheet) {\n        const workbook = ws.workbook;\n        const sourceSheet = workbook.getWorksheet(pivotTable.sourceSheet);\n        if (!sourceSheet) {\n          console.warn(`Source sheet \"${pivotTable.sourceSheet}\" not found for pivot table \"${pivotTable.name}\"`);\n          return;\n        }\n      }\n\n      // Construir la configuración de la tabla dinámica\n      const pivotConfig: any = {\n        name: pivotTable.name,\n        ref: pivotTable.ref,\n        sourceRange: pivotTable.sourceRange,\n        fields: {}\n      };\n\n      // Configurar campos\n      if (pivotTable.fields.rows && pivotTable.fields.rows.length > 0) {\n        pivotConfig.fields.rows = pivotTable.fields.rows;\n      }\n\n      if (pivotTable.fields.columns && pivotTable.fields.columns.length > 0) {\n        pivotConfig.fields.columns = pivotTable.fields.columns;\n      }\n\n      if (pivotTable.fields.values && pivotTable.fields.values.length > 0) {\n        pivotConfig.fields.values = pivotTable.fields.values.map(v => ({\n          name: v.name,\n          stat: v.stat\n        }));\n      }\n\n      if (pivotTable.fields.filters && pivotTable.fields.filters.length > 0) {\n        pivotConfig.fields.filters = pivotTable.fields.filters;\n      }\n\n      // Opciones\n      if (pivotTable.options) {\n        pivotConfig.options = pivotTable.options;\n      }\n\n      // Agregar la tabla dinámica\n      // ExcelJS addPivotTable - verificar si existe el método\n      if ((ws as any).addPivotTable) {\n        (ws as any).addPivotTable(pivotConfig);\n      } else {\n        console.warn('Pivot tables require ExcelJS 4.5.0+. Feature may not be fully supported.');\n      }\n    } catch (error) {\n      console.warn('Error adding pivot table:', error);\n    }\n  }\n\n  /**\n   * Convierte un color a formato ExcelJS\n   */\n  private convertColorToExcelJS(color: string | { r: number; g: number; b: number } | { theme: number }): any {\n    if (typeof color === 'string') {\n      // Hex color\n      if (color.startsWith('#')) {\n        const hex = color.substring(1);\n        return { argb: `FF${hex.toUpperCase()}` };\n      }\n      // Named color - intentar convertir\n      return { argb: 'FF000000' };\n    } else if ('r' in color && 'g' in color && 'b' in color) {\n      // RGB object\n      const hex = [color.r, color.g, color.b].map(x => {\n        const hex = x.toString(16);\n        return hex.length === 1 ? '0' + hex : hex;\n      }).join('').toUpperCase();\n      return { argb: `FF${hex}` };\n    } else if ('theme' in color) {\n      // Theme color\n      return { theme: color.theme };\n    }\n    return { argb: 'FF000000' };\n  }\n\n  /**\n   * Aplica views (freeze panes, split panes, sheet views)\n   */\n  private applyViews(ws: ExcelJS.Worksheet): void {\n    const views: ExcelJS.WorksheetView[] = [];\n\n    // Freeze panes\n    if (this.config.freezePanes) {\n      const freezeView: any = {\n        state: 'frozen',\n        xSplit: this.config.freezePanes.col - 1,\n        ySplit: this.config.freezePanes.row - 1,\n        topLeftCell: this.config.freezePanes.reference || this.numberToColumnLetter(this.config.freezePanes.col) + String(this.config.freezePanes.row),\n        activeCell: this.config.freezePanes.reference || this.numberToColumnLetter(this.config.freezePanes.col) + String(this.config.freezePanes.row)\n      };\n      views.push(freezeView);\n    }\n    // Split panes\n    else if (this.config.splitPanes) {\n      const splitConfig = this.config.splitPanes;\n      const splitView: any = {\n        state: 'split',\n        xSplit: splitConfig.xSplit || 0,\n        ySplit: splitConfig.ySplit || 0\n      };\n\n      if (splitConfig.topLeftCell) {\n        splitView.topLeftCell = splitConfig.topLeftCell;\n      }\n\n      if (splitConfig.activePane) {\n        const paneMap: Record<string, string> = {\n          'topLeft': 'topLeft',\n          'topRight': 'topRight',\n          'bottomLeft': 'bottomLeft',\n          'bottomRight': 'bottomRight'\n        };\n        splitView.activePane = paneMap[splitConfig.activePane] || 'topLeft';\n      }\n\n      views.push(splitView);\n    }\n    // Sheet views (normal, pageBreakPreview, pageLayout)\n    else if (this.config.views) {\n      const viewConfig = this.config.views;\n      const view: any = {\n        state: viewConfig.state === 'pageBreakPreview' || viewConfig.state === 'pageLayout' ? 'normal' : (viewConfig.state || 'normal')\n      };\n\n      if (viewConfig.zoomScale !== undefined) {\n        view.zoomScale = viewConfig.zoomScale;\n      }\n\n      if (viewConfig.zoomScaleNormal !== undefined) {\n        view.zoomScaleNormal = viewConfig.zoomScaleNormal;\n      }\n\n      if (viewConfig.showGridLines !== undefined) {\n        view.showGridLines = viewConfig.showGridLines;\n      }\n\n      if (viewConfig.showRowColHeaders !== undefined) {\n        view.showRowColHeaders = viewConfig.showRowColHeaders;\n      }\n\n      if (viewConfig.showRuler !== undefined) {\n        view.showRuler = viewConfig.showRuler;\n      }\n\n      if (viewConfig.rightToLeft !== undefined) {\n        view.rightToLeft = viewConfig.rightToLeft;\n      }\n\n      views.push(view);\n    }\n    // Default view if zoom is set\n    else if (this.config.zoom) {\n      views.push({\n        state: 'normal',\n        zoomScale: this.config.zoom\n      } as any);\n    }\n\n    // Apply views if any were configured\n    if (views.length > 0) {\n      ws.views = views;\n    }\n  }\n\n  /**\n   * Obtiene un estilo predefinido del workbook\n   */\n  private getPredefinedStyle(styleName: string): import('../types/style.types').IStyle | undefined {\n    if (this.customStyles && this.customStyles[styleName]) {\n      return this.customStyles[styleName];\n    }\n    return undefined;\n  }\n\n  /**\n   * Obtiene un estilo del tema para una sección específica\n   */\n  private getThemeStyle(section: 'header' | 'subHeader' | 'body' | 'footer', rowIndex?: number): import('../types/style.types').IStyle | undefined {\n    if (!this.theme || this.theme.autoApplySectionStyles === false) {\n      return undefined;\n    }\n\n    if (!this.customStyles) {\n      return undefined;\n    }\n\n    // Mapear sección a nombre de estilo del tema\n    let styleName = '';\n    if (section === 'header') {\n      styleName = '__theme_header';\n    } else if (section === 'subHeader') {\n      styleName = '__theme_subHeader';\n    } else if (section === 'body') {\n      // Para body, alternar entre normal y alternativo si está disponible\n      if (rowIndex !== undefined && rowIndex % 2 === 1 && this.customStyles['__theme_body_alt']) {\n        styleName = '__theme_body_alt';\n      } else {\n        styleName = '__theme_body';\n      }\n    } else if (section === 'footer') {\n      styleName = '__theme_footer';\n    }\n\n    return this.customStyles[styleName];\n  }\n\n  /**\n   * Aplica un slicer a una tabla o tabla dinámica\n   */\n  private async applySlicer(ws: ExcelJS.Worksheet, slicer: ISlicer): Promise<void> {\n    try {\n      // ExcelJS no tiene soporte directo para slicers en la API pública\n      // Se puede implementar usando la estructura XML subyacente, pero es complejo\n      // Por ahora, documentamos la funcionalidad y dejamos un placeholder\n      // Nota: Los slicers requieren manipulación directa del XML de Excel\n      console.warn('Slicers require advanced ExcelJS XML manipulation. Feature documented but not fully implemented.');\n      \n      // Intentar agregar como comentario o nota en la celda de posición\n      const colNum = typeof slicer.position.col === 'string' \n        ? this.columnLetterToNumber(slicer.position.col)\n        : slicer.position.col;\n      \n      const cell = ws.getRow(slicer.position.row).getCell(colNum);\n      cell.note = `Slicer: ${slicer.name} for table \"${slicer.targetTable}\" on column \"${slicer.column}\"`;\n    } catch (error) {\n      console.warn('Error adding slicer:', error);\n    }\n  }\n\n  /**\n   * Aplica una marca de agua al worksheet\n   */\n  private async applyWatermark(ws: ExcelJS.Worksheet, watermark: IWatermark): Promise<void> {\n    try {\n      if (watermark.image) {\n        // Usar imagen como marca de agua\n        const imageConfig: IWorksheetImage = {\n          ...watermark.image,\n          position: watermark.position ? {\n            row: watermark.position.vertical === 'top' ? 1 : watermark.position.vertical === 'bottom' ? 1000 : 500,\n            col: watermark.position.horizontal === 'left' ? 1 : watermark.position.horizontal === 'right' ? 20 : 10\n          } : { row: 500, col: 10 },\n          size: watermark.image.size || {\n            width: 400,\n            height: 300,\n            scaleX: watermark.opacity || 0.3,\n            scaleY: watermark.opacity || 0.3\n          }\n        };\n        await this.applyImage(ws, imageConfig);\n      } else if (watermark.text) {\n        // Crear marca de agua de texto usando una imagen generada\n        // Nota: En un entorno real, necesitarías generar una imagen del texto\n        // Por ahora, agregamos el texto como comentario en una celda central\n        const centerRow = Math.floor((ws.rowCount || 100) / 2);\n        const centerCol = Math.floor((ws.columnCount || 20) / 2);\n        const cell = ws.getRow(centerRow).getCell(centerCol);\n        cell.value = watermark.text;\n        cell.style = {\n          font: {\n            size: watermark.fontSize || 72,\n            color: { argb: this.convertColorToExcelJS(watermark.fontColor || '#CCCCCC').argb },\n            italic: true\n          },\n          alignment: {\n            horizontal: 'center',\n            vertical: 'middle'\n          }\n        } as any;\n      }\n    } catch (error) {\n      console.warn('Error adding watermark:', error);\n    }\n  }\n\n  /**\n   * Aplica una conexión de datos\n   */\n  private async applyDataConnection(workbook: ExcelJS.Workbook, connection: IDataConnection): Promise<void> {\n    try {\n      // ExcelJS no tiene soporte directo para conexiones de datos\n      // Las conexiones de datos requieren manipulación del XML de Excel\n      // Por ahora, documentamos la funcionalidad\n      console.warn('Data connections require advanced ExcelJS XML manipulation. Feature documented but not fully implemented.');\n      \n      // Guardar información de la conexión en los metadatos del workbook\n      if (!workbook.model) {\n        (workbook as any).model = {};\n      }\n      if (!(workbook as any).model.dataConnections) {\n        (workbook as any).model.dataConnections = [];\n      }\n      (workbook as any).model.dataConnections.push({\n        name: connection.name,\n        type: connection.type,\n        connectionString: connection.connectionString,\n        commandText: connection.commandText,\n        refresh: connection.refresh,\n        credentials: connection.credentials ? {\n          username: connection.credentials.username,\n          integratedSecurity: connection.credentials.integratedSecurity\n          // No guardar password por seguridad\n        } : undefined\n      });\n    } catch (error) {\n      console.warn('Error adding data connection:', error);\n    }\n  }\n}","/**\n * Builder-specific type definitions\n */\n\nimport { IWorkbookMetadata, Result, Color } from './core.types';\nimport { IWorksheet, IWorksheetConfig } from './worksheet.types';\nimport { IStyle } from './style.types';\n\n// Re-export ErrorType for convenience\nexport { ErrorType } from './core.types';\n\n/**\n * Excel builder configuration interface\n */\nexport interface IExcelBuilderConfig {\n  /** Workbook metadata */\n  metadata?: IWorkbookMetadata;\n  /** Default worksheet configuration */\n  defaultWorksheetConfig?: Partial<IWorksheetConfig>;\n  /** Default styles */\n  defaultStyles?: {\n    header?: IStyle;\n    subheader?: IStyle;\n    data?: IStyle;\n    footer?: IStyle;\n    total?: IStyle;\n  };\n  /** Whether to enable validation */\n  enableValidation?: boolean;\n  /** Whether to enable events */\n  enableEvents?: boolean;\n  /** Whether to enable performance monitoring */\n  enablePerformanceMonitoring?: boolean;\n  /** Maximum number of worksheets */\n  maxWorksheets?: number;\n  /** Maximum number of rows per worksheet */\n  maxRowsPerWorksheet?: number;\n  /** Maximum number of columns per worksheet */\n  maxColumnsPerWorksheet?: number;\n  /** Memory limit in bytes */\n  memoryLimit?: number;\n}\n\n/**\n * Build options interface\n */\nexport interface IBuildOptions {\n  /** Output format */\n  format?: 'xlsx' | 'xls' | 'csv';\n  /** Whether to include styles */\n  includeStyles?: boolean;\n  /** Whether to include formulas */\n  includeFormulas?: boolean;\n  /** Whether to include comments */\n  includeComments?: boolean;\n  /** Whether to include data validation */\n  includeValidation?: boolean;\n  /** Whether to include conditional formatting */\n  includeConditionalFormatting?: boolean;\n  /** Compression level (0-9) */\n  compressionLevel?: number;\n  /** Whether to optimize for size */\n  optimizeForSize?: boolean;\n  /** Whether to optimize for speed */\n  optimizeForSpeed?: boolean;\n}\n\n/**\n * Download options interface\n */\nexport interface IDownloadOptions extends IBuildOptions {\n  /** File name */\n  fileName?: string;\n  /** Whether to show download progress */\n  showProgress?: boolean;\n  /** Progress callback */\n  onProgress?: (progress: number) => void;\n  /** Whether to auto-download */\n  autoDownload?: boolean;\n  /** MIME type */\n  mimeType?: string;\n}\n\n/**\n * Save file options interface (for Node.js)\n */\nexport interface ISaveFileOptions extends IBuildOptions {\n  /** Whether to create parent directories if they don't exist (default: true) */\n  createDir?: boolean;\n  /** File encoding (default: 'binary') */\n  encoding?: 'ascii' | 'utf8' | 'utf-8' | 'utf16le' | 'ucs2' | 'ucs-2' | 'base64' | 'latin1' | 'binary' | 'hex';\n}\n\n/**\n * Excel builder interface\n */\nexport interface IExcelBuilder {\n  /** Builder configuration */\n  config: IExcelBuilderConfig;\n  /** Worksheets in the workbook */\n  worksheets: Map<string, IWorksheet>;\n  /** Current worksheet */\n  currentWorksheet: IWorksheet | undefined;\n  /** Whether the builder is building */\n  isBuilding: boolean;\n  /** Build statistics */\n  stats: IBuildStats;\n\n  /** Add a new worksheet */\n  addWorksheet(name: string, config?: Partial<IWorksheetConfig>): IWorksheet;\n  /** Get a worksheet by name */\n  getWorksheet(name: string): IWorksheet | undefined;\n  /** Remove a worksheet */\n  removeWorksheet(name: string): boolean;\n  /** Set the current worksheet */\n  setCurrentWorksheet(name: string): boolean;\n  /** Build the workbook */\n  build(options?: IBuildOptions): Promise<Result<ArrayBuffer>>;\n  /** Generate and download the file */\n  generateAndDownload(fileName: string, options?: IDownloadOptions): Promise<Result<void>>;\n  /** Save file to disk (Node.js only) - Similar to generateAndDownload but for Node.js */\n  saveToFile(filePath: string, options?: ISaveFileOptions): Promise<Result<void>>;\n  /** Save to stream (Node.js only) - For large files */\n  saveToStream(writeStream: { write: (chunk: any, callback?: (error?: Error | null) => void) => boolean }, options?: IBuildOptions): Promise<Result<void>>;\n  /** Get workbook as buffer */\n  toBuffer(options?: IBuildOptions): Promise<Result<ArrayBuffer>>;\n  /** Get workbook as blob */\n  toBlob(options?: IBuildOptions): Promise<Result<Blob>>;\n  /** Validate the workbook */\n  validate(): Result<boolean>;\n  /** Clear all worksheets */\n  clear(): void;\n  /** Get workbook statistics */\n  getStats(): IBuildStats;\n  /** Add a predefined cell style */\n  addCellStyle(name: string, style: IStyle): this;\n  /** Get a predefined cell style by name */\n  getCellStyle(name: string): IStyle | undefined;\n  /** Set workbook theme */\n  setTheme(theme: IWorkbookTheme): this;\n  /** Get current workbook theme */\n  getTheme(): IWorkbookTheme | undefined;\n}\n\n/**\n * Build statistics interface\n */\nexport interface IBuildStats {\n  /** Total number of worksheets */\n  totalWorksheets: number;\n  /** Total number of cells */\n  totalCells: number;\n  /** Total memory usage in bytes */\n  memoryUsage: number;\n  /** Build time in milliseconds */\n  buildTime: number;\n  /** File size in bytes */\n  fileSize: number;\n  /** Number of styles used */\n  stylesUsed: number;\n  /** Number of formulas used */\n  formulasUsed: number;\n  /** Number of conditional formats used */\n  conditionalFormatsUsed: number;\n  /** Performance metrics */\n  performance: {\n    /** Time spent building headers */\n    headersTime: number;\n    /** Time spent building data */\n    dataTime: number;\n    /** Time spent applying styles */\n    stylesTime: number;\n    /** Time spent writing to buffer */\n    writeTime: number;\n  };\n}\n\n/**\n * Builder event types\n */\nexport enum BuilderEventType {\n  WORKSHEET_ADDED = 'worksheetAdded',\n  WORKSHEET_REMOVED = 'worksheetRemoved',\n  WORKSHEET_UPDATED = 'worksheetUpdated',\n  BUILD_STARTED = 'buildStarted',\n  BUILD_PROGRESS = 'buildProgress',\n  BUILD_COMPLETED = 'buildCompleted',\n  BUILD_ERROR = 'buildError',\n  DOWNLOAD_STARTED = 'downloadStarted',\n  DOWNLOAD_PROGRESS = 'downloadProgress',\n  DOWNLOAD_COMPLETED = 'downloadCompleted',\n  DOWNLOAD_ERROR = 'downloadError'\n}\n\n/**\n * Builder event interface\n */\nexport interface IBuilderEvent {\n  type: BuilderEventType;\n  data?: Record<string, unknown>;\n  timestamp: Date;\n}\n\n/**\n * Builder event listener interface\n */\nexport interface IBuilderEventListener {\n  (event: IBuilderEvent): void;\n}\n\n/**\n * Builder validation result interface\n */\nexport interface IBuilderValidationResult {\n  /** Whether the builder is valid */\n  isValid: boolean;\n  /** Validation errors */\n  errors: string[];\n  /** Validation warnings */\n  warnings: string[];\n  /** Worksheet validation results */\n  worksheetResults: Map<string, boolean>;\n}\n\n/**\n * Workbook theme configuration\n */\nexport interface IWorkbookTheme {\n  /** Theme name */\n  name?: string;\n  /** Color scheme */\n  colors?: {\n    /** Dark 1 color */\n    dark1?: Color;\n    /** Light 1 color */\n    light1?: Color;\n    /** Dark 2 color */\n    dark2?: Color;\n    /** Light 2 color */\n    light2?: Color;\n    /** Accent 1 color */\n    accent1?: Color;\n    /** Accent 2 color */\n    accent2?: Color;\n    /** Accent 3 color */\n    accent3?: Color;\n    /** Accent 4 color */\n    accent4?: Color;\n    /** Accent 5 color */\n    accent5?: Color;\n    /** Accent 6 color */\n    accent6?: Color;\n    /** Hyperlink color */\n    hyperlink?: Color;\n    /** Followed hyperlink color */\n    followedHyperlink?: Color;\n  };\n  /** Font scheme */\n  fonts?: {\n    /** Major font (headings) */\n    major?: {\n      latin?: string;\n      eastAsian?: string;\n      complexScript?: string;\n    };\n    /** Minor font (body) */\n    minor?: {\n      latin?: string;\n      eastAsian?: string;\n      complexScript?: string;\n    };\n  };\n  /** Section styles - automatically applied to headers, footers, body, etc. */\n  sectionStyles?: {\n    /** Style for main headers */\n    header?: {\n      backgroundColor?: Color;\n      fontColor?: Color;\n      fontSize?: number;\n      fontBold?: boolean;\n      borderColor?: Color;\n    };\n    /** Style for subheaders */\n    subHeader?: {\n      backgroundColor?: Color;\n      fontColor?: Color;\n      fontSize?: number;\n      fontBold?: boolean;\n      borderColor?: Color;\n    };\n    /** Style for body/data rows */\n    body?: {\n      backgroundColor?: Color;\n      fontColor?: Color;\n      fontSize?: number;\n      alternatingRowColor?: Color;\n      borderColor?: Color;\n    };\n    /** Style for footers */\n    footer?: {\n      backgroundColor?: Color;\n      fontColor?: Color;\n      fontSize?: number;\n      fontBold?: boolean;\n      borderColor?: Color;\n    };\n  };\n  /** Whether to automatically apply section styles (default: true) */\n  autoApplySectionStyles?: boolean;\n} ","/**\n * ExcelBuilder - Main class for creating Excel workbooks\n * \n * This class provides a fluent API for creating complex Excel files with multiple worksheets,\n * advanced styling, themes, and comprehensive features. It works in both browser and Node.js environments.\n * \n * @example\n * ```typescript\n * const builder = new ExcelBuilder({\n *   metadata: {\n *     title: 'Sales Report',\n *     author: 'My Company'\n *   }\n * });\n * \n * const worksheet = builder.addWorksheet('Sales');\n * worksheet.addHeader({ key: 'title', value: 'Monthly Report', type: CellType.STRING });\n * \n * // Browser\n * await builder.generateAndDownload('report.xlsx');\n * \n * // Node.js\n * await builder.saveToFile('./output/report.xlsx');\n * ```\n */\n\nimport ExcelJS from 'exceljs';\nimport saveAs from 'file-saver';\nimport { EventEmitter } from '../utils/EventEmitter';\nimport { Worksheet } from './Worksheet';\nimport {\n  IExcelBuilder,\n  IExcelBuilderConfig,\n  IBuildOptions,\n  IDownloadOptions,\n  ISaveFileOptions,\n  IBuildStats,\n  BuilderEventType,\n  IBuilderEvent,\n  ErrorType,\n  IWorkbookTheme\n} from '../types/builder.types';\nimport { Color } from '../types/core.types';\nimport {\n  IWorksheet,\n  IWorksheetConfig\n} from '../types/worksheet.types';\nimport { \n  Result,\n  ISuccessResult,\n  IErrorResult\n} from '../types/core.types';\n\n/**\n * ExcelBuilder class for creating Excel workbooks\n * \n * Main entry point for creating Excel files. Supports multiple worksheets, themes,\n * predefined styles, and comprehensive Excel features.\n * \n * @class ExcelBuilder\n * @implements {IExcelBuilder}\n */\nexport class ExcelBuilder implements IExcelBuilder {\n  public config: IExcelBuilderConfig;\n  public worksheets: Map<string, IWorksheet> = new Map();\n  public currentWorksheet: IWorksheet | undefined;\n  public isBuilding = false;\n  public stats: IBuildStats;\n\n  private eventEmitter: EventEmitter;\n  private cellStyles: Map<string, import('../types/style.types').IStyle> = new Map();\n  private theme: IWorkbookTheme | undefined;\n\n  /**\n   * Creates a new ExcelBuilder instance\n   * \n   * @param {IExcelBuilderConfig} config - Configuration options for the builder\n   * @param {IWorkbookMetadata} [config.metadata] - Workbook metadata (title, author, description, etc.)\n   * @param {Partial<IWorksheetConfig>} [config.defaultWorksheetConfig] - Default configuration for all worksheets\n   * @param {boolean} [config.enableValidation=true] - Enable data validation\n   * @param {boolean} [config.enableEvents=true] - Enable event system\n   * @param {boolean} [config.enablePerformanceMonitoring=false] - Enable performance monitoring\n   * @param {number} [config.maxWorksheets=255] - Maximum number of worksheets allowed\n   * @param {number} [config.maxRowsPerWorksheet=1048576] - Maximum rows per worksheet\n   * @param {number} [config.maxColumnsPerWorksheet=16384] - Maximum columns per worksheet\n   * @param {number} [config.memoryLimit=104857600] - Memory limit in bytes (100MB default)\n   * \n   * @example\n   * ```typescript\n   * const builder = new ExcelBuilder({\n   *   metadata: {\n   *     title: 'Annual Report',\n   *     author: 'John Doe',\n   *     description: 'Company annual report for 2024'\n   *   },\n   *   enableValidation: true,\n   *   enableEvents: true\n   * });\n   * ```\n   */\n  constructor(config: IExcelBuilderConfig = {}) {\n    this.config = {\n      enableValidation: true,\n      enableEvents: true,\n      enablePerformanceMonitoring: false,\n      maxWorksheets: 255,\n      maxRowsPerWorksheet: 1048576,\n      maxColumnsPerWorksheet: 16384,\n      memoryLimit: 100 * 1024 * 1024, // 100MB\n      ...config\n    };\n\n    this.stats = this.initializeStats();\n    this.eventEmitter = new EventEmitter();\n  }\n\n  /**\n   * Add a new worksheet to the workbook\n   * \n   * Creates a new worksheet with the specified name and configuration. The worksheet\n   * becomes the current worksheet automatically. If a worksheet with the same name\n   * already exists, an error is thrown.\n   * \n   * @param {string} name - Unique name for the worksheet (required, must be unique)\n   * @param {Partial<IWorksheetConfig>} [worksheetConfig={}] - Configuration for the worksheet\n   * @param {string} [worksheetConfig.tabColor] - Tab color (hex format, e.g., '#FF0000')\n   * @param {number} [worksheetConfig.defaultRowHeight=20] - Default row height in points\n   * @param {number} [worksheetConfig.defaultColWidth=10] - Default column width in characters\n   * @param {boolean} [worksheetConfig.hidden=false] - Whether the worksheet is hidden\n   * @param {boolean} [worksheetConfig.protected=false] - Whether the worksheet is protected\n   * @param {string} [worksheetConfig.protectionPassword] - Password for worksheet protection\n   * @param {boolean} [worksheetConfig.showGridLines=true] - Show grid lines\n   * @param {boolean} [worksheetConfig.showRowColHeaders=true] - Show row and column headers\n   * @param {number} [worksheetConfig.zoom] - Zoom level (10-400)\n   * \n   * @returns {IWorksheet} The newly created worksheet instance\n   * \n   * @throws {Error} If a worksheet with the same name already exists\n   * \n   * @example\n   * ```typescript\n   * // Simple worksheet\n   * const sheet1 = builder.addWorksheet('Sales');\n   * \n   * // Worksheet with configuration\n   * const sheet2 = builder.addWorksheet('Summary', {\n   *   tabColor: '#4472C4',\n   *   defaultRowHeight: 25,\n   *   defaultColWidth: 15,\n   *   protected: true,\n   *   protectionPassword: 'mypassword'\n   * });\n   * ```\n   */\n  addWorksheet(name: string, worksheetConfig: Partial<IWorksheetConfig> = {}): IWorksheet {\n    if (this.worksheets.has(name)) {\n      throw new Error(`Worksheet \"${name}\" already exists`);\n    }\n\n    const config: IWorksheetConfig = {\n      name,\n      defaultRowHeight: 20,\n      defaultColWidth: 10,\n      ...this.config.defaultWorksheetConfig,\n      ...worksheetConfig\n    };\n\n    const worksheet = new Worksheet(config);\n    this.worksheets.set(name, worksheet);\n    this.currentWorksheet = worksheet;\n    \n    this.emitEvent(BuilderEventType.WORKSHEET_ADDED, { worksheetName: name });\n    \n    return worksheet;\n  }\n\n  /**\n   * Get a worksheet by name\n   * \n   * Retrieves an existing worksheet from the workbook by its name.\n   * Returns undefined if the worksheet doesn't exist.\n   * \n   * @param {string} name - Name of the worksheet to retrieve\n   * @returns {IWorksheet | undefined} The worksheet if found, undefined otherwise\n   * \n   * @example\n   * ```typescript\n   * const worksheet = builder.getWorksheet('Sales');\n   * if (worksheet) {\n   *   worksheet.addRow([...]);\n   * }\n   * ```\n   */\n  getWorksheet(name: string): IWorksheet | undefined {\n    return this.worksheets.get(name);\n  }\n\n  /**\n   * Remove a worksheet by name\n   * \n   * Removes a worksheet from the workbook. If the removed worksheet was the current\n   * worksheet, the current worksheet is cleared.\n   * \n   * @param {string} name - Name of the worksheet to remove\n   * @returns {boolean} True if the worksheet was found and removed, false otherwise\n   * \n   * @example\n   * ```typescript\n   * const removed = builder.removeWorksheet('OldSheet');\n   * if (removed) {\n   *   console.log('Worksheet removed successfully');\n   * }\n   * ```\n   */\n  removeWorksheet(name: string): boolean {\n    const worksheet = this.worksheets.get(name);\n    if (!worksheet) {\n      return false;\n    }\n\n    this.worksheets.delete(name);\n    \n    // If this was the current worksheet, clear it\n    if (this.currentWorksheet === worksheet) {\n      this.currentWorksheet = undefined;\n    }\n    \n    this.emitEvent(BuilderEventType.WORKSHEET_REMOVED, { worksheetName: name });\n    \n    return true;\n  }\n\n  /**\n   * Set the current worksheet\n   * \n   * Sets the active worksheet. Operations like addRow() will be performed on the\n   * current worksheet. When you add a new worksheet, it automatically becomes the current one.\n   * \n   * @param {string} name - Name of the worksheet to set as current\n   * @returns {boolean} True if the worksheet was found and set, false otherwise\n   * \n   * @example\n   * ```typescript\n   * builder.addWorksheet('Sheet1');\n   * builder.addWorksheet('Sheet2');\n   * \n   * // Switch back to Sheet1\n   * builder.setCurrentWorksheet('Sheet1');\n   * ```\n   */\n  setCurrentWorksheet(name: string): boolean {\n    const worksheet = this.worksheets.get(name);\n    if (!worksheet) {\n      return false;\n    }\n    \n    this.currentWorksheet = worksheet;\n    return true;\n  }\n\n  /**\n   * Build the workbook and return as ArrayBuffer\n   * \n   * Compiles all worksheets, applies themes and styles, and generates the Excel file\n   * as an ArrayBuffer. This is the core method that all export methods use internally.\n   * \n   * The build process:\n   * 1. Creates a new ExcelJS workbook\n   * 2. Applies workbook metadata\n   * 3. Applies theme (if set)\n   * 4. Adds predefined cell styles\n   * 5. Builds each worksheet\n   * 6. Writes to buffer with compression\n   * \n   * @param {IBuildOptions} [options={}] - Build options\n   * @param {'xlsx' | 'xls' | 'csv'} [options.format='xlsx'] - Output format\n   * @param {boolean} [options.includeStyles=true] - Include cell styles\n   * @param {number} [options.compressionLevel=6] - Compression level (0-9, higher = more compression)\n   * @param {boolean} [options.optimizeForSpeed=false] - Optimize for speed over file size\n   * \n   * @returns {Promise<Result<ArrayBuffer>>} Result containing the Excel file as ArrayBuffer\n   * \n   * @throws {Error} If build is already in progress (prevents concurrent builds)\n   * \n   * @example\n   * ```typescript\n   * // Basic build\n   * const result = await builder.build();\n   * if (result.success) {\n   *   const buffer = result.data;\n   *   // Use buffer...\n   * }\n   * \n   * // Build with options\n   * const result = await builder.build({\n   *   compressionLevel: 9, // Maximum compression\n   *   optimizeForSpeed: true\n   * });\n   * ```\n   */\n  async build(options: IBuildOptions = {}): Promise<Result<ArrayBuffer>> {\n    if (this.isBuilding) {\n      return {\n        success: false,\n        error: {\n          type: ErrorType.BUILD_ERROR,\n          message: 'Build already in progress',\n          stack: new Error().stack || ''\n        }\n      };\n    }\n\n    this.isBuilding = true;\n    const startTime = Date.now();\n    \n    try {\n      this.emitEvent(BuilderEventType.BUILD_STARTED);\n      \n      const workbook = new ExcelJS.Workbook();\n      \n      // Add metadata\n      if (this.config.metadata) {\n        workbook.creator = this.config.metadata.author || 'Han Excel Builder';\n        workbook.lastModifiedBy = this.config.metadata.author || 'Han Excel Builder';\n        workbook.created = this.config.metadata.created || new Date();\n        workbook.modified = this.config.metadata.modified || new Date();\n        if (this.config.metadata.title) workbook.title = this.config.metadata.title;\n        if (this.config.metadata.subject) workbook.subject = this.config.metadata.subject;\n        if (this.config.metadata.keywords) workbook.keywords = this.config.metadata.keywords;\n        if (this.config.metadata.category) workbook.category = this.config.metadata.category;\n        if (this.config.metadata.description) workbook.description = this.config.metadata.description;\n      }\n\n      // Apply theme if set\n      if (this.theme) {\n        this.applyTheme(workbook, this.theme);\n      }\n\n      // Add predefined cell styles\n      for (const [name, style] of this.cellStyles.entries()) {\n        this.addStyleToWorkbook(workbook, name, style);\n      }\n\n      // Build each worksheet\n      for (const worksheet of this.worksheets.values()) {\n        await (worksheet as Worksheet).build(workbook, options);\n      }\n\n      // Write to buffer\n      const buffer = await workbook.xlsx.writeBuffer({\n        compression: options.compressionLevel || 6\n      } as any);\n\n      const endTime = Date.now();\n      this.stats.buildTime = endTime - startTime;\n      this.stats.fileSize = buffer.byteLength;\n      \n      const successResult: ISuccessResult<ArrayBuffer> = {\n        success: true,\n        data: buffer\n      };\n\n      this.emitEvent(BuilderEventType.BUILD_COMPLETED, {\n        buildTime: this.stats.buildTime,\n        fileSize: this.stats.fileSize\n      });\n\n      return successResult;\n\n    } catch (error) {\n      const errorResult: IErrorResult = {\n        success: false,\n        error: {\n          type: ErrorType.BUILD_ERROR,\n          message: error instanceof Error ? error.message : 'Unknown build error',\n          stack: error instanceof Error ? error.stack || '' : ''\n        }\n      };\n\n      this.emitEvent(BuilderEventType.BUILD_ERROR, { error: errorResult.error });\n      return errorResult;\n\n    } finally {\n      this.isBuilding = false;\n    }\n  }\n\n  /**\n   * Generate and download the file (Browser only)\n   * \n   * Builds the Excel file and automatically triggers a download in the user's browser.\n   * This is the simplest method for browser environments - just one method call!\n   * \n   * **Note**: This method is designed for browser environments. For Node.js, use `saveToFile()` instead.\n   * \n   * @param {string} fileName - Name of the file to download (e.g., 'report.xlsx')\n   * @param {IDownloadOptions} [options={}] - Download options\n   * @param {string} [options.mimeType] - MIME type (default: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')\n   * @param {number} [options.compressionLevel=6] - Compression level (0-9)\n   * @param {boolean} [options.includeStyles=true] - Include cell styles\n   * \n   * @returns {Promise<Result<void>>} Result indicating success or failure\n   * \n   * @example\n   * ```typescript\n   * // Simple download\n   * const result = await builder.generateAndDownload('sales-report.xlsx');\n   * \n   * if (result.success) {\n   *   console.log('File downloaded successfully!');\n   * } else {\n   *   console.error('Download failed:', result.error);\n   * }\n   * \n   * // With options\n   * await builder.generateAndDownload('report.xlsx', {\n   *   compressionLevel: 9,\n   *   mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n   * });\n   * ```\n   */\n  async generateAndDownload(fileName: string, options: IDownloadOptions = {}): Promise<Result<void>> {\n    const buildResult = await this.build(options);\n    \n    if (!buildResult.success) {\n      return buildResult;\n    }\n\n    try {\n      this.emitEvent(BuilderEventType.DOWNLOAD_STARTED, { fileName });\n      \n      const blob = new Blob([buildResult.data], { \n        type: options.mimeType || 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' \n      });\n      \n      saveAs(blob, fileName);\n      \n      this.emitEvent(BuilderEventType.DOWNLOAD_COMPLETED, { fileName });\n      \n      return { success: true, data: undefined };\n\n    } catch (error) {\n      const errorResult: IErrorResult = {\n        success: false,\n        error: {\n          type: ErrorType.BUILD_ERROR,\n          message: error instanceof Error ? error.message : 'Download failed',\n          stack: error instanceof Error ? error.stack || '' : ''\n        }\n      };\n\n      this.emitEvent(BuilderEventType.DOWNLOAD_ERROR, { error: errorResult.error });\n      return errorResult;\n    }\n  }\n\n  /**\n   * Save file to disk (Node.js only)\n   * \n   * Builds the Excel file and saves it directly to the file system. This is the Node.js\n   * equivalent of `generateAndDownload()` - just as simple! Automatically creates parent\n   * directories if they don't exist.\n   * \n   * **Note**: This method only works in Node.js environments. For browsers, use `generateAndDownload()`.\n   * \n   * @param {string} filePath - Full path where to save the file (e.g., './output/report.xlsx')\n   * @param {ISaveFileOptions} [options={}] - Save options\n   * @param {boolean} [options.createDir=true] - Create parent directories if they don't exist\n   * @param {string} [options.encoding='binary'] - File encoding ('binary', 'base64', etc.)\n   * @param {number} [options.compressionLevel=6] - Compression level (0-9)\n   * @param {boolean} [options.includeStyles=true] - Include cell styles\n   * \n   * @returns {Promise<Result<void>>} Result indicating success or failure\n   * \n   * @throws {Error} If called in browser environment (use `generateAndDownload()` instead)\n   * @throws {Error} If Node.js modules (fs, path, buffer) are not available\n   * \n   * @example\n   * ```typescript\n   * // Simple save - creates directories automatically\n   * const result = await builder.saveToFile('./output/report.xlsx');\n   * \n   * if (result.success) {\n   *   console.log('File saved successfully!');\n   * }\n   * \n   * // With options\n   * await builder.saveToFile('./reports/sales.xlsx', {\n   *   createDir: true,  // Create ./reports/ if it doesn't exist\n   *   encoding: 'binary',\n   *   compressionLevel: 9\n   * });\n   * ```\n   */\n  async saveToFile(filePath: string, options: ISaveFileOptions = {}): Promise<Result<void>> {\n    const buildResult = await this.build(options);\n    \n    if (!buildResult.success) {\n      return buildResult;\n    }\n\n    try {\n      // Check if we're in Node.js\n      if (typeof window !== 'undefined') {\n        const errorResult: IErrorResult = {\n          success: false,\n          error: {\n            type: ErrorType.BUILD_ERROR,\n            message: 'saveToFile() is only available in Node.js. Use generateAndDownload() in the browser.',\n            stack: ''\n          }\n        };\n        return errorResult;\n      }\n\n      this.emitEvent(BuilderEventType.DOWNLOAD_STARTED, { fileName: filePath });\n      \n      // Dynamic import of Node.js modules to avoid issues in browser builds\n      // Use eval to prevent bundlers from trying to bundle these modules\n      const nodeModules = await (async () => {\n        try {\n          // @ts-ignore - Dynamic import for Node.js only\n          const fs = await import('fs/promises');\n          // @ts-ignore - Dynamic import for Node.js only\n          const path = await import('path');\n          // @ts-ignore - Dynamic import for Node.js only\n          const buffer = await import('buffer');\n          return { fs, path, Buffer: buffer.Buffer };\n        } catch {\n          throw new Error('Node.js modules not available. saveToFile() requires Node.js environment.');\n        }\n      })();\n      \n      // Create directory if needed\n      if (options.createDir !== false) {\n        const dir = nodeModules.path.dirname(filePath);\n        try {\n          await nodeModules.fs.mkdir(dir, { recursive: true });\n        } catch (error: any) {\n          // Ignore error if directory already exists\n          if (error?.code !== 'EEXIST') {\n            throw error;\n          }\n        }\n      }\n      \n      // Convert ArrayBuffer to Buffer and write to file\n      const buffer = nodeModules.Buffer.from(buildResult.data);\n      await nodeModules.fs.writeFile(filePath, buffer, { encoding: options.encoding || 'binary' });\n      \n      this.emitEvent(BuilderEventType.DOWNLOAD_COMPLETED, { fileName: filePath });\n      \n      return { success: true, data: undefined };\n\n    } catch (error) {\n      const errorResult: IErrorResult = {\n        success: false,\n        error: {\n          type: ErrorType.BUILD_ERROR,\n          message: error instanceof Error ? error.message : 'Failed to save file',\n          stack: error instanceof Error ? error.stack || '' : ''\n        }\n      };\n\n      this.emitEvent(BuilderEventType.DOWNLOAD_ERROR, { error: errorResult.error });\n      return errorResult;\n    }\n  }\n\n  /**\n   * Save to stream (Node.js only) - For large files\n   * \n   * Builds the Excel file and writes it directly to a writable stream. This is ideal\n   * for very large files or when you need to stream the data (e.g., HTTP responses,\n   * file uploads, etc.).\n   * \n   * **Note**: This method only works in Node.js environments.\n   * \n   * @param {NodeJS.WritableStream} writeStream - Writable stream to write the file to\n   * @param {IBuildOptions} [options={}] - Build options\n   * @param {number} [options.compressionLevel=6] - Compression level (0-9)\n   * @param {boolean} [options.includeStyles=true] - Include cell styles\n   * \n   * @returns {Promise<Result<void>>} Result indicating success or failure\n   * \n   * @throws {Error} If called in browser environment\n   * \n   * @example\n   * ```typescript\n   * import fs from 'fs';\n   * \n   * // Save to file stream\n   * const writeStream = fs.createWriteStream('./output/report.xlsx');\n   * const result = await builder.saveToStream(writeStream);\n   * \n   * if (result.success) {\n   *   writeStream.end();\n   *   console.log('File streamed successfully!');\n   * }\n   * \n   * // HTTP response stream\n   * app.get('/download', async (req, res) => {\n   *   res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');\n   *   await builder.saveToStream(res);\n   * });\n   * ```\n   */\n  async saveToStream(writeStream: { write: (chunk: any, callback?: (error?: Error | null) => void) => boolean }, options: IBuildOptions = {}): Promise<Result<void>> {\n    const buildResult = await this.build(options);\n    \n    if (!buildResult.success) {\n      return buildResult;\n    }\n\n    try {\n      // Check if we're in Node.js\n      if (typeof window !== 'undefined') {\n        const errorResult: IErrorResult = {\n          success: false,\n          error: {\n            type: ErrorType.BUILD_ERROR,\n            message: 'saveToStream() is only available in Node.js.',\n            stack: ''\n          }\n        };\n        return errorResult;\n      }\n\n      this.emitEvent(BuilderEventType.DOWNLOAD_STARTED, { fileName: 'stream' });\n      \n      // Dynamic import of Node.js buffer module\n      // @ts-ignore - Dynamic import for Node.js only\n      const bufferModule = await import('buffer');\n      const buffer = bufferModule.Buffer.from(buildResult.data);\n      \n      return new Promise((resolve) => {\n        writeStream.write(buffer, (error: any) => {\n          if (error) {\n            const errorResult: IErrorResult = {\n              success: false,\n              error: {\n                type: ErrorType.BUILD_ERROR,\n                message: error.message || 'Failed to write to stream',\n                stack: error.stack || ''\n              }\n            };\n            this.emitEvent(BuilderEventType.DOWNLOAD_ERROR, { error: errorResult.error });\n            resolve(errorResult);\n          } else {\n            this.emitEvent(BuilderEventType.DOWNLOAD_COMPLETED, { fileName: 'stream' });\n            resolve({ success: true, data: undefined });\n          }\n        });\n      });\n\n    } catch (error) {\n      const errorResult: IErrorResult = {\n        success: false,\n        error: {\n          type: ErrorType.BUILD_ERROR,\n          message: error instanceof Error ? error.message : 'Failed to save to stream',\n          stack: error instanceof Error ? error.stack || '' : ''\n        }\n      };\n\n      this.emitEvent(BuilderEventType.DOWNLOAD_ERROR, { error: errorResult.error });\n      return errorResult;\n    }\n  }\n\n  /**\n   * Get workbook as ArrayBuffer\n   * \n   * Builds the Excel file and returns it as an ArrayBuffer. This is useful when you need\n   * the raw binary data for custom handling (e.g., sending via WebSocket, processing with\n   * other libraries, manual file operations, etc.).\n   * \n   * Works in both browser and Node.js environments.\n   * \n   * @param {IBuildOptions} [options={}] - Build options\n   * @param {number} [options.compressionLevel=6] - Compression level (0-9)\n   * @param {boolean} [options.includeStyles=true] - Include cell styles\n   * \n   * @returns {Promise<Result<ArrayBuffer>>} Result containing the Excel file as ArrayBuffer\n   * \n   * @example\n   * ```typescript\n   * // Browser: Get buffer for custom handling\n   * const result = await builder.toBuffer();\n   * if (result.success) {\n   *   const buffer = result.data;\n   *   // Upload to server, send via WebSocket, etc.\n   * }\n   * \n   * // Node.js: Get buffer for manual file write\n   * const result = await builder.toBuffer();\n   * if (result.success) {\n   *   const fs = await import('fs/promises');\n   *   await fs.writeFile('./report.xlsx', Buffer.from(result.data));\n   * }\n   * ```\n   */\n  async toBuffer(options: IBuildOptions = {}): Promise<Result<ArrayBuffer>> {\n    return this.build(options);\n  }\n\n  /**\n   * Get workbook as Blob\n   * \n   * Builds the Excel file and returns it as a Blob object. This is useful in browser\n   * environments when you need to upload to a server, create object URLs for preview,\n   * or handle the file programmatically without triggering an automatic download.\n   * \n   * **Note**: Blob is a browser API. In Node.js, use `toBuffer()` instead.\n   * \n   * @param {IBuildOptions} [options={}] - Build options\n   * @param {number} [options.compressionLevel=6] - Compression level (0-9)\n   * @param {boolean} [options.includeStyles=true] - Include cell styles\n   * \n   * @returns {Promise<Result<Blob>>} Result containing the Excel file as Blob\n   * \n   * @example\n   * ```typescript\n   * // Get as Blob for upload\n   * const result = await builder.toBlob();\n   * if (result.success) {\n   *   const blob = result.data;\n   *   \n   *   // Upload to server\n   *   const formData = new FormData();\n   *   formData.append('file', blob, 'report.xlsx');\n   *   await fetch('/api/upload', { method: 'POST', body: formData });\n   *   \n   *   // Or create preview URL\n   *   const url = URL.createObjectURL(blob);\n   *   window.open(url);\n   * }\n   * ```\n   */\n  async toBlob(options: IBuildOptions = {}): Promise<Result<Blob>> {\n    const buildResult = await this.build(options);\n    \n    if (!buildResult.success) {\n      return buildResult;\n    }\n\n    const blob = new Blob([buildResult.data], { \n      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' \n    });\n    \n    return { success: true, data: blob };\n  }\n\n  /**\n   * Validate the workbook\n   * \n   * Performs validation checks on the workbook to ensure it's ready for building.\n   * Validates that worksheets exist and each worksheet is valid.\n   * \n   * @returns {Result<boolean>} Result indicating if the workbook is valid\n   * - `success: true` - Workbook is valid and ready to build\n   * - `success: false` - Validation errors found (check `error.message` for details)\n   * \n   * @example\n   * ```typescript\n   * const validation = builder.validate();\n   * if (!validation.success) {\n   *   console.error('Validation errors:', validation.error?.message);\n   *   return;\n   * }\n   * \n   * // Safe to build\n   * await builder.build();\n   * ```\n   */\n  validate(): Result<boolean> {\n    const errors: string[] = [];\n    \n    if (this.worksheets.size === 0) {\n      errors.push('No worksheets found');\n    }\n\n    // Validate each worksheet\n    for (const [name, worksheet] of this.worksheets.entries()) {\n      const worksheetValidation = (worksheet as Worksheet).validate();\n      if (!worksheetValidation.success) {\n        errors.push(`Worksheet \"${name}\": ${worksheetValidation.error?.message}`);\n      }\n    }\n\n    if (errors.length > 0) {\n      return {\n        success: false,\n        error: {\n          type: ErrorType.VALIDATION_ERROR,\n          message: errors.join('; '),\n          stack: new Error().stack || ''\n        }\n      };\n    }\n\n    return { success: true, data: true };\n  }\n\n  /**\n   * Clear all worksheets and reset the builder\n   * \n   * Removes all worksheets, clears predefined cell styles, resets the theme,\n   * and clears the current worksheet. This effectively resets the builder to\n   * its initial state.\n   * \n   * @returns {void}\n   * \n   * @example\n   * ```typescript\n   * // Clear everything and start fresh\n   * builder.clear();\n   * \n   * // Now add new worksheets\n   * builder.addWorksheet('NewSheet');\n   * ```\n   */\n  clear(): void {\n    this.worksheets.clear();\n    this.currentWorksheet = undefined;\n    this.cellStyles.clear();\n    this.theme = undefined;\n  }\n\n  /**\n   * Get workbook statistics\n   * \n   * Returns build statistics including build time, file size, number of worksheets,\n   * cells, styles used, and performance metrics. Statistics are updated after each build.\n   * \n   * @returns {IBuildStats} Statistics object containing:\n   * - `totalWorksheets` - Number of worksheets\n   * - `totalCells` - Total number of cells\n   * - `memoryUsage` - Memory usage in bytes\n   * - `buildTime` - Last build time in milliseconds\n   * - `fileSize` - Last build file size in bytes\n   * - `stylesUsed` - Number of unique styles used\n   * - `formulasUsed` - Number of formulas\n   * - `conditionalFormatsUsed` - Number of conditional formats\n   * - `performance` - Performance breakdown by operation\n   * \n   * @example\n   * ```typescript\n   * await builder.build();\n   * const stats = builder.getStats();\n   * \n   * console.log(`Build time: ${stats.buildTime}ms`);\n   * console.log(`File size: ${stats.fileSize} bytes`);\n   * console.log(`Worksheets: ${stats.totalWorksheets}`);\n   * ```\n   */\n  getStats(): IBuildStats {\n    return { ...this.stats };\n  }\n\n  /**\n   * Add a predefined cell style\n   * \n   * Defines a reusable cell style that can be referenced by name in cells using\n   * the `styleName` property. This is useful for maintaining consistent styling\n   * across the workbook and reducing code duplication.\n   * \n   * Styles are stored at the workbook level and can be used in any worksheet.\n   * \n   * @param {string} name - Unique name for the style (used to reference it later)\n   * @param {IStyle} style - Style object created with StyleBuilder\n   * @returns {this} Returns the builder instance for method chaining\n   * \n   * @example\n   * ```typescript\n   * // Define reusable styles\n   * builder.addCellStyle('headerStyle', StyleBuilder.create()\n   *   .font({ name: 'Arial', size: 14, bold: true })\n   *   .fill({ backgroundColor: '#4472C4' })\n   *   .fontColor('#FFFFFF')\n   *   .build()\n   * );\n   * \n   * // Use in cells\n   * worksheet.addHeader({\n   *   key: 'title',\n   *   value: 'Report',\n   *   type: CellType.STRING,\n   *   styleName: 'headerStyle' // Reference the predefined style\n   * });\n   * ```\n   */\n  addCellStyle(name: string, style: import('../types/style.types').IStyle): this {\n    this.cellStyles.set(name, style);\n    return this;\n  }\n\n  /**\n   * Get a predefined cell style by name\n   * \n   * Retrieves a previously defined cell style by its name. Returns undefined\n   * if the style doesn't exist.\n   * \n   * @param {string} name - Name of the style to retrieve\n   * @returns {IStyle | undefined} The style if found, undefined otherwise\n   * \n   * @example\n   * ```typescript\n   * const style = builder.getCellStyle('headerStyle');\n   * if (style) {\n   *   console.log('Style found:', style);\n   * }\n   * ```\n   */\n  getCellStyle(name: string): import('../types/style.types').IStyle | undefined {\n    return this.cellStyles.get(name);\n  }\n\n  /**\n   * Set workbook theme\n   * \n   * Applies a color and font theme to the entire workbook. Themes affect all\n   * worksheets and can automatically apply styles to table sections (header, body, footer)\n   * if `autoApplySectionStyles` is enabled.\n   * \n   * Themes include:\n   * - Color palette (dark1, light1, dark2, light2, accent1-6, hyperlink colors)\n   * - Font families (major and minor fonts for latin, eastAsian, complexScript)\n   * - Optional section styles for automatic styling\n   * \n   * @param {IWorkbookTheme} theme - Theme configuration object\n   * @param {string} [theme.name] - Theme name\n   * @param {object} [theme.colors] - Color palette\n   * @param {object} [theme.fonts] - Font configuration\n   * @param {object} [theme.sectionStyles] - Styles for table sections\n   * @param {boolean} [theme.autoApplySectionStyles=true] - Auto-apply section styles\n   * \n   * @returns {this} Returns the builder instance for method chaining\n   * \n   * @example\n   * ```typescript\n   * builder.setTheme({\n   *   name: 'Corporate Theme',\n   *   colors: {\n   *     dark1: '#000000',\n   *     light1: '#FFFFFF',\n   *     accent1: '#4472C4',\n   *     accent2: '#ED7D31'\n   *   },\n   *   fonts: {\n   *     major: { latin: 'Calibri' },\n   *     minor: { latin: 'Calibri' }\n   *   },\n   *   autoApplySectionStyles: true\n   * });\n   * ```\n   */\n  setTheme(theme: IWorkbookTheme): this {\n    this.theme = theme;\n    return this;\n  }\n\n  /**\n   * Get current workbook theme\n   * \n   * Retrieves the currently active theme, if one has been set.\n   * \n   * @returns {IWorkbookTheme | undefined} The current theme, or undefined if no theme is set\n   * \n   * @example\n   * ```typescript\n   * const theme = builder.getTheme();\n   * if (theme) {\n   *   console.log('Active theme:', theme.name);\n   * }\n   * ```\n   */\n  getTheme(): IWorkbookTheme | undefined {\n    return this.theme;\n  }\n\n  /**\n   * Register an event listener\n   * \n   * Subscribes to builder events to monitor the build process. Returns a listener ID\n   * that can be used to remove the listener later.\n   * \n   * Available events:\n   * - `build:started` - Build process started\n   * - `build:completed` - Build completed successfully\n   * - `build:error` - Build failed with error\n   * - `download:started` - File download/save started\n   * - `download:completed` - File download/save completed\n   * - `download:error` - File download/save failed\n   * - `worksheet:added` - New worksheet added\n   * - `worksheet:removed` - Worksheet removed\n   * \n   * @param {BuilderEventType} eventType - Type of event to listen for\n   * @param {(event: IBuilderEvent) => void} listener - Callback function to execute when event fires\n   * @returns {string} Listener ID (use with `off()` to remove the listener)\n   * \n   * @example\n   * ```typescript\n   * const listenerId = builder.on('build:started', (event) => {\n   *   console.log('Build started at', event.timestamp);\n   * });\n   * \n   * builder.on('build:completed', (event) => {\n   *   console.log('Build completed:', event.data);\n   * });\n   * \n   * builder.on('build:error', (event) => {\n   *   console.error('Build error:', event.data.error);\n   * });\n   * ```\n   */\n  on(eventType: BuilderEventType, listener: (event: IBuilderEvent) => void): string {\n    return this.eventEmitter.on(eventType, listener);\n  }\n\n  /**\n   * Remove an event listener\n   * \n   * Unsubscribes from a specific event by removing the listener with the given ID.\n   * \n   * @param {BuilderEventType} eventType - Type of event\n   * @param {string} listenerId - Listener ID returned from `on()`\n   * @returns {boolean} True if the listener was found and removed, false otherwise\n   * \n   * @example\n   * ```typescript\n   * const listenerId = builder.on('build:started', handler);\n   * \n   * // Later, remove the listener\n   * builder.off('build:started', listenerId);\n   * ```\n   */\n  off(eventType: BuilderEventType, listenerId: string): boolean {\n    return this.eventEmitter.off(eventType, listenerId);\n  }\n\n  /**\n   * Remove all event listeners\n   * \n   * Removes all listeners for a specific event type, or all listeners for all events\n   * if no event type is specified.\n   * \n   * @param {BuilderEventType} [eventType] - Event type to clear listeners for. If omitted, clears all listeners\n   * @returns {void}\n   * \n   * @example\n   * ```typescript\n   * // Remove all listeners for 'build:started' event\n   * builder.removeAllListeners('build:started');\n   * \n   * // Remove all listeners for all events\n   * builder.removeAllListeners();\n   * ```\n   */\n  removeAllListeners(eventType?: BuilderEventType): void {\n    if (eventType) {\n      this.eventEmitter.offAll(eventType);\n    } else {\n      this.eventEmitter.clear();\n    }\n  }\n\n  /**\n   * Private methods\n   */\n  \n  /**\n   * Emit an event to all registered listeners\n   * @private\n   */\n  private emitEvent(type: BuilderEventType, data?: Record<string, unknown>): void {\n    const event: IBuilderEvent = {\n      type,\n      data: data || {},\n      timestamp: new Date()\n    };\n    this.eventEmitter.emitSync(event);\n  }\n\n  /**\n   * Initialize build statistics\n   * @private\n   */\n  private initializeStats(): IBuildStats {\n    return {\n      totalWorksheets: 0,\n      totalCells: 0,\n      memoryUsage: 0,\n      buildTime: 0,\n      fileSize: 0,\n      stylesUsed: 0,\n      formulasUsed: 0,\n      conditionalFormatsUsed: 0,\n      performance: {\n        headersTime: 0,\n        dataTime: 0,\n        stylesTime: 0,\n        writeTime: 0\n      }\n    };\n  }\n\n  /**\n   * Apply theme to workbook\n   * \n   * Internal method that applies the theme configuration to the ExcelJS workbook.\n   * Converts theme colors and fonts to ExcelJS format.\n   * \n   * @private\n   * @param {ExcelJS.Workbook} workbook - ExcelJS workbook instance\n   * @param {IWorkbookTheme} theme - Theme configuration\n   */\n  private applyTheme(workbook: ExcelJS.Workbook, theme: IWorkbookTheme): void {\n    if (!workbook.model) {\n      return;\n    }\n\n    // ExcelJS theme structure\n    const excelTheme: any = {\n      name: theme.name || 'Custom Theme'\n    };\n\n    if (theme.colors) {\n      excelTheme.colors = {};\n      if (theme.colors.dark1) excelTheme.colors.dark1 = this.convertColorToTheme(theme.colors.dark1);\n      if (theme.colors.light1) excelTheme.colors.light1 = this.convertColorToTheme(theme.colors.light1);\n      if (theme.colors.dark2) excelTheme.colors.dark2 = this.convertColorToTheme(theme.colors.dark2);\n      if (theme.colors.light2) excelTheme.colors.light2 = this.convertColorToTheme(theme.colors.light2);\n      if (theme.colors.accent1) excelTheme.colors.accent1 = this.convertColorToTheme(theme.colors.accent1);\n      if (theme.colors.accent2) excelTheme.colors.accent2 = this.convertColorToTheme(theme.colors.accent2);\n      if (theme.colors.accent3) excelTheme.colors.accent3 = this.convertColorToTheme(theme.colors.accent3);\n      if (theme.colors.accent4) excelTheme.colors.accent4 = this.convertColorToTheme(theme.colors.accent4);\n      if (theme.colors.accent5) excelTheme.colors.accent5 = this.convertColorToTheme(theme.colors.accent5);\n      if (theme.colors.accent6) excelTheme.colors.accent6 = this.convertColorToTheme(theme.colors.accent6);\n      if (theme.colors.hyperlink) excelTheme.colors.hyperlink = this.convertColorToTheme(theme.colors.hyperlink);\n      if (theme.colors.followedHyperlink) excelTheme.colors.followedHyperlink = this.convertColorToTheme(theme.colors.followedHyperlink);\n    }\n\n    if (theme.fonts) {\n      excelTheme.fonts = {};\n      if (theme.fonts.major) {\n        excelTheme.fonts.major = {\n          latin: theme.fonts.major.latin || 'Calibri',\n          eastAsian: theme.fonts.major.eastAsian || theme.fonts.major.latin || 'Calibri',\n          complexScript: theme.fonts.major.complexScript || theme.fonts.major.latin || 'Calibri'\n        };\n      }\n      if (theme.fonts.minor) {\n        excelTheme.fonts.minor = {\n          latin: theme.fonts.minor.latin || 'Calibri',\n          eastAsian: theme.fonts.minor.eastAsian || theme.fonts.minor.latin || 'Calibri',\n          complexScript: theme.fonts.minor.complexScript || theme.fonts.minor.latin || 'Calibri'\n        };\n      }\n    }\n\n    // Apply theme to workbook (ExcelJS stores theme in model)\n    (workbook as any).model = (workbook as any).model || {};\n    (workbook as any).model.theme = excelTheme;\n  }\n\n  /**\n   * Convert color to theme format\n   * \n   * Converts a Color value (hex string, RGB object, or theme color) to the format\n   * expected by ExcelJS themes (hex string without #).\n   * \n   * @private\n   * @param {Color} color - Color to convert\n   * @returns {string} Hex color string without # prefix\n   */\n  private convertColorToTheme(color: Color): string {\n    if (typeof color === 'string') {\n      // Remove # if present\n      return color.startsWith('#') ? color.substring(1) : color;\n    }\n    if ('r' in color && 'g' in color && 'b' in color) {\n      return `${color.r.toString(16).padStart(2, '0')}${color.g.toString(16).padStart(2, '0')}${color.b.toString(16).padStart(2, '0')}`;\n    }\n    return '000000';\n  }\n\n  /**\n   * Add style to workbook\n   * \n   * Stores a predefined style in the workbook so it can be accessed during worksheet\n   * building. ExcelJS doesn't support named styles directly, so we store them in a custom\n   * property that worksheets can access when building cells.\n   * \n   * @private\n   * @param {ExcelJS.Workbook} workbook - ExcelJS workbook instance\n   * @param {string} name - Style name\n   * @param {IStyle} style - Style object\n   * \n   * @remarks\n   * ExcelJS applies styles per cell, not as named styles. This method stores styles\n   * in a way that worksheets can retrieve them when building cells that reference\n   * the style by name.\n   */\n  private addStyleToWorkbook(workbook: ExcelJS.Workbook, name: string, style: import('../types/style.types').IStyle): void {\n    (workbook as any).__customStyles = (workbook as any).__customStyles || {};\n    (workbook as any).__customStyles[name] = style;\n  }\n} ","/**\r\n * Types for Excel Reader functionality\r\n */\r\n\r\nimport { Result } from './core.types';\r\n\r\n/**\r\n * Output format types\r\n */\r\nexport enum OutputFormat {\r\n  /** Format by worksheet (structured with sheets, rows, cells) */\r\n  WORKSHEET = 'worksheet',\r\n  /** Detailed format with text, column, row information */\r\n  DETAILED = 'detailed',\r\n  /** Flat format - just the data without structure */\r\n  FLAT = 'flat'\r\n}\r\n\r\n/**\r\n * Mapper function types for different output formats\r\n */\r\nexport type WorksheetMapper = (data: IJsonWorkbook) => unknown;\r\nexport type DetailedMapper = (data: IDetailedFormat) => unknown;\r\nexport type FlatMapper = (data: IFlatFormat | IFlatFormatMultiSheet) => unknown;\r\n\r\n/**\r\n * Options for reading Excel files\r\n */\r\nexport interface IExcelReaderOptions {\r\n  /** Output format (default: 'worksheet') */\r\n  outputFormat?: OutputFormat | 'worksheet' | 'detailed' | 'flat';\r\n  /** Mapper function to transform the response data */\r\n  mapper?: WorksheetMapper | DetailedMapper | FlatMapper;\r\n  /** Whether to include empty rows */\r\n  includeEmptyRows?: boolean;\r\n  /** Whether to use first row as headers */\r\n  useFirstRowAsHeaders?: boolean;\r\n  /** Custom headers mapping (column index -> header name) */\r\n  headers?: string[] | Record<number, string>;\r\n  /** Sheet name or index to read (if not specified, reads all sheets) */\r\n  sheetName?: string | number;\r\n  /** Starting row (1-based, default: 1) */\r\n  startRow?: number;\r\n  /** Ending row (1-based, if not specified, reads until end) */\r\n  endRow?: number;\r\n  /** Starting column (1-based, default: 1) */\r\n  startColumn?: number;\r\n  /** Ending column (1-based, if not specified, reads until end) */\r\n  endColumn?: number;\r\n  /** Whether to include cell formatting information */\r\n  includeFormatting?: boolean;\r\n  /** Whether to include formulas */\r\n  includeFormulas?: boolean;\r\n  /** Date format for date cells */\r\n  dateFormat?: string;\r\n  /** Whether to convert dates to ISO strings */\r\n  datesAsISO?: boolean;\r\n}\r\n\r\n/**\r\n * Cell data in JSON format\r\n */\r\nexport interface IJsonCell {\r\n  /** Cell value */\r\n  value: unknown;\r\n  /** Cell type */\r\n  type?: string;\r\n  /** Cell reference (e.g., A1) */\r\n  reference?: string;\r\n  /** Formatted value (if includeFormatting is true) */\r\n  formattedValue?: string;\r\n  /** Formula (if includeFormulas is true) */\r\n  formula?: string;\r\n  /** Cell comment */\r\n  comment?: string;\r\n}\r\n\r\n/**\r\n * Row data in JSON format\r\n */\r\nexport interface IJsonRow {\r\n  /** Row number (1-based) */\r\n  rowNumber: number;\r\n  /** Cells in the row */\r\n  cells: IJsonCell[];\r\n  /** Row as object (if useFirstRowAsHeaders is true) */\r\n  data?: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * Sheet data in JSON format\r\n */\r\nexport interface IJsonSheet {\r\n  /** Sheet name */\r\n  name: string;\r\n  /** Sheet index */\r\n  index: number;\r\n  /** Rows in the sheet */\r\n  rows: IJsonRow[];\r\n  /** Headers (if useFirstRowAsHeaders is true) */\r\n  headers?: string[];\r\n  /** Total number of rows */\r\n  totalRows: number;\r\n  /** Total number of columns */\r\n  totalColumns: number;\r\n}\r\n\r\n/**\r\n * Workbook data in JSON format\r\n */\r\nexport interface IJsonWorkbook {\r\n  /** Workbook metadata */\r\n  metadata?: {\r\n    title?: string;\r\n    author?: string;\r\n    company?: string;\r\n    created?: Date | string;\r\n    modified?: Date | string;\r\n    description?: string;\r\n  };\r\n  /** Sheets in the workbook */\r\n  sheets: IJsonSheet[];\r\n  /** Total number of sheets */\r\n  totalSheets: number;\r\n}\r\n\r\n/**\r\n * Detailed cell format - includes position information\r\n */\r\nexport interface IDetailedCell {\r\n  /** Cell value */\r\n  value: unknown;\r\n  /** Cell text (string representation) */\r\n  text: string;\r\n  /** Column number (1-based) */\r\n  column: number;\r\n  /** Column letter (e.g., A, B, C) */\r\n  columnLetter: string;\r\n  /** Row number (1-based) */\r\n  row: number;\r\n  /** Cell reference (e.g., A1) */\r\n  reference: string;\r\n  /** Sheet name */\r\n  sheet: string;\r\n  /** Cell type */\r\n  type?: string;\r\n  /** Formatted value (if includeFormatting is true) */\r\n  formattedValue?: string;\r\n  /** Formula (if includeFormulas is true) */\r\n  formula?: string;\r\n  /** Cell comment */\r\n  comment?: string;\r\n}\r\n\r\n/**\r\n * Detailed format result - array of cells with position\r\n */\r\nexport interface IDetailedFormat {\r\n  /** Array of all cells with detailed information */\r\n  cells: IDetailedCell[];\r\n  /** Total number of cells */\r\n  totalCells: number;\r\n  /** Workbook metadata */\r\n  metadata?: {\r\n    title?: string;\r\n    author?: string;\r\n    company?: string;\r\n    created?: Date | string;\r\n    modified?: Date | string;\r\n    description?: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Flat format result - just the data values\r\n */\r\nexport interface IFlatFormat {\r\n  /** Array of row data (as objects if useFirstRowAsHeaders is true, or as arrays) */\r\n  data: Array<Record<string, unknown> | unknown[]>;\r\n  /** Headers (if useFirstRowAsHeaders is true) */\r\n  headers?: string[];\r\n  /** Sheet name */\r\n  sheet?: string;\r\n  /** Total number of rows */\r\n  totalRows: number;\r\n}\r\n\r\n/**\r\n * Flat format result for multiple sheets\r\n */\r\nexport interface IFlatFormatMultiSheet {\r\n  /** Data organized by sheet name */\r\n  sheets: Record<string, IFlatFormat>;\r\n  /** Total number of sheets */\r\n  totalSheets: number;\r\n  /** Workbook metadata */\r\n  metadata?: {\r\n    title?: string;\r\n    author?: string;\r\n    company?: string;\r\n    created?: Date | string;\r\n    modified?: Date | string;\r\n    description?: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Reader result - generic type based on output format\r\n */\r\nexport type ExcelReaderResult<T extends OutputFormat = OutputFormat.WORKSHEET> = \r\n  T extends OutputFormat.DETAILED\r\n    ? Result<IDetailedFormat> & { processingTime?: number }\r\n    : T extends OutputFormat.FLAT\r\n    ? Result<IFlatFormat | IFlatFormatMultiSheet> & { processingTime?: number }\r\n    : Result<IJsonWorkbook> & { processingTime?: number };\r\n\r\n/**\r\n * Legacy reader result (for backward compatibility)\r\n */\r\nexport type IExcelReaderResult = Result<IJsonWorkbook> & {\r\n  /** Processing time in milliseconds */\r\n  processingTime?: number;\r\n}\r\n\r\n","/**\r\n * StyleBuilder - Fluent API for creating Excel styles\r\n */\r\n\r\nimport {\r\n  IStyle,\r\n  IBorder,\r\n  IConditionalFormat,\r\n  IStyleBuilder as IStyleBuilderInterface\r\n} from '../types/style.types';\r\nimport { \r\n  Color, \r\n  HorizontalAlignment,\r\n  VerticalAlignment,\r\n  BorderStyle, \r\n  FontStyle \r\n} from '../types/core.types';\r\n\r\n/**\r\n * StyleBuilder class providing a fluent API for creating Excel styles\r\n */\r\nexport class StyleBuilder implements IStyleBuilderInterface {\r\n  private style: Partial<IStyle> = {};\r\n\r\n  constructor() {\r\n    // Configuración por defecto: wrapText true y alineación al centro\r\n    this.style.alignment = {\r\n      horizontal: HorizontalAlignment.CENTER,\r\n      vertical: VerticalAlignment.MIDDLE,\r\n      wrapText: true,\r\n      shrinkToFit: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create a new StyleBuilder instance\r\n   */\r\n  static create(): StyleBuilder {\r\n    return new StyleBuilder();\r\n  }\r\n\r\n  /**\r\n   * Set font name\r\n   */\r\n  fontName(name: string): StyleBuilder {\r\n    if (!this.style.font) {\r\n      this.style.font = {};\r\n    }\r\n    this.style.font.name = name;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set font size\r\n   */\r\n  fontSize(size: number): StyleBuilder {\r\n    if (!this.style.font) {\r\n      this.style.font = {};\r\n    }\r\n    this.style.font.size = size;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set font style\r\n   */\r\n  fontStyle(style: FontStyle): StyleBuilder {\r\n    if (!this.style.font) {\r\n      this.style.font = {};\r\n    }\r\n    this.style.font.style = style;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set font color\r\n   */\r\n  fontColor(color: Color): StyleBuilder {\r\n    if (!this.style.font) {\r\n      this.style.font = {};\r\n    }\r\n    this.style.font.color = color;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Make font bold\r\n   */\r\n  fontBold(): StyleBuilder {\r\n    if (!this.style.font) {\r\n      this.style.font = {};\r\n    }\r\n    this.style.font.bold = true;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Make font italic\r\n   */\r\n  fontItalic(): StyleBuilder {\r\n    if (!this.style.font) {\r\n      this.style.font = {};\r\n    }\r\n    this.style.font.italic = true;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Make font underlined\r\n   */\r\n  fontUnderline(): StyleBuilder {\r\n    if (!this.style.font) {\r\n      this.style.font = {};\r\n    }\r\n    this.style.font.underline = true;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set border on all sides\r\n   */\r\n  border(style: BorderStyle, color?: Color): StyleBuilder {\r\n    if (!this.style.border) {\r\n      this.style.border = {};\r\n    }\r\n    const border: IBorder = { style };\r\n    if (color !== undefined) {\r\n      border.color = color;\r\n    }\r\n    this.style.border.top = border;\r\n    this.style.border.left = border;\r\n    this.style.border.bottom = border;\r\n    this.style.border.right = border;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set top border\r\n   */\r\n  borderTop(style: BorderStyle, color?: Color): StyleBuilder {\r\n    if (!this.style.border) {\r\n      this.style.border = {};\r\n    }\r\n    const border: IBorder = { style };\r\n    if (color !== undefined) {\r\n      border.color = color;\r\n    }\r\n    this.style.border.top = border;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set left border\r\n   */\r\n  borderLeft(style: BorderStyle, color?: Color): StyleBuilder {\r\n    if (!this.style.border) {\r\n      this.style.border = {};\r\n    }\r\n    const border: IBorder = { style };\r\n    if (color !== undefined) {\r\n      border.color = color;\r\n    }\r\n    this.style.border.left = border;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set bottom border\r\n   */\r\n  borderBottom(style: BorderStyle, color?: Color): StyleBuilder {\r\n    if (!this.style.border) {\r\n      this.style.border = {};\r\n    }\r\n    const border: IBorder = { style };\r\n    if (color !== undefined) {\r\n      border.color = color;\r\n    }\r\n    this.style.border.bottom = border;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set right border\r\n   */\r\n  borderRight(style: BorderStyle, color?: Color): StyleBuilder {\r\n    if (!this.style.border) {\r\n      this.style.border = {};\r\n    }\r\n    const border: IBorder = { style };\r\n    if (color !== undefined) {\r\n      border.color = color;\r\n    }\r\n    this.style.border.right = border;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set background color\r\n   */\r\n  backgroundColor(color: Color): StyleBuilder {\r\n    if (!this.style.fill) {\r\n      this.style.fill = { type: 'pattern' };\r\n    }\r\n    this.style.fill.backgroundColor = color;\r\n    this.style.fill.pattern = 'solid';\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set horizontal alignment\r\n   */\r\n  horizontalAlign(alignment: HorizontalAlignment): StyleBuilder {\r\n    if (!this.style.alignment) {\r\n      this.style.alignment = {};\r\n    }\r\n    this.style.alignment.horizontal = alignment;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set vertical alignment\r\n   */\r\n  verticalAlign(alignment: VerticalAlignment): StyleBuilder {\r\n    if (!this.style.alignment) {\r\n      this.style.alignment = {};\r\n    }\r\n    this.style.alignment.vertical = alignment;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Center align text\r\n   */\r\n  centerAlign(): StyleBuilder {\r\n    if (!this.style.alignment) {\r\n      this.style.alignment = {};\r\n    }\r\n    this.style.alignment.horizontal = HorizontalAlignment.CENTER;\r\n    this.style.alignment.vertical = VerticalAlignment.MIDDLE;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Left align text\r\n   */\r\n  leftAlign(): StyleBuilder {\r\n    if (!this.style.alignment) {\r\n      this.style.alignment = {};\r\n    }\r\n    this.style.alignment.horizontal = HorizontalAlignment.LEFT;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Right align text\r\n   */\r\n  rightAlign(): StyleBuilder {\r\n    if (!this.style.alignment) {\r\n      this.style.alignment = {};\r\n    }\r\n    this.style.alignment.horizontal = HorizontalAlignment.RIGHT;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Wrap text\r\n   */\r\n  wrapText(): StyleBuilder {\r\n    if (!this.style.alignment) {\r\n      this.style.alignment = {};\r\n    }\r\n    this.style.alignment.wrapText = true;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set number format\r\n   */\r\n  numberFormat(format: string): StyleBuilder {\r\n    this.style.numberFormat = format;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set striped rows\r\n   */\r\n  striped(): StyleBuilder {\r\n    this.style.striped = true;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add conditional formatting\r\n   */\r\n  conditionalFormat(format: IConditionalFormat): StyleBuilder {\r\n    if (!this.style.conditionalFormats) {\r\n      this.style.conditionalFormats = [];\r\n    }\r\n    this.style.conditionalFormats.push(format);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Build the final style\r\n   */\r\n  build(): IStyle {\r\n    return this.style as IStyle;\r\n  }\r\n\r\n  /**\r\n   * Reset the builder\r\n   */\r\n  reset(): StyleBuilder {\r\n    this.style = {};\r\n    // Restaurar configuración por defecto\r\n    this.style.alignment = {\r\n      horizontal: HorizontalAlignment.CENTER,\r\n      vertical: VerticalAlignment.MIDDLE,\r\n      wrapText: true\r\n    };\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Clone the current style\r\n   */\r\n  clone(): StyleBuilder {\r\n    const cloned = new StyleBuilder();\r\n    cloned.style = JSON.parse(JSON.stringify(this.style));\r\n    return cloned;\r\n  }\r\n} ","/**\n * Cell-specific type definitions\n */\n\nimport { IBaseCell } from './core.types';\nimport type { CellValue } from 'exceljs';\n\n/**\n * Header cell interface\n */\nexport interface IHeaderCell extends IBaseCell {\n  /** Reference to parent header key */\n  mainHeaderKey?: string;\n  /** Child headers */\n  children?: IHeaderCell[];\n  /** Whether this is a main header */\n  isMainHeader?: boolean;\n  /** Header level (1 = main, 2 = sub, etc.) */\n  level?: number;\n}\n\n/**\n * Data cell interface\n */\nexport interface IDataCell extends IBaseCell {\n  /** Reference to header key */\n  header: string;\n  /** Reference to main header key */\n  mainHeaderKey?: string;\n  /** Child data cells */\n  children?: IDataCell[];\n  /** Whether this cell has alternating row color */\n  striped?: boolean;\n  /** Row index */\n  rowIndex?: number;\n  /** Column index */\n  colIndex?: number;\n}\n\n/**\n * Footer cell interface\n */\nexport interface IFooterCell extends IBaseCell {\n  /** Reference to header key */\n  header: string;\n  /** Child footer cells */\n  children?: IDataCell[];\n  /** Whether this is a total row */\n  isTotal?: boolean;\n  /** Footer type */\n  footerType?: 'total' | 'subtotal' | 'average' | 'count' | 'custom';\n}\n\n/**\n * Cell position interface\n */\nexport interface ICellPosition {\n  /** Row index (1-based) */\n  row: number;\n  /** Column index (1-based) */\n  col: number;\n  /** Cell reference (e.g., A1) */\n  reference: string;\n}\n\n/**\n * Cell range interface\n */\nexport interface ICellRange {\n  /** Start position */\n  start: ICellPosition;\n  /** End position */\n  end: ICellPosition;\n  /** Range reference (e.g., A1:B10) */\n  reference: string;\n}\n\n/**\n * Cell data for different types\n */\nexport interface ICellData {\n  /** String cell data */\n  string?: {\n    value: string;\n    maxLength?: number;\n    trim?: boolean;\n  };\n  /** Number cell data */\n  number?: {\n    value: number;\n    min?: number;\n    max?: number;\n    precision?: number;\n    allowNegative?: boolean;\n  };\n  /** Date cell data */\n  date?: {\n    value: Date;\n    min?: Date;\n    max?: Date;\n    format?: string;\n  };\n  /** Boolean cell data */\n  boolean?: {\n    value: boolean;\n    trueText?: string;\n    falseText?: string;\n  };\n  /** Percentage cell data */\n  percentage?: {\n    value: number;\n    min?: number;\n    max?: number;\n    precision?: number;\n    showSymbol?: boolean;\n  };\n  /** Currency cell data */\n  currency?: {\n    value: number;\n    currency?: string;\n    precision?: number;\n    showSymbol?: boolean;\n  };\n  /** Link cell data */\n  link?: {\n    value: string;\n    text?: string;\n    tooltip?: string;\n  };\n  /** Formula cell data */\n  formula?: {\n    value: string;\n    result?: CellValue;\n  };\n}\n\n/**\n * Cell validation result\n */\nexport interface ICellValidationResult {\n  /** Whether the cell is valid */\n  isValid: boolean;\n  /** Validation errors */\n  errors: string[];\n  /** Validation warnings */\n  warnings: string[];\n}\n\n/**\n * Cell event types\n */\nexport enum CellEventType {\n  CREATED = 'created',\n  UPDATED = 'updated',\n  DELETED = 'deleted',\n  STYLED = 'styled',\n  VALIDATED = 'validated'\n}\n\n/**\n * Cell event interface\n */\nexport interface ICellEvent {\n  type: CellEventType;\n  cell: IDataCell | IHeaderCell | IFooterCell;\n  position: ICellPosition;\n  timestamp: Date;\n  data?: Record<string, unknown>;\n}\n\n/**\n * Rich text run interface (for formatted text within a cell)\n */\nexport interface IRichTextRun {\n  /** Text content */\n  text: string;\n  /** Font name */\n  font?: string;\n  /** Font size */\n  size?: number;\n  /** Font color */\n  color?: string | { r: number; g: number; b: number } | { theme: number };\n  /** Bold */\n  bold?: boolean;\n  /** Italic */\n  italic?: boolean;\n  /** Underline */\n  underline?: boolean;\n  /** Strikethrough */\n  strikethrough?: boolean;\n} ","/**\n * Worksheet-specific type definitions\n */\n\nimport { IHeaderCell, IDataCell, IFooterCell, ICellPosition, ICellRange } from './cell.types';\nimport { Color, Result } from './core.types';\n\n/**\n * Worksheet configuration interface\n */\nexport interface IWorksheetConfig {\n  /** Worksheet name */\n  name: string;\n  /** Tab color */\n  tabColor?: Color;\n  /** Default row height */\n  defaultRowHeight?: number;\n  /** Default column width */\n  defaultColWidth?: number;\n  /** Whether the worksheet is hidden */\n  hidden?: boolean;\n  /** Whether the worksheet is protected */\n  protected?: boolean;\n  /** Protection password */\n  protectionPassword?: string;\n  /** Whether to show grid lines */\n  showGridLines?: boolean;\n  /** Whether to show row and column headers */\n  showRowColHeaders?: boolean;\n  /** Zoom level (1-400) */\n  zoom?: number;\n  /** Freeze panes position */\n  freezePanes?: ICellPosition;\n  /** Print area */\n  printArea?: ICellRange;\n  /** Fit to page settings */\n  fitToPage?: {\n    fitToWidth?: number;\n    fitToHeight?: number;\n  };\n  /** Page setup */\n  pageSetup?: {\n    orientation?: 'portrait' | 'landscape';\n    paperSize?: number;\n    fitToPage?: boolean;\n    fitToWidth?: number;\n    fitToHeight?: number;\n    scale?: number;\n    horizontalCentered?: boolean;\n    verticalCentered?: boolean;\n    margins?: {\n      top?: number;\n      left?: number;\n      bottom?: number;\n      right?: number;\n      header?: number;\n      footer?: number;\n    };\n  };\n  /** Auto filter configuration */\n  autoFilter?: {\n    /** Enable auto filter for the worksheet */\n    enabled?: boolean;\n    /** Auto filter range (if not specified, applies to all data) */\n    range?: ICellRange;\n    /** Start row for auto filter (1-based, default: first data row) */\n    startRow?: number;\n    /** End row for auto filter (1-based, default: last data row) */\n    endRow?: number;\n    /** Start column for auto filter (1-based, default: 1) */\n    startColumn?: number;\n    /** End column for auto filter (1-based, default: last column) */\n    endColumn?: number;\n  };\n  /** Print headers/footers configuration */\n  printHeadersFooters?: {\n    /** Header text (left, center, right) */\n    header?: {\n      left?: string;\n      center?: string;\n      right?: string;\n    };\n    /** Footer text (left, center, right) */\n    footer?: {\n      left?: string;\n      center?: string;\n      right?: string;\n    };\n  };\n  /** Repeat rows/columns on each printed page */\n  printRepeat?: {\n    /** Rows to repeat (e.g., \"1:2\" or [1, 2]) */\n    rows?: string | number[];\n    /** Columns to repeat (e.g., \"A:B\" or [1, 2]) */\n    columns?: string | number[];\n  };\n  /** Split panes configuration (divides window into panes) */\n  splitPanes?: {\n    /** Horizontal split position (column number, 0 = no split) */\n    xSplit?: number;\n    /** Vertical split position (row number, 0 = no split) */\n    ySplit?: number;\n    /** Top-left cell in bottom-right pane */\n    topLeftCell?: string;\n    /** Active pane (topLeft, topRight, bottomLeft, bottomRight) */\n    activePane?: 'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight';\n  };\n  /** Sheet views configuration */\n  views?: {\n    /** View state (normal, pageBreakPreview, pageLayout) */\n    state?: 'normal' | 'pageBreakPreview' | 'pageLayout';\n    /** Zoom level (10-400) */\n    zoomScale?: number;\n    /** Normal zoom level */\n    zoomScaleNormal?: number;\n    /** Show grid lines */\n    showGridLines?: boolean;\n    /** Show row and column headers */\n    showRowColHeaders?: boolean;\n    /** Show ruler (page layout view) */\n    showRuler?: boolean;\n    /** Right-to-left */\n    rightToLeft?: boolean;\n  };\n}\n\n/**\n * Table structure interface\n */\nexport interface ITable {\n  /** Table name */\n  name?: string;\n  /** Table headers */\n  headers?: IHeaderCell[];\n  /** Table sub-headers */\n  subHeaders?: IHeaderCell[];\n  /** Table data rows */\n  body?: IDataCell[];\n  /** Table footers */\n  footers?: IFooterCell[];\n  /** Table range */\n  range?: ICellRange;\n  /** Whether to show table borders */\n  showBorders?: boolean;\n  /** Whether to show alternating row colors */\n  showStripes?: boolean;\n  /** Table style */\n  style?: 'TableStyleLight1' | 'TableStyleLight2' | 'TableStyleMedium1' | 'TableStyleMedium2' | 'TableStyleDark1' | 'TableStyleDark2';\n  /** Auto filter for this table */\n  autoFilter?: boolean;\n}\n\n/**\n * Worksheet interface\n */\nexport interface IWorksheet {\n  /** Worksheet configuration */\n  config: IWorksheetConfig;\n  /** Tables in the worksheet */\n  tables: ITable[];\n  /** Current row pointer */\n  currentRow: number;\n  /** Current column pointer */\n  currentCol: number;\n  /** Header pointers for navigation */\n  headerPointers: Map<string, ICellPosition>;\n  /** Whether the worksheet has been built */\n  isBuilt: boolean;\n\n  /** Add a header */\n  addHeader(header: IHeaderCell): this;\n  /** Add subheaders */\n  addSubHeaders(subHeaders: IHeaderCell[]): this;\n  /** Add a row or rows */\n  addRow(row: IDataCell[] | IDataCell): this;\n  /** Add a footer or footers */\n  addFooter(footer: IFooterCell[] | IFooterCell): this;\n  /** Add a new table to the worksheet */\n  addTable(tableConfig?: Partial<ITable>): this;\n  /** Finalize the current table with temporary data */\n  finalizeTable(): this;\n  /** Get a table by name */\n  getTable(name: string): ITable | undefined;\n  /** Add an image to the worksheet */\n  addImage(image: IWorksheetImage): this;\n  /** Group rows (create collapsible outline) */\n  groupRows(startRow: number, endRow: number, collapsed?: boolean): this;\n  /** Group columns (create collapsible outline) */\n  groupColumns(startCol: number, endCol: number, collapsed?: boolean): this;\n  /** Add a named range */\n  addNamedRange(name: string, range: string | ICellRange, scope?: string): this;\n  /** Add an Excel structured table */\n  addExcelTable(table: IExcelTable): this;\n  /** Hide rows */\n  hideRows(rows: number | number[]): this;\n  /** Show rows */\n  showRows(rows: number | number[]): this;\n  /** Hide columns */\n  hideColumns(columns: number | string | (number | string)[]): this;\n  /** Show columns */\n  showColumns(columns: number | string | (number | string)[]): this;\n  /** Add a pivot table */\n  addPivotTable(pivotTable: IPivotTable): this;\n  /** Add a slicer to a table or pivot table */\n  addSlicer(slicer: ISlicer): this;\n  /** Add a watermark to the worksheet */\n  addWatermark(watermark: IWatermark): this;\n  /** Add a data connection */\n  addDataConnection(connection: IDataConnection): this;\n  /** Build the worksheet */\n  build(workbook: any, options?: any): Promise<void>;\n  /** Validate the worksheet */\n  validate(): Result<boolean>;\n}\n\n/**\n * Worksheet event types\n */\nexport enum WorksheetEventType {\n  CREATED = 'created',\n  UPDATED = 'updated',\n  DELETED = 'deleted',\n  TABLE_ADDED = 'tableAdded',\n  TABLE_REMOVED = 'tableRemoved',\n  CELL_ADDED = 'cellAdded',\n  CELL_UPDATED = 'cellUpdated',\n  CELL_DELETED = 'cellDeleted'\n}\n\n/**\n * Worksheet event interface\n */\nexport interface IWorksheetEvent {\n  type: WorksheetEventType;\n  worksheet: IWorksheet;\n  data?: Record<string, unknown>;\n  timestamp: Date;\n}\n\n/**\n * Worksheet validation result\n */\nexport interface IWorksheetValidationResult {\n  /** Whether the worksheet is valid */\n  isValid: boolean;\n  /** Validation errors */\n  errors: string[];\n  /** Validation warnings */\n  warnings: string[];\n  /** Cell validation results */\n  cellResults: Map<string, boolean>;\n}\n\n/**\n * Worksheet statistics\n */\nexport interface IWorksheetStats {\n  /** Total number of cells */\n  totalCells: number;\n  /** Number of header cells */\n  headerCells: number;\n  /** Number of data cells */\n  dataCells: number;\n  /** Number of footer cells */\n  footerCells: number;\n  /** Number of tables */\n  tables: number;\n  /** Used range */\n  usedRange: ICellRange;\n  /** Memory usage in bytes */\n  memoryUsage: number;\n}\n\n/**\n * Image configuration for worksheet\n */\nexport interface IWorksheetImage {\n  /** Image buffer (ArrayBuffer, Uint8Array, or base64 string) */\n  buffer: ArrayBuffer | Uint8Array | string;\n  /** Image name/ID */\n  name?: string;\n  /** Image extension (png, jpeg, gif, etc.) */\n  extension: 'png' | 'jpeg' | 'jpg' | 'gif' | 'bmp' | 'webp';\n  /** Position - can be cell reference or absolute position */\n  position: {\n    /** Cell reference (e.g., 'A1') or row number (1-based) */\n    row: string | number;\n    /** Column letter (e.g., 'A') or column number (1-based) */\n    col: string | number;\n  };\n  /** Image size */\n  size?: {\n    /** Width in pixels or Excel units */\n    width?: number;\n    /** Height in pixels or Excel units */\n    height?: number;\n    /** Scale factor (0-1) */\n    scaleX?: number;\n    /** Scale factor (0-1) */\n    scaleY?: number;\n  };\n  /** Hyperlink for image (optional) */\n  hyperlink?: string;\n  /** Image description/alt text */\n  description?: string;\n}\n\n/**\n * Pivot table configuration\n */\nexport interface IPivotTable {\n  /** Pivot table name */\n  name: string;\n  /** Reference cell where pivot table starts (e.g., 'A1') */\n  ref: string;\n  /** Source data range (e.g., 'A1:D100') */\n  sourceRange: string;\n  /** Source worksheet name (if different from current) */\n  sourceSheet?: string;\n  /** Pivot table fields configuration */\n  fields: {\n    /** Rows fields */\n    rows?: string[];\n    /** Columns fields */\n    columns?: string[];\n    /** Values fields with aggregation function */\n    values?: Array<{\n      name: string;\n      stat: 'sum' | 'count' | 'average' | 'min' | 'max' | 'stdDev' | 'var';\n    }>;\n    /** Filters fields */\n    filters?: string[];\n  };\n  /** Pivot table options */\n  options?: {\n    /** Show grand totals for rows */\n    showRowGrandTotals?: boolean;\n    /** Show grand totals for columns */\n    showColGrandTotals?: boolean;\n    /** Show headers */\n    showHeaders?: boolean;\n  };\n}\n\n/**\n * Slicer configuration for tables and pivot tables\n */\nexport interface ISlicer {\n  /** Slicer name */\n  name: string;\n  /** Target table or pivot table name */\n  targetTable: string;\n  /** Column/field to create slicer for */\n  column: string;\n  /** Position where slicer should be placed */\n  position: {\n    /** Row number (1-based) */\n    row: number;\n    /** Column number or letter (1-based or 'A', 'B', etc.) */\n    col: number | string;\n  };\n  /** Slicer size */\n  size?: {\n    /** Width in pixels */\n    width?: number;\n    /** Height in pixels */\n    height?: number;\n  };\n  /** Slicer style */\n  style?: {\n    /** Caption style */\n    caption?: string;\n    /** Item style */\n    itemStyle?: string;\n  };\n}\n\n/**\n * Watermark configuration\n */\nexport interface IWatermark {\n  /** Watermark text */\n  text?: string;\n  /** Watermark image (alternative to text) */\n  image?: IWorksheetImage;\n  /** Position */\n  position?: {\n    /** Horizontal position: 'left' | 'center' | 'right' */\n    horizontal?: 'left' | 'center' | 'right';\n    /** Vertical position: 'top' | 'middle' | 'bottom' */\n    vertical?: 'top' | 'middle' | 'bottom';\n  };\n  /** Opacity (0-1) */\n  opacity?: number;\n  /** Rotation in degrees */\n  rotation?: number;\n  /** Font size (if using text) */\n  fontSize?: number;\n  /** Font color (if using text) */\n  fontColor?: string;\n}\n\n/**\n * Data connection configuration\n */\nexport interface IDataConnection {\n  /** Connection name */\n  name: string;\n  /** Connection type */\n  type: 'odbc' | 'oledb' | 'web' | 'text' | 'xml';\n  /** Connection string or URL */\n  connectionString: string;\n  /** Command text (SQL query, etc.) */\n  commandText?: string;\n  /** Refresh settings */\n  refresh?: {\n    /** Auto refresh on open */\n    refreshOnOpen?: boolean;\n    /** Refresh interval in minutes */\n    refreshInterval?: number;\n  };\n  /** Credentials */\n  credentials?: {\n    /** Username */\n    username?: string;\n    /** Password */\n    password?: string;\n    /** Integrated security */\n    integratedSecurity?: boolean;\n  };\n}\n\n/**\n * Excel structured table configuration\n */\nexport interface IExcelTable {\n  /** Table name */\n  name: string;\n  /** Table range (start and end cells) */\n  range: {\n    /** Start cell reference (e.g., 'A1') */\n    start: string;\n    /** End cell reference (e.g., 'D10') */\n    end: string;\n  };\n  /** Table style */\n  style?: 'TableStyleLight1' | 'TableStyleLight2' | 'TableStyleLight3' | 'TableStyleLight4' | 'TableStyleLight5' | 'TableStyleLight6' | 'TableStyleLight7' | 'TableStyleLight8' | 'TableStyleLight9' | 'TableStyleLight10' | 'TableStyleLight11' | 'TableStyleLight12' | 'TableStyleLight13' | 'TableStyleLight14' | 'TableStyleLight15' | 'TableStyleLight16' | 'TableStyleLight17' | 'TableStyleLight18' | 'TableStyleLight19' | 'TableStyleLight20' | 'TableStyleLight21' | 'TableStyleMedium1' | 'TableStyleMedium2' | 'TableStyleMedium3' | 'TableStyleMedium4' | 'TableStyleMedium5' | 'TableStyleMedium6' | 'TableStyleMedium7' | 'TableStyleMedium8' | 'TableStyleMedium9' | 'TableStyleMedium10' | 'TableStyleMedium11' | 'TableStyleMedium12' | 'TableStyleMedium13' | 'TableStyleMedium14' | 'TableStyleMedium15' | 'TableStyleMedium16' | 'TableStyleMedium17' | 'TableStyleMedium18' | 'TableStyleMedium19' | 'TableStyleMedium20' | 'TableStyleMedium21' | 'TableStyleMedium22' | 'TableStyleMedium23' | 'TableStyleMedium24' | 'TableStyleMedium25' | 'TableStyleMedium26' | 'TableStyleMedium27' | 'TableStyleMedium28' | 'TableStyleDark1' | 'TableStyleDark2' | 'TableStyleDark3' | 'TableStyleDark4' | 'TableStyleDark5' | 'TableStyleDark6' | 'TableStyleDark7' | 'TableStyleDark8' | 'TableStyleDark9' | 'TableStyleDark10' | 'TableStyleDark11';\n  /** Whether to show header row */\n  headerRow?: boolean;\n  /** Whether to show total row */\n  totalRow?: boolean;\n  /** Column definitions */\n  columns?: Array<{\n    /** Column name */\n    name: string;\n    /** Column filter button */\n    filterButton?: boolean;\n    /** Totals row function */\n    totalsRowFunction?: 'none' | 'sum' | 'min' | 'max' | 'average' | 'count' | 'countNums' | 'stdDev' | 'var' | 'custom';\n    /** Totals row formula */\n    totalsRowFormula?: string;\n  }>;\n} ","/**\r\n * Style-specific type definitions\r\n */\r\n\r\nimport { \r\n  Color, \r\n  HorizontalAlignment, \r\n  VerticalAlignment, \r\n  BorderStyle, \r\n  FontStyle \r\n} from './core.types';\r\n\r\n/**\r\n * Font configuration interface\r\n */\r\nexport interface IFont {\r\n  /** Font name */\r\n  name?: string;\r\n  /** Font size */\r\n  size?: number;\r\n  /** Font style */\r\n  style?: FontStyle;\r\n  /** Font color */\r\n  color?: Color;\r\n  /** Whether the font is bold */\r\n  bold?: boolean;\r\n  /** Whether the font is italic */\r\n  italic?: boolean;\r\n  /** Whether the font is underlined */\r\n  underline?: boolean;\r\n  /** Whether the font is strikethrough */\r\n  strikethrough?: boolean;\r\n  /** Font family */\r\n  family?: string;\r\n  /** Font scheme */\r\n  scheme?: 'major' | 'minor' | 'none';\r\n}\r\n\r\n/**\r\n * Border configuration interface\r\n */\r\nexport interface IBorder {\r\n  /** Border style */\r\n  style?: BorderStyle;\r\n  /** Border color */\r\n  color?: Color;\r\n  /** Border width */\r\n  width?: number;\r\n}\r\n\r\n/**\r\n * Border sides interface\r\n */\r\nexport interface IBorderSides {\r\n  /** Top border */\r\n  top?: IBorder;\r\n  /** Left border */\r\n  left?: IBorder;\r\n  /** Bottom border */\r\n  bottom?: IBorder;\r\n  /** Right border */\r\n  right?: IBorder;\r\n  /** Diagonal border */\r\n  diagonal?: IBorder;\r\n  /** Diagonal direction */\r\n  diagonalDirection?: 'up' | 'down' | 'both';\r\n}\r\n\r\n/**\r\n * Fill pattern interface\r\n */\r\nexport interface IFill {\r\n  /** Fill type */\r\n  type: 'pattern' | 'gradient';\r\n  /** Pattern type (for pattern fills) */\r\n  pattern?: 'none' | 'solid' | 'darkGray' | 'mediumGray' | 'lightGray' | 'gray125' | 'gray0625' | 'darkHorizontal' | 'darkVertical' | 'darkDown' | 'darkUp' | 'darkGrid' | 'darkTrellis' | 'lightHorizontal' | 'lightVertical' | 'lightDown' | 'lightUp' | 'lightGrid' | 'lightTrellis';\r\n  /** Background color */\r\n  backgroundColor?: Color;\r\n  /** Foreground color */\r\n  foregroundColor?: Color;\r\n  /** Gradient type (for gradient fills) */\r\n  gradient?: 'linear' | 'path';\r\n  /** Gradient stops */\r\n  stops?: Array<{\r\n    position: number;\r\n    color: Color;\r\n  }>;\r\n  /** Gradient angle (for linear gradients) */\r\n  angle?: number;\r\n}\r\n\r\n/**\r\n * Alignment configuration interface\r\n */\r\nexport interface IAlignment {\r\n  /** Horizontal alignment */\r\n  horizontal?: HorizontalAlignment;\r\n  /** Vertical alignment */\r\n  vertical?: VerticalAlignment;\r\n  /** Text rotation (0-180 degrees) */\r\n  textRotation?: number;\r\n  /** Whether to wrap text */\r\n  wrapText?: boolean;\r\n  /** Whether to shrink text to fit */\r\n  shrinkToFit?: boolean;\r\n  /** Indent level */\r\n  indent?: number;\r\n  /** Whether to merge cells */\r\n  mergeCell?: boolean;\r\n  /** Reading order */\r\n  readingOrder?: 'left-to-right' | 'right-to-left';\r\n}\r\n\r\n/**\r\n * Protection configuration interface\r\n */\r\nexport interface IProtection {\r\n  /** Whether the cell is locked */\r\n  locked?: boolean;\r\n  /** Whether the cell is hidden */\r\n  hidden?: boolean;\r\n}\r\n\r\n/**\r\n * Conditional formatting interface\r\n */\r\nexport interface IConditionalFormat {\r\n  /** Condition type */\r\n  type: 'cellIs' | 'containsText' | 'beginsWith' | 'endsWith' | 'containsBlanks' | 'notContainsBlanks' | 'containsErrors' | 'notContainsErrors' | 'timePeriod' | 'top' | 'bottom' | 'aboveAverage' | 'belowAverage' | 'duplicateValues' | 'uniqueValues' | 'expression' | 'colorScale' | 'dataBar' | 'iconSet';\r\n  /** Condition operator */\r\n  operator?: 'between' | 'notBetween' | 'equal' | 'notEqual' | 'greaterThan' | 'lessThan' | 'greaterThanOrEqual' | 'lessThanOrEqual';\r\n  /** Condition values */\r\n  values?: Array<string | number | Date>;\r\n  /** Condition formula */\r\n  formula?: string;\r\n  /** Style to apply when condition is met */\r\n  style?: IStyle;\r\n  /** Priority of the condition */\r\n  priority?: number;\r\n  /** Whether to stop if true */\r\n  stopIfTrue?: boolean;\r\n}\r\n\r\n/**\r\n * Main style interface\r\n */\r\nexport interface IStyle {\r\n  /** Font configuration */\r\n  font?: IFont;\r\n  /** Border configuration */\r\n  border?: IBorderSides;\r\n  /** Fill configuration */\r\n  fill?: IFill;\r\n  /** Alignment configuration */\r\n  alignment?: IAlignment;\r\n  /** Protection configuration */\r\n  protection?: IProtection;\r\n  /** Conditional formatting */\r\n  conditionalFormats?: IConditionalFormat[];\r\n  /** Number format */\r\n  numberFormat?: string;\r\n  /** Whether to apply alternating row colors */\r\n  striped?: boolean;\r\n  /** Custom CSS-like properties */\r\n  custom?: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * Style preset types\r\n */\r\nexport enum StylePreset {\r\n  HEADER = 'header',\r\n  SUBHEADER = 'subheader',\r\n  DATA = 'data',\r\n  FOOTER = 'footer',\r\n  TOTAL = 'total',\r\n  HIGHLIGHT = 'highlight',\r\n  WARNING = 'warning',\r\n  ERROR = 'error',\r\n  SUCCESS = 'success',\r\n  INFO = 'info'\r\n}\r\n\r\n/**\r\n * Style theme interface\r\n */\r\nexport interface IStyleTheme {\r\n  /** Theme name */\r\n  name: string;\r\n  /** Theme description */\r\n  description?: string;\r\n  /** Color palette */\r\n  colors: {\r\n    primary: Color;\r\n    secondary: Color;\r\n    accent: Color;\r\n    background: Color;\r\n    text: Color;\r\n    border: Color;\r\n    success: Color;\r\n    warning: Color;\r\n    error: Color;\r\n    info: Color;\r\n  };\r\n  /** Font family */\r\n  fontFamily: string;\r\n  /** Base font size */\r\n  fontSize: number;\r\n  /** Style presets */\r\n  presets: Record<StylePreset, IStyle>;\r\n}\r\n\r\n/**\r\n * Style builder interface\r\n */\r\nexport interface IStyleBuilder {\r\n  /** Set font name */\r\n  fontName(name: string): IStyleBuilder;\r\n  /** Set font size */\r\n  fontSize(size: number): IStyleBuilder;\r\n  /** Set font style */\r\n  fontStyle(style: FontStyle): IStyleBuilder;\r\n  /** Set font color */\r\n  fontColor(color: Color): IStyleBuilder;\r\n  /** Make font bold */\r\n  fontBold(): IStyleBuilder;\r\n  /** Make font italic */\r\n  fontItalic(): IStyleBuilder;\r\n  /** Make font underlined */\r\n  fontUnderline(): IStyleBuilder;\r\n  /** Set border */\r\n  border(style: BorderStyle, color?: Color): IStyleBuilder;\r\n  /** Set specific border */\r\n  borderTop(style: BorderStyle, color?: Color): IStyleBuilder;\r\n  borderLeft(style: BorderStyle, color?: Color): IStyleBuilder;\r\n  borderBottom(style: BorderStyle, color?: Color): IStyleBuilder;\r\n  borderRight(style: BorderStyle, color?: Color): IStyleBuilder;\r\n  /** Set background color */\r\n  backgroundColor(color: Color): IStyleBuilder;\r\n  /** Set horizontal alignment */\r\n  horizontalAlign(alignment: HorizontalAlignment): IStyleBuilder;\r\n  /** Set vertical alignment */\r\n  verticalAlign(alignment: VerticalAlignment): IStyleBuilder;\r\n  /** Center align text */\r\n  centerAlign(): IStyleBuilder;\r\n  /** Left align text */\r\n  leftAlign(): IStyleBuilder;\r\n  /** Right align text */\r\n  rightAlign(): IStyleBuilder;\r\n  /** Wrap text */\r\n  wrapText(): IStyleBuilder;\r\n  /** Set number format */\r\n  numberFormat(format: string): IStyleBuilder;\r\n  /** Set striped rows */\r\n  striped(): IStyleBuilder;\r\n  /** Add conditional formatting */\r\n  conditionalFormat(format: IConditionalFormat): IStyleBuilder;\r\n  /** Build the final style */\r\n  build(): IStyle;\r\n} ","/**\r\n * ExcelReader - Class for reading Excel files and converting them to JSON\r\n */\r\n\r\nimport ExcelJS from 'exceljs';\r\nimport {\r\n  IExcelReaderOptions,\r\n  IJsonWorkbook,\r\n  IJsonSheet,\r\n  IJsonRow,\r\n  IJsonCell,\r\n  OutputFormat,\r\n  IDetailedFormat,\r\n  IDetailedCell,\r\n  IFlatFormat,\r\n  IFlatFormatMultiSheet,\r\n  ExcelReaderResult\r\n} from '../types/reader.types';\r\nimport { IErrorResult, ErrorType } from '../types/core.types';\r\n\r\n/**\r\n * ExcelReader class for reading Excel files and converting to JSON\r\n */\r\nexport class ExcelReader {\r\n  /**\r\n   * Read Excel file from ArrayBuffer\r\n   */\r\n  static async fromBuffer<T extends OutputFormat = OutputFormat.WORKSHEET>(\r\n    buffer: ArrayBuffer,\r\n    options: IExcelReaderOptions = {}\r\n  ): Promise<ExcelReaderResult<T>> {\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      const workbook = new ExcelJS.Workbook();\r\n      await workbook.xlsx.load(buffer);\r\n\r\n      const outputFormat = (options.outputFormat || OutputFormat.WORKSHEET) as OutputFormat;\r\n      const processingTime = Date.now() - startTime;\r\n\r\n      let result: unknown;\r\n\r\n      switch (outputFormat) {\r\n        case OutputFormat.DETAILED:\r\n          result = this.convertToDetailedFormat(workbook, options);\r\n          break;\r\n        case OutputFormat.FLAT:\r\n          result = this.convertToFlatFormat(workbook, options);\r\n          break;\r\n        case OutputFormat.WORKSHEET:\r\n        default:\r\n          result = this.convertWorkbookToJson(workbook, options);\r\n          break;\r\n      }\r\n\r\n      // Apply mapper function if provided\r\n      if (options.mapper) {\r\n        try {\r\n          // Apply mapper based on output format\r\n          switch (outputFormat) {\r\n            case OutputFormat.DETAILED:\r\n              result = (options.mapper as (data: IDetailedFormat) => unknown)(result as IDetailedFormat);\r\n              break;\r\n            case OutputFormat.FLAT:\r\n              result = (options.mapper as (data: IFlatFormat | IFlatFormatMultiSheet) => unknown)(result as IFlatFormat | IFlatFormatMultiSheet);\r\n              break;\r\n            case OutputFormat.WORKSHEET:\r\n            default:\r\n              result = (options.mapper as (data: IJsonWorkbook) => unknown)(result as IJsonWorkbook);\r\n              break;\r\n          }\r\n        } catch (mapperError) {\r\n          const errorResult: IErrorResult = {\r\n            success: false,\r\n            error: {\r\n              type: ErrorType.VALIDATION_ERROR,\r\n              message: mapperError instanceof Error \r\n                ? `Mapper function error: ${mapperError.message}` \r\n                : 'Error in mapper function',\r\n              stack: mapperError instanceof Error ? (mapperError.stack || '') : ''\r\n            }\r\n          };\r\n          return {\r\n            ...errorResult,\r\n            processingTime: Date.now() - startTime\r\n          } as unknown as ExcelReaderResult<T>;\r\n        }\r\n      }\r\n\r\n      const successResult = {\r\n        success: true as const,\r\n        data: result,\r\n        processingTime\r\n      };\r\n\r\n      return successResult as ExcelReaderResult<T>;\r\n    } catch (error) {\r\n      const errorResult: IErrorResult = {\r\n        success: false,\r\n        error: {\r\n          type: ErrorType.VALIDATION_ERROR,\r\n          message: error instanceof Error ? error.message : 'Error reading Excel file',\r\n          stack: error instanceof Error ? (error.stack || '') : ''\r\n        }\r\n      };\r\n\r\n      const errorResponse = {\r\n        success: false as const,\r\n        error: errorResult.error,\r\n        processingTime: Date.now() - startTime\r\n      };\r\n      return errorResponse as unknown as ExcelReaderResult<T>;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read Excel file from Blob\r\n   */\r\n  static async fromBlob<T extends OutputFormat = OutputFormat.WORKSHEET>(\r\n    blob: Blob,\r\n    options: IExcelReaderOptions = {}\r\n  ): Promise<ExcelReaderResult<T>> {\r\n    const arrayBuffer = await blob.arrayBuffer();\r\n    return this.fromBuffer<T>(arrayBuffer, options);\r\n  }\r\n\r\n  /**\r\n   * Read Excel file from File (browser)\r\n   */\r\n  static async fromFile<T extends OutputFormat = OutputFormat.WORKSHEET>(\r\n    file: File,\r\n    options: IExcelReaderOptions = {}\r\n  ): Promise<ExcelReaderResult<T>> {\r\n    return this.fromBlob<T>(file, options);\r\n  }\r\n\r\n  /**\r\n   * Read Excel file from path (Node.js)\r\n   * Note: This method only works in Node.js environment\r\n   */\r\n  /**\r\n   * Read Excel file from path (Node.js only)\r\n   * Note: This method only works in Node.js environment\r\n   */\r\n  static async fromPath<T extends OutputFormat = OutputFormat.WORKSHEET>(\r\n    filePath: string,\r\n    options: IExcelReaderOptions = {}\r\n  ): Promise<ExcelReaderResult<T>> {\r\n    try {\r\n      // Dynamic import - only loads fs in Node.js environment\r\n      // This allows the code to work in both browser and Node.js\r\n      // @ts-expect-error - fs/promises is a Node.js module, not available in browser\r\n      const fs = await import('fs/promises');\r\n      const buffer = await fs.readFile(filePath);\r\n      const arrayBuffer = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\r\n      return this.fromBuffer(arrayBuffer, options);\r\n    } catch (error) {\r\n      // Check if error is because fs is not available (browser environment)\r\n      const isBrowserError = error instanceof Error && \r\n        (error.message.includes('Cannot find module') || \r\n         error.message.includes('fs') ||\r\n         (typeof window !== 'undefined'));\r\n      \r\n      const errorResult: IErrorResult = {\r\n        success: false,\r\n        error: {\r\n          type: ErrorType.VALIDATION_ERROR,\r\n          message: isBrowserError \r\n            ? 'fromPath() method requires Node.js environment. Use fromFile() or fromBlob() in browser.'\r\n            : (error instanceof Error ? error.message : 'Error reading file from path'),\r\n          stack: error instanceof Error ? (error.stack || '') : ''\r\n        }\r\n      };\r\n\r\n      const errorResponse = {\r\n        ...errorResult,\r\n        processingTime: 0\r\n      };\r\n      return errorResponse as unknown as ExcelReaderResult<T>;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert ExcelJS Workbook to JSON\r\n   */\r\n  private static convertWorkbookToJson(\r\n    workbook: ExcelJS.Workbook,\r\n    options: IExcelReaderOptions\r\n  ): IJsonWorkbook {\r\n    const {\r\n      includeEmptyRows = false,\r\n      useFirstRowAsHeaders = false,\r\n      headers,\r\n      sheetName,\r\n      startRow = 1,\r\n      endRow,\r\n      startColumn = 1,\r\n      endColumn,\r\n      includeFormatting = false,\r\n      includeFormulas = false,\r\n      datesAsISO = true\r\n    } = options;\r\n\r\n    // Get metadata\r\n    const metadata = {\r\n      title: workbook.title,\r\n      author: workbook.creator,\r\n      company: workbook.company,\r\n      created: workbook.created,\r\n      modified: workbook.modified,\r\n      description: workbook.description\r\n    };\r\n\r\n    // Filter sheets\r\n    let sheetsToProcess: ExcelJS.Worksheet[] = [];\r\n    \r\n    if (sheetName !== undefined) {\r\n      if (typeof sheetName === 'number') {\r\n        const sheet = workbook.worksheets[sheetName];\r\n        if (sheet) sheetsToProcess.push(sheet);\r\n      } else {\r\n        const sheet = workbook.getWorksheet(sheetName);\r\n        if (sheet) sheetsToProcess.push(sheet);\r\n      }\r\n    } else {\r\n      sheetsToProcess = workbook.worksheets;\r\n    }\r\n\r\n    // Convert each sheet\r\n    const sheets: IJsonSheet[] = sheetsToProcess.map((worksheet) => {\r\n      const sheetOptions: {\r\n        includeEmptyRows: boolean;\r\n        useFirstRowAsHeaders: boolean;\r\n        headers?: string[] | Record<number, string>;\r\n        startRow: number;\r\n        endRow?: number;\r\n        startColumn: number;\r\n        endColumn?: number;\r\n        includeFormatting: boolean;\r\n        includeFormulas: boolean;\r\n        datesAsISO: boolean;\r\n      } = {\r\n        includeEmptyRows: includeEmptyRows ?? false,\r\n        useFirstRowAsHeaders: useFirstRowAsHeaders ?? false,\r\n        startRow: startRow ?? 1,\r\n        startColumn: startColumn ?? 1,\r\n        includeFormatting: includeFormatting ?? false,\r\n        includeFormulas: includeFormulas ?? false,\r\n        datesAsISO: datesAsISO ?? true\r\n      };\r\n\r\n      if (headers !== undefined) {\r\n        sheetOptions.headers = headers;\r\n      }\r\n      if (endRow !== undefined) {\r\n        sheetOptions.endRow = endRow;\r\n      }\r\n      if (endColumn !== undefined) {\r\n        sheetOptions.endColumn = endColumn;\r\n      }\r\n\r\n      return this.convertSheetToJson(worksheet, sheetOptions);\r\n    });\r\n\r\n    const workbookResult: IJsonWorkbook = {\r\n      sheets,\r\n      totalSheets: sheets.length\r\n    };\r\n\r\n    // Only add metadata if it has at least one property\r\n    const hasMetadata = Object.values(metadata).some(val => val !== undefined && val !== null);\r\n    if (hasMetadata) {\r\n      workbookResult.metadata = metadata;\r\n    }\r\n\r\n    return workbookResult;\r\n  }\r\n\r\n  /**\r\n   * Convert ExcelJS Worksheet to JSON\r\n   */\r\n  private static convertSheetToJson(\r\n    worksheet: ExcelJS.Worksheet,\r\n    options: {\r\n      includeEmptyRows: boolean;\r\n      useFirstRowAsHeaders: boolean;\r\n      headers?: string[] | Record<number, string>;\r\n      startRow: number;\r\n      endRow?: number;\r\n      startColumn: number;\r\n      endColumn?: number;\r\n      includeFormatting: boolean;\r\n      includeFormulas: boolean;\r\n      datesAsISO: boolean;\r\n    }\r\n  ): IJsonSheet {\r\n    const {\r\n      includeEmptyRows,\r\n      useFirstRowAsHeaders,\r\n      headers,\r\n      startRow,\r\n      endRow,\r\n      startColumn,\r\n      endColumn,\r\n      includeFormatting,\r\n      includeFormulas,\r\n      datesAsISO\r\n    } = options;\r\n\r\n    const rows: IJsonRow[] = [];\r\n    let headerRow: string[] | undefined;\r\n    let maxColumns = 0;\r\n\r\n    // Determine row range\r\n    const actualStartRow = Math.max(startRow, 1);\r\n    const actualEndRow = endRow || worksheet.rowCount || worksheet.lastRow?.number || 1;\r\n    const actualStartCol = Math.max(startColumn, 1);\r\n    const actualEndCol = endColumn || worksheet.columnCount || worksheet.lastColumn?.number || 1;\r\n\r\n    // Process rows\r\n    for (let rowNum = actualStartRow; rowNum <= actualEndRow; rowNum++) {\r\n      const excelRow = worksheet.getRow(rowNum);\r\n      const cells: IJsonCell[] = [];\r\n      let hasData = false;\r\n\r\n      // Process cells in row\r\n      for (let colNum = actualStartCol; colNum <= actualEndCol; colNum++) {\r\n        const cell = excelRow.getCell(colNum);\r\n        \r\n        // Skip if cell is empty and we're not including empty rows\r\n        if (!cell.value && !includeEmptyRows) {\r\n          continue;\r\n        }\r\n\r\n        const jsonCell = this.convertCellToJson(cell, {\r\n          includeFormatting,\r\n          includeFormulas,\r\n          datesAsISO\r\n        });\r\n\r\n        cells.push(jsonCell);\r\n        hasData = true;\r\n      }\r\n\r\n      // Track max columns\r\n      if (cells.length > maxColumns) {\r\n        maxColumns = cells.length;\r\n      }\r\n\r\n      // Skip empty rows if configured\r\n      if (!hasData && !includeEmptyRows) {\r\n        continue;\r\n      }\r\n\r\n      // Handle headers\r\n      if (useFirstRowAsHeaders && rowNum === actualStartRow) {\r\n        headerRow = cells.map(cell => {\r\n          if (headers && Array.isArray(headers)) {\r\n            return headers[cells.indexOf(cell)] || String(cell.value || '');\r\n          } else if (headers && typeof headers === 'object') {\r\n            return headers[actualStartCol + cells.indexOf(cell)] || String(cell.value || '');\r\n          }\r\n          return String(cell.value || '');\r\n        });\r\n        continue; // Skip header row in data\r\n      }\r\n\r\n      // Create row data object if headers are used\r\n      let rowData: Record<string, unknown> | undefined;\r\n      if (useFirstRowAsHeaders && headerRow) {\r\n        rowData = {};\r\n        cells.forEach((cell, index) => {\r\n          const header = headerRow![index] || `column_${index + 1}`;\r\n          rowData![header] = cell.value;\r\n        });\r\n      }\r\n\r\n      const jsonRow: IJsonRow = {\r\n        rowNumber: rowNum,\r\n        cells\r\n      };\r\n\r\n      if (rowData) {\r\n        jsonRow.data = rowData;\r\n      }\r\n\r\n      rows.push(jsonRow);\r\n    }\r\n\r\n    const sheet: IJsonSheet = {\r\n      name: worksheet.name,\r\n      index: worksheet.id || 0,\r\n      rows,\r\n      totalRows: rows.length,\r\n      totalColumns: maxColumns\r\n    };\r\n\r\n    if (headerRow) {\r\n      sheet.headers = headerRow;\r\n    }\r\n\r\n    return sheet;\r\n  }\r\n\r\n  /**\r\n   * Convert ExcelJS Cell to JSON\r\n   */\r\n  private static convertCellToJson(\r\n    cell: ExcelJS.Cell,\r\n    options: {\r\n      includeFormatting: boolean;\r\n      includeFormulas: boolean;\r\n      datesAsISO: boolean;\r\n    }\r\n  ): IJsonCell {\r\n    const { includeFormatting, includeFormulas, datesAsISO } = options;\r\n\r\n    let value: unknown = cell.value;\r\n    let type: string | undefined;\r\n\r\n    // Determine type and convert value\r\n    if (cell.type === ExcelJS.ValueType.Null || cell.value === null || cell.value === undefined) {\r\n      value = null;\r\n      type = 'null';\r\n    } else if (cell.type === ExcelJS.ValueType.Number) {\r\n      value = cell.value as number;\r\n      type = 'number';\r\n    } else if (cell.type === ExcelJS.ValueType.String) {\r\n      value = cell.value as string;\r\n      type = 'string';\r\n    } else if (cell.type === ExcelJS.ValueType.Date) {\r\n      const dateValue = cell.value as Date;\r\n      value = datesAsISO ? dateValue.toISOString() : dateValue;\r\n      type = 'date';\r\n    } else if (cell.type === ExcelJS.ValueType.Boolean) {\r\n      value = cell.value as boolean;\r\n      type = 'boolean';\r\n    } else if (cell.type === ExcelJS.ValueType.Formula) {\r\n      if (includeFormulas && cell.formula) {\r\n        value = cell.result || cell.value;\r\n        type = 'formula';\r\n      } else {\r\n        value = cell.result || cell.value;\r\n        type = typeof cell.result === 'number' ? 'number' : typeof cell.result === 'string' ? 'string' : 'unknown';\r\n      }\r\n    } else if (cell.type === ExcelJS.ValueType.Hyperlink) {\r\n      // Handle hyperlink - ExcelJS stores hyperlinks as objects with text and hyperlink properties\r\n      const hyperlinkValue = cell.value as { text?: string; hyperlink?: string } | string;\r\n      if (typeof hyperlinkValue === 'object' && hyperlinkValue !== null) {\r\n        value = hyperlinkValue.text || hyperlinkValue.hyperlink || cell.value;\r\n      } else {\r\n        value = hyperlinkValue;\r\n      }\r\n      type = 'hyperlink';\r\n    } else {\r\n      value = cell.value;\r\n      type = 'unknown';\r\n    }\r\n\r\n    const jsonCell: IJsonCell = {\r\n      value,\r\n      type,\r\n      reference: cell.address\r\n    };\r\n\r\n    // Add formatted value if requested\r\n    if (includeFormatting && cell.numFmt) {\r\n      // Try to get formatted value (ExcelJS doesn't always provide this easily)\r\n      jsonCell.formattedValue = String(value);\r\n    }\r\n\r\n    // Add formula if requested\r\n    if (includeFormulas && cell.formula) {\r\n      jsonCell.formula = cell.formula;\r\n    }\r\n\r\n    // Add comment if exists\r\n    if (cell.note) {\r\n      // ExcelJS stores comments as Note objects or strings\r\n      const note = cell.note;\r\n      if (typeof note === 'string') {\r\n        jsonCell.comment = note;\r\n      } else if (note && typeof note === 'object' && 'texts' in note) {\r\n        // Note object with texts array\r\n        const texts = (note as any).texts;\r\n        if (Array.isArray(texts) && texts.length > 0) {\r\n          jsonCell.comment = texts.map((t: any) => t.text || '').join('');\r\n        }\r\n      } else if (note && typeof note === 'object' && 'text' in note) {\r\n        jsonCell.comment = String((note as any).text);\r\n      }\r\n    }\r\n\r\n    return jsonCell;\r\n  }\r\n\r\n  /**\r\n   * Convert workbook to detailed format (with position information)\r\n   */\r\n  private static convertToDetailedFormat(\r\n    workbook: ExcelJS.Workbook,\r\n    options: IExcelReaderOptions\r\n  ): IDetailedFormat {\r\n    const {\r\n      includeEmptyRows = false,\r\n      includeFormatting = false,\r\n      includeFormulas = false,\r\n      datesAsISO = true,\r\n      sheetName,\r\n      startRow = 1,\r\n      endRow,\r\n      startColumn = 1,\r\n      endColumn\r\n    } = options;\r\n\r\n    const cells: IDetailedCell[] = [];\r\n\r\n    // Get metadata\r\n    const metadata = {\r\n      title: workbook.title,\r\n      author: workbook.creator,\r\n      company: workbook.company,\r\n      created: workbook.created,\r\n      modified: workbook.modified,\r\n      description: workbook.description\r\n    };\r\n\r\n    // Filter sheets\r\n    let sheetsToProcess: ExcelJS.Worksheet[] = [];\r\n    \r\n    if (sheetName !== undefined) {\r\n      if (typeof sheetName === 'number') {\r\n        const sheet = workbook.worksheets[sheetName];\r\n        if (sheet) sheetsToProcess.push(sheet);\r\n      } else {\r\n        const sheet = workbook.getWorksheet(sheetName);\r\n        if (sheet) sheetsToProcess.push(sheet);\r\n      }\r\n    } else {\r\n      sheetsToProcess = workbook.worksheets;\r\n    }\r\n\r\n    // Process each sheet\r\n    for (const worksheet of sheetsToProcess) {\r\n      const actualStartRow = Math.max(startRow, 1);\r\n      const actualEndRow = endRow || worksheet.rowCount || worksheet.lastRow?.number || 1;\r\n      const actualStartCol = Math.max(startColumn, 1);\r\n      const actualEndCol = endColumn || worksheet.columnCount || worksheet.lastColumn?.number || 1;\r\n\r\n      for (let rowNum = actualStartRow; rowNum <= actualEndRow; rowNum++) {\r\n        const excelRow = worksheet.getRow(rowNum);\r\n\r\n        for (let colNum = actualStartCol; colNum <= actualEndCol; colNum++) {\r\n          const cell = excelRow.getCell(colNum);\r\n\r\n          // Skip empty cells if configured\r\n          if (!cell.value && !includeEmptyRows) {\r\n            continue;\r\n          }\r\n\r\n          // Convert column number to letter (1 = A, 2 = B, etc.)\r\n          const columnLetter = this.numberToColumnLetter(colNum);\r\n          const cellValue = this.getCellValue(cell, { includeFormatting, includeFormulas, datesAsISO });\r\n\r\n          const detailedCell: IDetailedCell = {\r\n            value: cellValue.value,\r\n            text: String(cellValue.value ?? ''),\r\n            column: colNum,\r\n            columnLetter,\r\n            row: rowNum,\r\n            reference: cell.address || `${columnLetter}${rowNum}`,\r\n            sheet: worksheet.name\r\n          };\r\n\r\n          if (cellValue.type) {\r\n            detailedCell.type = cellValue.type;\r\n          }\r\n          if (cellValue.formattedValue) {\r\n            detailedCell.formattedValue = cellValue.formattedValue;\r\n          }\r\n          if (cellValue.formula) {\r\n            detailedCell.formula = cellValue.formula;\r\n          }\r\n\r\n          // Add comment if exists\r\n          if (cell.note) {\r\n            const note = cell.note;\r\n            if (typeof note === 'string') {\r\n              detailedCell.comment = note;\r\n            } else if (note && typeof note === 'object' && 'texts' in note) {\r\n              // Note object with texts array\r\n              const texts = (note as any).texts;\r\n              if (Array.isArray(texts) && texts.length > 0) {\r\n                detailedCell.comment = texts.map((t: any) => t.text || '').join('');\r\n              }\r\n            } else if (note && typeof note === 'object' && 'text' in note) {\r\n              detailedCell.comment = String((note as any).text);\r\n            }\r\n          }\r\n\r\n          cells.push(detailedCell);\r\n        }\r\n      }\r\n    }\r\n\r\n    const result: IDetailedFormat = {\r\n      cells,\r\n      totalCells: cells.length\r\n    };\r\n\r\n    const hasMetadata = Object.values(metadata).some(val => val !== undefined && val !== null);\r\n    if (hasMetadata) {\r\n      result.metadata = metadata;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Convert workbook to flat format (just data)\r\n   */\r\n  private static convertToFlatFormat(\r\n    workbook: ExcelJS.Workbook,\r\n    options: IExcelReaderOptions\r\n  ): IFlatFormat | IFlatFormatMultiSheet {\r\n    const {\r\n      useFirstRowAsHeaders = false,\r\n      includeEmptyRows = false,\r\n      sheetName,\r\n      startRow = 1,\r\n      endRow,\r\n      startColumn = 1,\r\n      endColumn\r\n    } = options;\r\n\r\n    // Get metadata\r\n    const metadata = {\r\n      title: workbook.title,\r\n      author: workbook.creator,\r\n      company: workbook.company,\r\n      created: workbook.created,\r\n      modified: workbook.modified,\r\n      description: workbook.description\r\n    };\r\n\r\n    // Filter sheets\r\n    let sheetsToProcess: ExcelJS.Worksheet[] = [];\r\n    \r\n    if (sheetName !== undefined) {\r\n      if (typeof sheetName === 'number') {\r\n        const sheet = workbook.worksheets[sheetName];\r\n        if (sheet) sheetsToProcess.push(sheet);\r\n      } else {\r\n        const sheet = workbook.getWorksheet(sheetName);\r\n        if (sheet) sheetsToProcess.push(sheet);\r\n      }\r\n    } else {\r\n      sheetsToProcess = workbook.worksheets;\r\n    }\r\n\r\n    // If single sheet, return single format\r\n    if (sheetsToProcess.length === 1) {\r\n      const worksheet = sheetsToProcess[0]!;\r\n      const flatOptions: {\r\n        useFirstRowAsHeaders: boolean;\r\n        includeEmptyRows: boolean;\r\n        startRow: number;\r\n        endRow?: number;\r\n        startColumn?: number;\r\n        endColumn?: number;\r\n      } = {\r\n        useFirstRowAsHeaders,\r\n        includeEmptyRows,\r\n        startRow\r\n      };\r\n\r\n      if (endRow !== undefined) {\r\n        flatOptions.endRow = endRow;\r\n      }\r\n      if (startColumn !== undefined) {\r\n        flatOptions.startColumn = startColumn;\r\n      }\r\n      if (endColumn !== undefined) {\r\n        flatOptions.endColumn = endColumn;\r\n      }\r\n\r\n      const flatData = this.convertSheetToFlat(worksheet, flatOptions);\r\n      return flatData;\r\n    }\r\n\r\n    // Multiple sheets - return multi-sheet format\r\n    const sheets: Record<string, IFlatFormat> = {};\r\n    \r\n    for (const worksheet of sheetsToProcess) {\r\n      const flatOptions: {\r\n        useFirstRowAsHeaders: boolean;\r\n        includeEmptyRows: boolean;\r\n        startRow: number;\r\n        endRow?: number;\r\n        startColumn?: number;\r\n        endColumn?: number;\r\n      } = {\r\n        useFirstRowAsHeaders,\r\n        includeEmptyRows,\r\n        startRow\r\n      };\r\n\r\n      if (endRow !== undefined) {\r\n        flatOptions.endRow = endRow;\r\n      }\r\n      if (startColumn !== undefined) {\r\n        flatOptions.startColumn = startColumn;\r\n      }\r\n      if (endColumn !== undefined) {\r\n        flatOptions.endColumn = endColumn;\r\n      }\r\n\r\n      const flatData = this.convertSheetToFlat(worksheet, flatOptions);\r\n      sheets[worksheet.name] = flatData;\r\n    }\r\n\r\n    const result: IFlatFormatMultiSheet = {\r\n      sheets,\r\n      totalSheets: Object.keys(sheets).length\r\n    };\r\n\r\n    const hasMetadata = Object.values(metadata).some(val => val !== undefined && val !== null);\r\n    if (hasMetadata) {\r\n      result.metadata = metadata;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Convert a single sheet to flat format\r\n   */\r\n  private static convertSheetToFlat(\r\n    worksheet: ExcelJS.Worksheet,\r\n    options: {\r\n      useFirstRowAsHeaders: boolean;\r\n      includeEmptyRows: boolean;\r\n      startRow: number;\r\n      endRow?: number;\r\n      startColumn?: number;\r\n      endColumn?: number;\r\n    }\r\n  ): IFlatFormat {\r\n    const {\r\n      useFirstRowAsHeaders,\r\n      includeEmptyRows,\r\n      startRow,\r\n      endRow,\r\n      startColumn,\r\n      endColumn\r\n    } = options;\r\n\r\n    const actualStartRow = Math.max(startRow, 1);\r\n    const actualEndRow = endRow || worksheet.rowCount || worksheet.lastRow?.number || 1;\r\n    const actualStartCol = Math.max(startColumn || 1, 1);\r\n    const actualEndCol = endColumn || worksheet.columnCount || worksheet.lastColumn?.number || 1;\r\n\r\n    const data: Array<Record<string, unknown> | unknown[]> = [];\r\n    let headers: string[] | undefined;\r\n\r\n    // Get headers if needed\r\n    if (useFirstRowAsHeaders) {\r\n      const headerRow = worksheet.getRow(actualStartRow);\r\n      headers = [];\r\n      for (let colNum = actualStartCol; colNum <= actualEndCol; colNum++) {\r\n        const cell = headerRow.getCell(colNum);\r\n        headers.push(String(cell.value || `Column${colNum}`));\r\n      }\r\n    }\r\n\r\n    // Process data rows\r\n    const dataStartRow = useFirstRowAsHeaders ? actualStartRow + 1 : actualStartRow;\r\n    \r\n    for (let rowNum = dataStartRow; rowNum <= actualEndRow; rowNum++) {\r\n      const excelRow = worksheet.getRow(rowNum);\r\n      const rowValues: unknown[] = [];\r\n      let hasData = false;\r\n\r\n      for (let colNum = actualStartCol; colNum <= actualEndCol; colNum++) {\r\n        const cell = excelRow.getCell(colNum);\r\n        const cellValue = this.getCellValue(cell, { includeFormatting: false, includeFormulas: false, datesAsISO: true });\r\n        rowValues.push(cellValue.value);\r\n        if (cellValue.value !== null && cellValue.value !== undefined && cellValue.value !== '') {\r\n          hasData = true;\r\n        }\r\n      }\r\n\r\n      if (!hasData && !includeEmptyRows) {\r\n        continue;\r\n      }\r\n\r\n      if (useFirstRowAsHeaders && headers) {\r\n        // Convert to object\r\n        const rowObject: Record<string, unknown> = {};\r\n        headers.forEach((header, index) => {\r\n          rowObject[header] = rowValues[index];\r\n        });\r\n        data.push(rowObject);\r\n      } else {\r\n        // Keep as array\r\n        data.push(rowValues);\r\n      }\r\n    }\r\n\r\n    const result: IFlatFormat = {\r\n      data,\r\n      totalRows: data.length,\r\n      sheet: worksheet.name\r\n    };\r\n\r\n    if (headers) {\r\n      result.headers = headers;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get cell value with type information\r\n   */\r\n  private static getCellValue(\r\n    cell: ExcelJS.Cell,\r\n    options: {\r\n      includeFormatting: boolean;\r\n      includeFormulas: boolean;\r\n      datesAsISO: boolean;\r\n    }\r\n  ): {\r\n    value: unknown;\r\n    type?: string;\r\n    formattedValue?: string;\r\n    formula?: string;\r\n  } {\r\n    const { includeFormatting, includeFormulas, datesAsISO } = options;\r\n\r\n    let value: unknown = cell.value;\r\n    let type: string | undefined;\r\n    let formattedValue: string | undefined;\r\n    let formula: string | undefined;\r\n\r\n    if (cell.type === ExcelJS.ValueType.Null || cell.value === null || cell.value === undefined) {\r\n      value = null;\r\n      type = 'null';\r\n    } else if (cell.type === ExcelJS.ValueType.Number) {\r\n      value = cell.value as number;\r\n      type = 'number';\r\n    } else if (cell.type === ExcelJS.ValueType.String) {\r\n      value = cell.value as string;\r\n      type = 'string';\r\n    } else if (cell.type === ExcelJS.ValueType.Date) {\r\n      const dateValue = cell.value as Date;\r\n      value = datesAsISO ? dateValue.toISOString() : dateValue;\r\n      type = 'date';\r\n    } else if (cell.type === ExcelJS.ValueType.Boolean) {\r\n      value = cell.value as boolean;\r\n      type = 'boolean';\r\n    } else if (cell.type === ExcelJS.ValueType.Formula) {\r\n      if (includeFormulas && cell.formula) {\r\n        formula = cell.formula;\r\n        value = cell.result || cell.value;\r\n        type = 'formula';\r\n      } else {\r\n        value = cell.result || cell.value;\r\n        type = typeof cell.result === 'number' ? 'number' : typeof cell.result === 'string' ? 'string' : 'unknown';\r\n      }\r\n    } else if (cell.type === ExcelJS.ValueType.Hyperlink) {\r\n      const hyperlinkValue = cell.value as { text?: string; hyperlink?: string } | string;\r\n      if (typeof hyperlinkValue === 'object' && hyperlinkValue !== null) {\r\n        value = hyperlinkValue.text || hyperlinkValue.hyperlink || cell.value;\r\n      } else {\r\n        value = hyperlinkValue;\r\n      }\r\n      type = 'hyperlink';\r\n    } else {\r\n      value = cell.value;\r\n      type = 'unknown';\r\n    }\r\n\r\n    if (includeFormatting && cell.numFmt) {\r\n      formattedValue = String(value);\r\n    }\r\n\r\n    return {\r\n      value,\r\n      type,\r\n      ...(formattedValue && { formattedValue }),\r\n      ...(formula && { formula })\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Convert column number to letter (1 = A, 2 = B, 27 = AA, etc.)\r\n   */\r\n  private static numberToColumnLetter(columnNumber: number): string {\r\n    let result = '';\r\n    while (columnNumber > 0) {\r\n      columnNumber--;\r\n      result = String.fromCharCode(65 + (columnNumber % 26)) + result;\r\n      columnNumber = Math.floor(columnNumber / 26);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\n"],"names":["EventEmitter","listeners","Map","on","type","listener","options","this","has","set","registration","once","async","priority","stopPropagation","id","generateId","active","timestamp","Date","get","push","sort","a","b","off","listenerId","index","findIndex","reg","splice","offAll","count","length","delete","emit","event","activeListeners","filter","error","console","cleanupInactiveListeners","emitSync","clear","getListeners","getListenerCount","getEventTypes","Array","from","keys","Math","random","toString","substr","CellType","NumberFormat","HorizontalAlignment","VerticalAlignment","BorderStyle","FontStyle","ErrorType","Worksheet","config","tables","currentRow","currentCol","headerPointers","isBuilt","headers","subHeaders","body","footers","images","rowGroups","columnGroups","namedRanges","excelTables","hiddenRows","Set","hiddenColumns","pivotTables","slicers","watermarks","dataConnections","customStyles","theme","constructor","addHeader","header","addSubHeaders","addRow","row","isArray","addFooter","footer","addTable","tableConfig","table","name","showBorders","showStripes","style","finalizeTable","currentTable","Error","getTable","find","addImage","image","groupRows","startRow","endRow","collapsed","start","end","groupColumns","startCol","endCol","addNamedRange","range","scope","rangeString","reference","numberToColumnLetter","col","namedRange","addExcelTable","hideRows","rows","forEach","add","showRows","hideColumns","columns","colNum","columnLetterToNumber","showColumns","addPivotTable","pivotTable","addSlicer","slicer","addWatermark","watermark","addDataConnection","connection","build","workbook","_options","ws","addWorksheet","properties","defaultRowHeight","tabColor","pageSetup","__customStyles","__theme","rowPointer","tableStartRow","i","buildTable","autoFilter","applyAutoFilter","buildLegacyContent","enabled","applyWorksheetAutoFilter","applyViews","protected","protect","protectionPassword","selectLockedCells","selectUnlockedCells","formatCells","formatColumns","formatRows","insertColumns","insertRows","insertHyperlinks","deleteColumns","deleteRows","applyImage","group","applyRowGrouping","applyColumnGrouping","definedNames","excelTable","applyExcelTable","applyAdvancedPrintSettings","applyHiddenRowsColumns","applyPivotTable","applySlicer","applyWatermark","applyDataConnection","addSpacing","cell","getRow","getCell","richText","value","map","run","text","font","size","color","convertColorToExcelJS","bold","italic","underline","strike","strikethrough","processCellValue","mergeCell","maxCols","calculateTableMaxColumns","mergeCells","styles","eachCell","convertStyle","cellProtection","protection","locked","hidden","applyCellDimensions","comment","applyCellComment","validation","applyDataValidation","conditionalFormats","applyConditionalFormatting","buildNestedHeaders","addDataRowRecursive","addFooterRow","applyTableStyle","getMaxColumns","calculateHeaderColSpan","border","top","argb","left","bottom","right","fill","pattern","fgColor","maxDepth","getMaxHeaderDepth","depth","colIndex","headerInfo","getHeaderAtDepth","colSpan","children","child","applyAllMerges","mergeRange","String","childColSpan","applySmartMerges","applySmartMergesForHeader","headerColSpan","childColIndex","reduce","total","childDepth","max","validate","success","data","VALIDATION_ERROR","message","calculateDataColumnPositions","positions","key","columnPositions","footerColPosition","excelRow","footerCell","styleName","getPredefinedStyle","themeStyle","getThemeStyle","numberFormat","numFmt","mergeTo","colPosition","childCell","jump","rowHeight","height","colWidth","getColumn","width","trim","note","dataValidation","allowBlank","formulae","operator","formula1","toISOString","formula2","showErrorMessage","errorMessage","showInputMessage","inputMessage","prompt","cellAddress","address","format","rule","stopIfTrue","formula","values","v","addConditionalFormatting","ref","rules","headerRow","dataEndRow","column","to","lastRow","autoFilterConfig","columnCount","startColumn","endColumn","link","LINK","linkUrl","displayText","mask","hyperlink","mainColPosition","mainCell","convertColor","r","padStart","g","toUpperCase","hex","replace","split","c","join","converted","family","backgroundColor","foregroundColor","bgColor","alignment","horizontal","includes","vertical","wrapText","Boolean","shrinkToFit","indent","textRotation","readingOrder","Object","columnNumber","result","fromCharCode","floor","columnLetter","charCodeAt","imageBuffer","position","match","parseInt","buffer","base64Data","startsWith","binaryString","atob","bytes","Uint8Array","ArrayBuffer","imagePosition","tl","ext","scaleX","scaleY","extension","description","warn","outlineLevel","excelCol","totalsRow","totalRow","showFirstColumn","showLastColumn","showRowStripes","showColumnStripes","filterButton","totalsRowFunction","totalsRowFormula","printHeadersFooters","headerFooter","center","oddHeader","oddFooter","printRepeat","rowsStr","printTitlesRow","colsStr","printTitlesColumn","rowNum","sourceSheet","getWorksheet","pivotConfig","sourceRange","fields","stat","filters","substring","x","views","freezePanes","freezeView","state","xSplit","ySplit","topLeftCell","activeCell","splitPanes","splitConfig","splitView","activePane","paneMap","topLeft","topRight","bottomLeft","bottomRight","viewConfig","view","zoomScale","zoomScaleNormal","showGridLines","showRowColHeaders","showRuler","rightToLeft","zoom","section","rowIndex","autoApplySectionStyles","targetTable","imageConfig","opacity","centerRow","rowCount","centerCol","fontSize","fontColor","model","connectionString","commandText","refresh","credentials","username","integratedSecurity","BuilderEventType","ExcelBuilder","worksheets","currentWorksheet","isBuilding","stats","eventEmitter","cellStyles","enableValidation","enableEvents","enablePerformanceMonitoring","maxWorksheets","maxRowsPerWorksheet","maxColumnsPerWorksheet","memoryLimit","initializeStats","worksheetConfig","defaultColWidth","defaultWorksheetConfig","worksheet","emitEvent","WORKSHEET_ADDED","worksheetName","removeWorksheet","WORKSHEET_REMOVED","setCurrentWorksheet","BUILD_ERROR","stack","startTime","now","BUILD_STARTED","ExcelJS","Workbook","metadata","creator","author","lastModifiedBy","created","modified","title","subject","keywords","category","applyTheme","entries","addStyleToWorkbook","xlsx","writeBuffer","compression","compressionLevel","endTime","buildTime","fileSize","byteLength","successResult","BUILD_COMPLETED","errorResult","generateAndDownload","fileName","buildResult","DOWNLOAD_STARTED","blob","Blob","mimeType","saveAs","DOWNLOAD_COMPLETED","DOWNLOAD_ERROR","saveToFile","filePath","window","nodeModules","fs","Promise","resolve","then","require","path","Buffer","createDir","dir","dirname","mkdir","recursive","code","writeFile","encoding","saveToStream","writeStream","write","toBuffer","toBlob","errors","worksheetValidation","getStats","addCellStyle","getCellStyle","setTheme","getTheme","eventType","removeAllListeners","totalWorksheets","totalCells","memoryUsage","stylesUsed","formulasUsed","conditionalFormatsUsed","performance","headersTime","dataTime","stylesTime","writeTime","excelTheme","colors","dark1","convertColorToTheme","light1","dark2","light2","accent1","accent2","accent3","accent4","accent5","accent6","followedHyperlink","fonts","major","latin","eastAsian","complexScript","minor","OutputFormat","StyleBuilder","CENTER","MIDDLE","create","fontName","fontStyle","fontBold","fontItalic","fontUnderline","borderTop","borderLeft","borderBottom","borderRight","horizontalAlign","verticalAlign","centerAlign","leftAlign","LEFT","rightAlign","RIGHT","striped","conditionalFormat","reset","clone","cloned","JSON","parse","stringify","CellEventType","WorksheetEventType","StylePreset","fromBuffer","load","outputFormat","WORKSHEET","processingTime","DETAILED","convertToDetailedFormat","FLAT","convertToFlatFormat","convertWorkbookToJson","mapper","mapperError","fromBlob","arrayBuffer","fromFile","file","fromPath","readFile","slice","byteOffset","isBrowserError","includeEmptyRows","useFirstRowAsHeaders","sheetName","includeFormatting","includeFormulas","datesAsISO","company","sheetsToProcess","sheet","sheets","sheetOptions","convertSheetToJson","workbookResult","totalSheets","some","val","maxColumns","actualStartRow","actualEndRow","number","actualStartCol","actualEndCol","lastColumn","cells","rowData","hasData","jsonCell","convertCellToJson","indexOf","jsonRow","rowNumber","totalRows","totalColumns","ValueType","Null","Number","dateValue","Formula","Hyperlink","hyperlinkValue","formattedValue","texts","t","cellValue","getCellValue","detailedCell","flatOptions","convertSheetToFlat","flatData","rowValues","rowObject"],"mappings":"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"}